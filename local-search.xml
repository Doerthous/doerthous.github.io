<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>卷积</title>
    <link href="/2021/03/27/%E5%8D%B7%E7%A7%AF/"/>
    <url>/2021/03/27/%E5%8D%B7%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h2><p>本文在参考了许多答案及个别文章的基础上，基于个人的理解，逐步深入对卷积、卷积的作用及其相关概念进行总结。本文结构大致如下：</p><p>1 从几何角度理解卷积的过程。</p><p>2~3 引入卷积的数学定义，并说明卷积如何计算。</p><p>4~5 简要说明卷积在使用过程中会遇到的概念，及卷积在实际工程中的作用。</p><h2 id="1-卷积如何理解"><a href="#1-卷积如何理解" class="headerlink" title="1 卷积如何理解"></a>1 卷积如何理解</h2><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>设一个函数为f(x)，将f(x)<strong>反转</strong>在本文中定义为f(-x)</p><h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>函数图像在某个轴上平移（向左、向右移动、向上或向下都可以），为方便描述，均以向右滑动为例。想象一个图像f(x)从时间轴t的负无穷时刻开始滑动到正无穷时刻，f(x)是一个形状不变的图像，随时间向右滑动，该过程中仅有时间t是变量，用s(t)=f(x-t)描述。滑动图像f(x)的自变量和滑动过程s(t)的自变量t没有关系，同理，卷积结果的自变量与参与卷积的两个函数中的自变量没有关系。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/03/448454555d18443d.gif" alt="move_sinx.gif"></p><h3 id="重叠面积随时间的变化"><a href="#重叠面积随时间的变化" class="headerlink" title="重叠面积随时间的变化"></a>重叠面积随时间的变化</h3><p>两个函数图像，任选一个函数从负无穷滑动到正无穷，另一个不动，观察这个过程中两个函数重叠面积随时间变化的过程。</p><blockquote><p>为方便理解，此处及下文假设t为时间，实际上未必是。</p></blockquote><p><img src="https://ftp.bmp.ovh/imgs/2021/03/b0a4030684c7f579.gif" alt="Convolution_of_box_signal_with_itself2.gif"></p><p><img src="https://ftp.bmp.ovh/imgs/2021/03/b2b6a2fea1008e32.gif" alt="Convolution_of_spiky_function_with_box2.gif"></p><blockquote><p>图片来源：wiki</p></blockquote><p>思考1：两个函数中任选一个进行滑动，会有不同的结果吗？</p><p>思考2：设滑动的图像为f(x)，f(x)滑动产生的结果，和镜像后的图像f(-x)滑动产生的结果相同吗？</p><p>思考3：从刚开始重叠的时刻开始滑动，从已经重叠了一部分的时候开始滑动，从已经滑过固定图像的时候开始滑动，这三种情况下产生的结果有什么不同？</p><p>思考4：卷积和图像重叠面积有什么关系，两者是否相等？</p><blockquote><p>另见：积分运算与函数图像面积的关系</p></blockquote><h3 id="为什么要反转"><a href="#为什么要反转" class="headerlink" title="为什么要反转"></a>为什么要反转</h3><p>下图包含了思考1和思考2的答案，从左至右分别两个函数为卷积、互相关、自相关的结果。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/03/d7e3eaf43f158070.png" alt="Comparison_convolution_correlation.svg.png"></p><p>从图可知，某个函数图像滑动过另一个函数图像的过程中，<strong>重叠面积随时间变化的结果和他们从哪里开始接触有关</strong>，进行卷积操作时先将滑动的图像反转，使得两个图像滑动过程中，最先重叠的部分总是相同（无论以哪个图像滑动），所以<strong>反转使得卷积满足交换律</strong>。</p><blockquote><p>图像滤波中卷积的反转：(<a href="https://zhuanlan.zhihu.com/p/33194385">https://zhuanlan.zhihu.com/p/33194385</a>)</p></blockquote><h3 id="平移什么"><a href="#平移什么" class="headerlink" title="平移什么"></a>平移什么</h3><p>平移，在卷积中可能包含两种观念，一种是将反转的图像g(-x)平移一个固定值t，对应g(t-x)；另一种将反转的图像从负无穷平移到正无穷的过程。本节主要说的前者，后者在本文中用“滑动”描述，以避免平移的二义性。</p><p>先来看一下卷积的数学定义：$s(t)=\int^{+\infty}_{-\infty}f(x)*g(t-x)dt$</p><p>在不考虑t的时候，我们仅有两个函数图像f(x)、g(x)，以及f(x)、g(x)的反转图像f(-x)、g(-x)。在卷积的公式中，g(t-x)看起来是将g(-x)向右平移了t个单位，这是从g(-x)的角度考虑的。然而前面说过，两个函数图像f(x)、g(x)滑动过程中，重叠面积的变化与两个函数的自变量x无关，所以，<strong>从卷积定义的角度讲，实际上并不存在平移</strong>。卷积的操作仅仅从两个函数图像中任意选取一个反转，然后从无限远的过去滑向无限远的未来，得到这两个函数图像<strong>某种性质s</strong>随<strong>时间t</strong>变化的函数s(t)。<strong>对于g(-x)来说，t是一个固定偏移量，是平移，但是对于卷积来说，t是自变量</strong>。卷积关注的重点是从哪个t开始，到哪个t结束。</p><h3 id="t-x-x-t"><a href="#t-x-x-t" class="headerlink" title="(t-x)+(x)=t"></a>(t-x)+(x)=t</h3><p><strong>事先声明：此节仅为个人观点，可略过</strong>。</p><p>卷积的定义：$s(t)=\int^{+\infty}_{-\infty}f(x)*g(t-x)dt$</p><p>很多涉及卷积的文章经常提到<code>(t-x)+(x)=t</code>，个人认为这个纯粹是巧合：仅仅因为反转了某个图像使得<code>(t-x)+(x)=t</code>成立。如果想要使式子不成立，可以上任意一个x加上某个常量或放大某个倍数。</p><ul><li><p>情况1：$(t-x)+(x+a)=t+a$</p><p>  f(x)右移a，f(x)和g(x)相遇时刻延迟，等价于s(t)右移</p></li><li><p>情况2：$(t-x+a)+(x)=t+a$</p><p>  g(x)右移a，f(x)和g(x)相遇时刻提前，等价于s(t)左移</p></li><li><p>情况3：$(t-2x)+(x)=t-x$</p><p>  不考虑，f(x)图像已经变形</p></li></ul><p>排除情况3，情况2和情况1均可用原来的定义进行表述，所以个人认为<code>(t-x)+(x)=t</code>这个纯粹是人为选择的结果，没必要特别强调<code>(t-x)+(x)=t</code>，它仅仅是恰好成立的等式。</p><p>当然，可以为了解释<code>(t-x)+(x)=t</code>设计出一些有意思的题目，但这就属于舍本逐末了，就像许多讲解卷积的文章总是试图通过各种故事解释”卷”字一样。</p><h2 id="2-卷积的数学定义"><a href="#2-卷积的数学定义" class="headerlink" title="2 卷积的数学定义"></a>2 卷积的数学定义</h2><p>连续形式：$s(t)=\int^{+\infty}_{-\infty}f(x)*g(t-x)dt$</p><p>离散形式：<script type="math/tex">s(t)=\sum^{+\infty}_{-\infty}f(x)*g(t-x)</script></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>交换律：<script type="math/tex">s(t)=\int^{+\infty}_{-\infty}f(x)*g(t-x)dt=\int^{+\infty}_{-\infty}g(x)*f(t-x)dt</script></li></ul><h2 id="3-卷积如何计算"><a href="#3-卷积如何计算" class="headerlink" title="3 卷积如何计算"></a>3 卷积如何计算</h2><p>反转、滑动、相乘、叠加（求和、积分）</p><p>见：(<a href="https://www.zhihu.com/answer/1392460040">https://www.zhihu.com/answer/1392460040</a>)</p><p><strong>反转</strong>是卷积中某个函数自变量由x变为-x带来的，<strong>滑动</strong>是为了考察卷积随自变量变化而导致的结果，<strong>相乘</strong>是卷积中的乘法运算，<strong>叠加</strong>是卷积中的求和或积分运算（对于离散信号来说是求和，对于连续信号来说是积分）。</p><blockquote><p>此处措辞与上述链接中有所不同，但对应的观念是相同的。这些词汇仅仅只是表面的概念，重要的是这些措辞背后的观念。</p></blockquote><h2 id="4-卷积中的概念"><a href="#4-卷积中的概念" class="headerlink" title="4 卷积中的概念"></a>4 卷积中的概念</h2><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>s(t)是一个强度s随时间t变化的信号，s(t+5)意味着s(t)延迟了5个单位时间，直观上看，s(t)往后(t增大的方向)移动了5个单位时间。</p><blockquote><p>将图像右移的观念与延迟的概念建立联系</p></blockquote><h3 id="加权叠加"><a href="#加权叠加" class="headerlink" title="加权叠加"></a>加权叠加</h3><p>有两个类似的对卷积解释的答案<a href="https://www.zhihu.com/answer/34267457">A1</a>、<a href="https://www.zhihu.com/answer/1544028976">A2</a>，个人觉得对理解卷积的物理意义很有帮助，然而，越是贴近现实的概念就越容易产生分歧。个人认为两个答案没有完全描述卷积的性质。</p><p>将A1中的<strong>X[n]</strong>和A2中的<strong>钢琴波形</strong>类比，设其为f(x)，两个答案中的另一个信号设为g(x)。两个答案的计算过程为：f(x)滑到0处时，有<code>f(x)*g(0)</code>。滑到1处时，有<code>f(x)*g(1)</code>，其他情况同理，最后将所有结果叠加得到卷积结果：$\sum_{i=0}{f(x)*g(i)}$。</p><p>两个答案中f(x)作为滑动的图像，滑过g(x)，显然已经预设了卷积的反转性质。如果要将g(x)作为滑动的图像，显然要把原先的<strong>X[n]</strong>或<strong>钢琴波形</strong>反转，再把g(x)反转，然后按照上述答案中提到的<strong>加权叠加</strong>算法，才能得到和原来一样的结果。</p><p>实际上，两个答案中的<strong>加权</strong>概念对应<strong>卷积公式的乘法运算</strong>，<strong>叠加</strong>概念对应<strong>卷积公式的求和或积分运算</strong>，<strong>依次计算的过程</strong>则体现了<strong>滑动</strong>。</p><p>在深剖两个答案中的加权概念，里边的加权是把<strong>固定的函数</strong>作为权重，加权到了<strong>滑动的函数</strong>（如X[n]和钢琴波形）上。而在图像处理中，往往是<strong>滑动的3x3模板</strong>作为权重，加权到原图像的像素上。这两种理解是对立的，因为加权的概念里有谁是权、谁要被加权的观念，显然两种观念是不同的，不满足交换律，而卷积的乘法是满足交换性律的（即卷积的两个函数中的任意一个既可以是固定的、也可以是滑动的）。所以用加权描述卷积的相乘操作可能产生歧义。</p><h2 id="5-卷积的作用"><a href="#5-卷积的作用" class="headerlink" title="5 卷积的作用"></a>5 卷积的作用</h2><p>信号的叠加[4]、[5]，提取复杂信号中的分量[6]，图像滤波及加权叠加[7]、[9]</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>互相关[10]</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>思考1：两个函数中任选一个进行滑动，会有不同的结果吗？</p></li><li><p>思考2：设滑动的图像为f(x)，f(x)滑动产生的结果，和镜像后的图像f(-x)滑动产生的结果相同吗？</p></li><li><p>思考3：从刚开始重叠的时刻开始滑动，从已经重叠了一部分的时候开始滑动，从已经滑过固定图像的时候开始滑动，这三种情况下产生的结果有什么不同？</p></li><li><p>思考4：卷积和图像重叠面积有什么关系，两者是否相等？</p><p>  设两个函数f(x)、g(x)，以及他们的卷积s(t)，取f(x)为滑动的图像，并且是一个宽度为1，高度为1的矩形。如果卷积不考虑f(x)，单独对g(x)积分，那么求得的是g(x)图像的面积，g(x)*dx。此时，在引入f(x)，相当于g(x)*dt*f(x)，类似于求一个三维空间对象的体积，其底面是g(x)与x围成的区域，高为f(x)，由于f(x)高度总是1，所以求得的体积正好是g(x)与x围成的区域的面积。</p><p>  由此可知，当参与卷积的某个函数是矩形时，设其高度为H，那么两个函数再t时刻的卷积S与两个函数在t时刻的重叠面积A(t)有S(t)=H*A(t)的关系。如果H=1，则S(t)=A(t)。</p><p>  如果f(x)是delta函数（积分为1，在x=0处的值无穷大，其他位置等于0），卷积求的是高度无穷大，宽度无穷小，长度为g(x)的物体体积（这个物体是一个平面），由于delta函数的特性，这个平面的体积正好等于g(x)的值。这就是<strong>单位冲击信号的取样特性</strong>。</p><p>  注意，由于f(x)退化成矩形或冲击，是一个偶函数，所以此处的卷积和互相关等价。</p></li><li><p>思考5：滤波器滑动的顺序（从左上往右下、从右下往左上）是否会影响输出结果，如何从数学角度解释。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>[1] <a href="https://www.zhihu.com/answer/225986429">如何通俗易懂地解释卷积, michael-kuang, 知乎</a></p></li><li><p>[2] <a href="https://www.zhihu.com/answer/1205380116">如何通俗易懂地解释卷积, chang-yi-61, 知乎</a></p></li><li><p>[3] <a href="https://www.zhihu.com/answer/1392460040">如何通俗易懂地解释卷积, arkham, 知乎</a></p></li><li><p>[4] <a href="https://www.zhihu.com/answer/34267457">如何通俗易懂地解释卷积, jimbozhang, 知乎</a></p></li><li><p>[5] <a href="https://www.zhihu.com/answer/1544028976">如何通俗易懂地解释卷积, cg-wang-1, 知乎</a></p></li><li><p>[6] <a href="https://www.zhihu.com/question/22298352/answer/216754608">如何通俗易懂地解释卷积, gates-bill-2-84, 知乎</a></p></li><li><p>[7] <a href="https://www.zhihu.com/answer/1744295305">如何通俗易懂地解释卷积, huo-hua-12-55, 知乎</a></p></li><li><p>[8] <a href="https://en.wikipedia.org/wiki/Convolution">Convolution, Wiki</a></p></li><li><p>[9] <a href="https://zhuanlan.zhihu.com/p/33194385">卷积（convolution）与互相关(cross-correlation)的一点探讨, zzh-32-70, 知乎</a></p></li><li><p>[10] <a href="https://www.zhihu.com/question/29186714/answer/822469294">对两个信号做互相关的目的和结果是什么, tu-ji-ji-68, 知乎</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>卷积</tag>
      
      <tag>信号处理</tag>
      
      <tag>图像滤波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB协议</title>
    <link href="/2021/01/30/USB%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/30/USB%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="USB协议分析"><a href="#USB协议分析" class="headerlink" title="USB协议分析"></a>USB协议分析</h2><p>本文侧重从软件开发的角度描述USB设备及如何实现一个USB设备。</p><p>本文第1章从整体的角度介绍了部分USB的一些概念，2到5章节以自底向上的方式描述了USB传输层次构建、数据通信交互的过程。6章以实验的方式分析USB枚举过程，7章则以CDC设备为例深入分析USB的Class及Subclass规范，8章以STM32F10X为例，说明如何使用其USB外设，并简要描绘了USB设备的硬件驱动接口及通用软件模块设计。9章则列举一系列USB设备的应用及其实现思路。</p><p>【TODO】:</p><ul><li><p>中断（Coding）</p></li><li><p>顶向下补充</p></li><li><p>硬件信号分析</p></li></ul><h3 id="1-USB概念"><a href="#1-USB概念" class="headerlink" title="1 USB概念"></a>1 USB概念</h3><p>一个USB系统可通过三个方面描述：USB Host、USB Device、USB Interconnect。</p><p>一个USB Host的逻辑组件包括：Client SW、USB System SW、USB Host Controller。</p><p>一个USB Device（物理设备）的逻辑组件包括：Function、USB Logical Device、USB Bus Interface。</p><pre><code class="hljs routeros">        Host          Interconnect       Device[    <span class="hljs-built_in"> Client </span>SW     ]   &lt;&lt;&lt;-&gt;&gt;&gt;   [      Function      ] --has-&gt; Interfaces        ^                                  ^        |                                  |        v                                  v [   USB<span class="hljs-built_in"> System </span>SW   ]   &lt;&lt;---&gt;&gt;   [ USB Logical Device ] --has-&gt; Endpoints        ^                                  ^        |                                  |        v                                  v[USB Host Controller]   &lt;-----&gt;   [ USB Bus<span class="hljs-built_in"> Interface </span> ]图例：&lt;&lt;&lt;-&gt;&gt;&gt;：逻辑数据流&lt;&lt;---&gt;&gt;：Pipe&lt;-----&gt;：实际数据流[xxx]：逻辑组件</code></pre><p><strong>USB Device</strong></p><p>USB设备有一个或多个Configuration，一个Configuration有提供一个或多个Interface，一个Interface有零个或多个Endpoint。一个Configuration下的Interfaces不能共用一个Endpoint。不同Configuration下的Interfaces可以共用一个Endpoint。</p><pre><code class="hljs gherkin">      USB Device     /          \    C1           C2   / \         /  |<span class="hljs-string">  \</span><span class="hljs-string">  I1 I2      I1   I2  I3</span><span class="hljs-string">  </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> \    </span>|<span class="hljs-string">    </span>|  E0  E0 E1  E1   E1(x)注：C2.I2.E1是异常的，因为同一个Configuration下的Interfaces不能共用一个Endpoint。</code></pre><p>USB设备通过多个Interface提供某种Function，比如【TODO】。一个USB物理设备能提供多个Function。</p><p><strong>端点（Endpoint）</strong></p><p>Device地址、Endpoint编号、Endpoint数据流向三者组合唯一标识一个Endpoint。</p><p>所有USB Device必须支持在Endpoint0建立一个专用的Pipe（Default Control Pipe）。</p><p><strong>管道（Pipe）</strong></p><p>USB数据在Host Software和USB Device’s Endpoint之间传输，Host Software和USB Device’s Endpoint之间形成的连接被称为Pipe。一个USB Device可能有多个Pipe，例如一个输入Pipe，一个输出Pipe。Pipe有两种类型，一种是Message，一种是Stream。</p><p>四种数据传输类型：控制传输（Control Transfer）、批量传输（Bulk Transfer）、中断传输（Interrupt Transfer）、同步传输（Isochronous Transfer）。</p><p>一个Pipe只能支持某一种传数据输类型。</p><h3 id="2-包（Packet）"><a href="#2-包（Packet）" class="headerlink" title="2 包（Packet）"></a>2 包（Packet）</h3><p>Packet是USB总线上真实存在的数据结构，每个Packet以一个SYNC开头，一个EOP（End Of Packet）结尾，SYNC中含有SOP（Start Of Packet）。SYNC与EOP属于硬件信号，大多数由硬件产生，故其细节不在本文中赘述。</p><p><strong>总线上的信号流</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">USB</span> <span class="hljs-selector-tag">Bus</span>&lt;&lt;&lt;<span class="hljs-selector-tag">-----------------------------------------------------------------------------</span><span class="hljs-selector-attr">[SYNC]</span> <span class="hljs-selector-attr">[Packet 1]</span> <span class="hljs-selector-attr">[EOP]</span>   <span class="hljs-selector-attr">[SYNC]</span> <span class="hljs-selector-attr">[Packet 2]</span> <span class="hljs-selector-attr">[EOP]</span>  ...  <span class="hljs-selector-attr">[SYNC]</span> <span class="hljs-selector-attr">[Packet n]</span> <span class="hljs-selector-attr">[EOP]</span>&lt;&lt;&lt;<span class="hljs-selector-tag">-----------------------------------------------------------------------------</span></code></pre><p>Packet分为Token、Data、Handshake、Special四种类型，每种类型由Packet中第一个字段PID指示。除了PID字段外，Packet可能还包含Address、Endpoint、Frame number、Data、CRC字段，不同类型的Packet有不同的字段结构。</p><p><strong>Packet通用格式</strong></p><pre><code class="hljs asciidoc">Packet<span class="hljs-code">+-----+</span>--------------+| PID | Other Fields |<span class="hljs-code">+-----+</span>--------------+</code></pre><h4 id="Packet字段"><a href="#Packet字段" class="headerlink" title="Packet字段"></a>Packet字段</h4><h5 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h5><pre><code class="hljs angelscript"> b0  b1  b2  b3  b4  b5  b6  b7+---+---+---+---+---+---+---+---+|      PID      |     (~PID)    |+---+---+---+---+---+---+---+---+字段       大小    说明----       ----    ----PID        <span class="hljs-number">4</span>b      Packet类型标识（PID）                        <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>                       +-+-+-+-+                       |<span class="hljs-number">1</span>|<span class="hljs-number">0</span>|X|X| = Token Packet                       +-+-+-+-+                           <span class="hljs-number">1000</span> = OUT Token Packet (PID = <span class="hljs-number">0x87</span>)                           <span class="hljs-number">1001</span> = IN Token Packet (PID = <span class="hljs-number">0x96</span>)                           <span class="hljs-number">1010</span> = SOF Token Packet (PID = <span class="hljs-number">0xA5</span>)                           <span class="hljs-number">1011</span> = SETUP Token Packet (PID = <span class="hljs-number">0xB4</span>)                       <span class="hljs-number">11</span>XX = Data Packet                           <span class="hljs-number">1100</span> = DATA0 Data Packet (PID = <span class="hljs-number">0xC3</span>)                           <span class="hljs-number">1101</span> = DATA1 Data Packet (PID = <span class="hljs-number">0xD2</span>)                           <span class="hljs-number">1110</span> = DATA2 Data Packet (PID = <span class="hljs-number">0xE1</span>)                           <span class="hljs-number">1111</span> = MDATA Data Packet (PID = <span class="hljs-number">0xF0</span>)                       <span class="hljs-number">01</span>XX = Handshake Packet                           <span class="hljs-number">0100</span> = ACK Handshake Packet (PID = <span class="hljs-number">0x4B</span>)                           <span class="hljs-number">0101</span> = NAK Handshake Packet (PID = <span class="hljs-number">0x5A</span>)                           <span class="hljs-number">0110</span> = NYET Handshake Packet (PID = <span class="hljs-number">0x69</span>)                           <span class="hljs-number">0111</span> = STALL Handshake Packet (PID = <span class="hljs-number">078</span>)                       <span class="hljs-number">00</span>XX = Special Packet                           <span class="hljs-number">0001</span> = SPLIT Special Packet (PID = <span class="hljs-number">0x1E</span>)                           <span class="hljs-number">0010</span> = PING Special Packet (PID = <span class="hljs-number">0x2D</span>)                           <span class="hljs-number">0011</span> = PRE Special Packet (PID = <span class="hljs-number">0x3C</span>)                           <span class="hljs-number">0011</span> = ERR Special Packet (PID = <span class="hljs-number">0x3C</span>)                           <span class="hljs-number">0000</span> = Reserved(~PID)     <span class="hljs-number">4</span>b      PID取反</code></pre><h5 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> b0  b1  b2  b3  b4  b5  b6  </span><span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>|          Address          |<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>字段       大小    说明<span class="hljs-bullet">----       </span>----    ----Address    7b      Function地址。Power up并Reset后，Function的地址被必须设置为默认<span class="hljs-code">                   地址：0。在枚举过程中，Host必须为Function设置一个唯一的地址。</span></code></pre><h5 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> b0  b1  b2  b3</span><span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---+|    Endpoint   |<span class="hljs-code">+---+</span>---<span class="hljs-code">+---+</span>---+字段       大小    说明<span class="hljs-bullet">----       </span>----    ----Endpoint   4b      Endpoint编号。Endpoint域为IN、SETUP、OUT和PING而定义。特殊<span class="hljs-code">                   Endpoint：Ep0。所有Funciton必须支持一个在Ep0的控制Pipe，又称为</span><span class="hljs-code">                   Default Control Pipe。Low-speed设备最多使用3个Pipes，一个</span><span class="hljs-code">                   Default Control Pipe和两个附加的Pipe，这两个附加的Pipe只能是</span><span class="hljs-code">                   Control Pipe或Interrupt Pipe。</span></code></pre><h5 id="Frame-Number"><a href="#Frame-Number" class="headerlink" title="Frame Number"></a>Frame Number</h5><p>11bit，由Host在发送一帧后递增，仅在SOF中使用。</p><h5 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h5><p>0到1024字节。Low-Speed设备最大大小为8字节，Full-Speed最大大小为1023字节，High-Speed最大大小为1024字节。</p><h5 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h5><h6 id="Token-CRCs"><a href="#Token-CRCs" class="headerlink" title="Token CRCs"></a>Token CRCs</h6><p>【TODO】</p><h6 id="Data-CRCs"><a href="#Data-CRCs" class="headerlink" title="Data CRCs"></a>Data CRCs</h6><p>【TODO】</p><h4 id="Packet格式"><a href="#Packet格式" class="headerlink" title="Packet格式"></a>Packet格式</h4><pre><code class="hljs asciidoc"><span class="hljs-code">+---+</span>-------<span class="hljs-code">+--------+</span>----+|PID|Address|Endpoint|CRC5|     (IN, OUT, SETUP)<span class="hljs-code">+---+</span>-------<span class="hljs-code">+--------+</span>----+<span class="hljs-code">+---+</span>------------<span class="hljs-code">+----+</span>|PID|Frame Number|CRC5|         (SOF)<span class="hljs-code">+---+</span>------------<span class="hljs-code">+----+</span><span class="hljs-code">+---+</span>----<span class="hljs-code">+-----+</span>|PID|Data|CRC16|                (DATA0, DATA1, DATA2, MDATA)<span class="hljs-code">+---+</span>----<span class="hljs-code">+-----+</span><span class="hljs-code">+---+</span>|PID|                           (ACK, NACK, STALL, NYET, ERR)<span class="hljs-code">+---+</span></code></pre><p>只有Host能发Token包【出自：USB2.0 8.4.1：Only the host can issue token packets，这里有一个问题（Q1），经实测，虚拟串口可以主动发bulk in给host，那么这个bulk in中的in token是谁发出的？】</p><p>IN：定义了一个Function-to-Host的数据事务（Data transaction）。<br>OUT：定义了一个Host-to-Function的数据数据。</p><p>STALL：Function to Host，表示Function永久性停机（Halted），需要USB Software System干涉。<br>NAK：Function to Host，表示Function暂时无法处理Host的请求</p><h3 id="3-事务（Transaction）"><a href="#3-事务（Transaction）" class="headerlink" title="3 事务（Transaction）"></a>3 事务（Transaction）</h3><p>在Packet一章中有提到Packet分为Token Packet、Data Packet、Handshake Packet以及Special Packet，Transaction则由各种类型的Packet构成。一个Transaction通常包含一个Token包、一个可选的Data包以及一个可选的Handshake包，不同类型的Transaction可能还包含其他类型的包。</p><blockquote><p>Transaction实际上是一种逻辑概念，在总线中只有Packet在传输。</p></blockquote><h4 id="Setup事务"><a href="#Setup事务" class="headerlink" title="Setup事务"></a>Setup事务</h4><p>下图表示了一个Setup事务，其由一个SETUP Token Packet以及一个DATA0 Data Packet和一个Handshake Packet构成（注：Setup事务的Data Packet只能是DATA0）。</p><pre><code class="hljs txt">                Token               Data             Handshake                Phase               Phase            PhaseSetup       /------------\      /------------\      /----------\Transaction [SETUP Packet] ---&gt; [DATA0 Packet] ---&gt; [ACK Packet]  (正常流程)图例：[]：Packet</code></pre><h4 id="Out事务"><a href="#Out事务" class="headerlink" title="Out事务"></a>Out事务</h4><p>Out事务由一个OUT Token Packet以及一个DATA0/1 Data Packet和一个Handshake Packet构成。</p><pre><code class="hljs txt">               Token               Data               Handshake               Phase               Phase              PhaseOut         /----------\      /--------------\      /------------\Transaction [OUT Packet] ---&gt; [DATA0/1 Packet] ---&gt; [ACK   Packet]  (正常流程)                  +-------------------------------&gt; [NAK   Packet]  (异常流程)                  +-------------------------------&gt; [STALL Packet]  (异常流程)                  +-------------------------------&gt; [NYET  Packet]  (异常流程)图例：[]：Packet注：1. NYET仅在High-Speed设备中使用</code></pre><h4 id="In事务"><a href="#In事务" class="headerlink" title="In事务"></a>In事务</h4><p>In事务由一个IN Token Packet以及一个DATA0/1 Data Packet和一个Handshake Packet构成。</p><pre><code class="hljs txt">               Token              Data               Handshake               Phase              Phase              PhaseIn          /---------\      /--------------\      /------------\Transaction [IN Packet] ---&gt; [DATA0/1 Packet] ---&gt; [ACK   Packet]  (正常流程)                 +-------------------------------&gt; [NAK   Packet]  (异常流程)                 +-------------------------------&gt; [STALL Packet]  (异常流程)图例：[]：Packet</code></pre><h4 id="Ping事务"><a href="#Ping事务" class="headerlink" title="Ping事务"></a>Ping事务</h4><p>Ping事务有一个PING Special Packet以及一个Handshake Packet构成。</p><pre><code class="hljs txt">               Special            Handshake               Phase              PhasePing        /-----------\      /------------\Transaction [PING Packet] ---&gt; [ACK   Packet]  (正常流程)                  +----------&gt; [NAK   Packet]  (异常流程)                  +----------&gt; [STALL Packet]  (异常流程)图例：[]：Packet注：1. PING事务仅在High-Speed设备中使用</code></pre><h4 id="Start-Split事务"><a href="#Start-Split事务" class="headerlink" title="Start-Split事务"></a>Start-Split事务</h4><p>【TODO】</p><h4 id="Complete-Split事务"><a href="#Complete-Split事务" class="headerlink" title="Complete-Split事务"></a>Complete-Split事务</h4><p>【TODO】</p><h3 id="4-传输（Transfer）"><a href="#4-传输（Transfer）" class="headerlink" title="4 传输（Transfer）"></a>4 传输（Transfer）</h3><p>Transfer指一个或多个在总线上传输的Transaction。</p><blockquote><p>Transfer实际上是一种逻辑概念，在总线中只有Packet在传输。</p></blockquote><h4 id="Control传输"><a href="#Control传输" class="headerlink" title="Control传输"></a>Control传输</h4><p>Control传输有Setup、Data、Status三个阶段。Setup阶段包含一个Setup事务，Data阶段包含零个或多个Out事务，或者零个或多个In事务，Status阶段包含一个和上一个阶段中最后一个事务传输方向相反的事务（见下图说明）。Control传输使用双向Message Pipe。Control传输有三种类型：Control写、Control读、无数据Control。</p><pre><code class="hljs gherkin">             Setup                      Data                      Status             Stage                      Stage                     Stage            /---------\  /------------------------------------\  /-------\Control     <span class="hljs-variable">&lt;Setup (0)&gt;</span>  <span class="hljs-variable">&lt;Out (1)&gt;</span>  <span class="hljs-variable">&lt;Out (0)&gt;</span>  ...  <span class="hljs-variable">&lt;Out (0/1)&gt;</span>  <span class="hljs-variable">&lt;In  (1)&gt;</span>Write           DATA0      DATA1      DATA0           DATA0/1      DATA1Control     <span class="hljs-variable">&lt;Setup (0)&gt;</span>  <span class="hljs-variable">&lt;In  (1)&gt;</span>  <span class="hljs-variable">&lt;In  (0)&gt;</span>  ...  <span class="hljs-variable">&lt;In  (0/1)&gt;</span>  <span class="hljs-variable">&lt;Out (1)&gt;</span>Read            DATA0      DATA1      DATA0           DATA0/1      DATA1             Setup        Status             Stage        Stage            /---------\  /-------\No-Data     <span class="hljs-variable">&lt;Setup (0)&gt;</span>  <span class="hljs-variable">&lt;IN  (1)&gt;</span>Control         DATA0      DATA1            |<span class="hljs-string">           \</span><span class="hljs-string">            </span>|<span class="hljs-string">                 \</span><span class="hljs-string">            </span>|<span class="hljs-string">                       \</span><span class="hljs-string">            </span>|<span class="hljs-string">                             \</span><span class="hljs-string">            </span>|<span class="hljs-string">                                     \</span><span class="hljs-string">            </span>|<span class="hljs-string"> Token          Data          Handshake</span><span class="hljs-string">            </span>|<span class="hljs-string"> Phase          Phase         Phase</span><span class="hljs-string">            /------------\ /------------\ /----------\</span><span class="hljs-string">            [SETUP Packet] [DATA0 Packet] [ACK Packet]</span><span class="hljs-string">            &lt;---       Setup  Transaction         ---&gt;</span><span class="hljs-string">    Control                   Control                  No-Data</span><span class="hljs-string">    Write                     Read                     Control</span><span class="hljs-string">Host      Function        Host      Function       Host      Function </span><span class="hljs-string"> </span>|<span class="hljs-string">   Setup   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">   Setup   </span>|<span class="hljs-string">            </span>|<span class="hljs-string">   Setup   </span>| |<span class="hljs-string"> &gt;-------&gt; </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> &gt;-------&gt; </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> &gt;-------&gt; </span>| |<span class="hljs-string">    Out    </span>|<span class="hljs-string">             </span>|<span class="hljs-string">    In     </span>|<span class="hljs-string">            </span>|<span class="hljs-string">    In     </span>| |<span class="hljs-string"> &gt;-------&gt; </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> &lt;-------&lt; </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> &lt;-------&lt; </span>| |<span class="hljs-string">    ...    </span>|<span class="hljs-string">             </span>|<span class="hljs-string">    ...    </span>| |<span class="hljs-string">    Out    </span>|<span class="hljs-string">             </span>|<span class="hljs-string">    In     </span>| |<span class="hljs-string"> &gt;-------&gt; </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> &lt;-------&lt; </span>| |<span class="hljs-string">    In     </span>|<span class="hljs-string">             </span>|<span class="hljs-string">    Out    </span>| |<span class="hljs-string"> &lt;-------&lt; </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> &gt;-------&gt; </span>|图例：[]：Packet<span class="hljs-variable">&lt;&gt;</span>：Transaction<span class="hljs-variable">&lt; (0)&gt;</span>：使用DATA0的Transaction<span class="hljs-variable">&lt; (1)&gt;</span>：使用DATA1的Transaction</code></pre><h4 id="Bulk传输"><a href="#Bulk传输" class="headerlink" title="Bulk传输"></a>Bulk传输</h4><p>Bulk传输仅有一个阶段，该阶段包含一个或多个In/Out事务。Bulk传输使用单向Stream Pipe。Bulk传输有两种类型：Bulk写，Bulk读。</p><pre><code class="hljs angelscript">                       A Stage        /------------------------------------\Bulk    &lt;Out (<span class="hljs-number">0</span>)&gt;  &lt;Out (<span class="hljs-number">1</span>)&gt;  ...  &lt;Out (<span class="hljs-number">0</span>/<span class="hljs-number">1</span>)&gt;Write     DATA0      DATA1           DATA0/<span class="hljs-number">1</span>Bulk    &lt;In  (<span class="hljs-number">0</span>)&gt;  &lt;In  (<span class="hljs-number">1</span>)&gt;  ...  &lt;In  (<span class="hljs-number">0</span>/<span class="hljs-number">1</span>)&gt;Read      DATA0      DATA1           DATA0/<span class="hljs-number">1</span>图例：&lt;&gt;：Transaction&lt; (<span class="hljs-number">0</span>)&gt;：使用DATA0的Transaction&lt; (<span class="hljs-number">1</span>)&gt;：使用DATA1的Transaction</code></pre><p>Bulk传输提供的服务有以下特点：</p><ul><li>Access to the USB on a bandwidth-available basis（【不理解】）</li><li>Retry of transfers, in the case of occasional delivery failure due to errors on the bus（有重传机制）</li><li>Guaranteed delivery of data but no guarantee of bandwidth or latency（保证交付，但不保证带宽（传输速率）和延迟【不理解】）</li></ul><blockquote><p>带宽和延迟的关系：<br>【TODO】</p></blockquote><h4 id="Interrupt传输"><a href="#Interrupt传输" class="headerlink" title="Interrupt传输"></a>Interrupt传输</h4><p>Interrupt传输仅有一个阶段，该阶段包含一个In/Out事务（又称为Interrupt事务）。Interrupt传输使用单向Stream Pipe。</p><pre><code class="hljs angelscript">               A Stage            /------------\Interrupt   &lt;In/Out (<span class="hljs-number">0</span>/<span class="hljs-number">1</span>)&gt;Transfer         DATA0/<span class="hljs-number">1</span>图例：&lt;&gt;：Transaction&lt; (<span class="hljs-number">0</span>)&gt;：使用DATA0的Transaction&lt; (<span class="hljs-number">1</span>)&gt;：使用DATA1的Transaction</code></pre><h4 id="Isochronous传输"><a href="#Isochronous传输" class="headerlink" title="Isochronous传输"></a>Isochronous传输</h4><p>Isochronous传输仅有一个阶段，该阶段包含一个没有Handshake Phase的In/Out事务（又称为Isochronous事务）。Isochronous传输使用单向Stream Pipe，如果要进行双向Isochronous传输，则需要两个Pipe。</p><pre><code class="hljs livescript">               A Stage            /------------<span class="hljs-string">\</span>Isochronous &lt;In/Out (<span class="hljs-number">0</span>/<span class="hljs-number">1</span>)&gt;Transfer         DATA0/<span class="hljs-number">1</span>            |            <span class="hljs-string">\</span>            |               <span class="hljs-string">\</span>            |                  <span class="hljs-string">\</span>            |                     <span class="hljs-string">\</span>            |                        <span class="hljs-string">\</span>            | Token           Data     <span class="hljs-string">\</span>            | Phase           Phase     <span class="hljs-string">\</span>            <span class="hljs-regexp">/-------------\ /</span>------------<span class="hljs-string">\</span>            [IN/OUT Packet] [DATA0/<span class="hljs-number">1</span> Packet]            &lt;-- Isochronous Transaction<span class="hljs-function">  --&gt;</span>图例：&lt;&gt;：Transaction&lt; (<span class="hljs-number">0</span>)&gt;：使用DATA0的Transaction&lt; (<span class="hljs-number">1</span>)&gt;：使用DATA1的Transaction</code></pre><p>Isochronous传输提供的服务有以下特点：</p><ul><li>Guaranteed access to USB bandwidth with bounded latency（有限延迟访问USB带宽【不理解】）</li><li>Guaranteed constant data rate through the pipe as long as data is provided to the pipe（有数据需要传输时，保证数据能够以恒定的速率在Pipe中传输）</li><li>In the case of a delivery failure due to error, no retrying of the attempt to deliver the data（没有重传机制，无法保证可靠传输）</li></ul><h3 id="5-有效数据流"><a href="#5-有效数据流" class="headerlink" title="5 有效数据流"></a>5 有效数据流</h3><p>USB协议通过Packet、Transaction、Transfer语义定义USB传输的基础设施，拿网络协议栈类比，相当于定义了应用层以下的层次，应用层的数据、命令在这些语义的基础上进行传输。拿I2C总线类比，相当于定义了开始条件、结束条件、设备地址、读写操作、ACK/NAK等，实际的具体的有效数据在这些框架中进行传输。例如：Host要设置Device的地址，获取Device的各种信息，或者是和Device之间进行数据传输等等操作都在Packet、Transaction、Transfer的基础上进行，或者说在逻辑Pipe中进行。</p><pre><code class="hljs gherkin">Host                  Device |<span class="hljs-string">   cmd:set_address   </span>| |<span class="hljs-string">   arg:some_addr     </span>| |<span class="hljs-string"> ------------------&gt; </span>|Host                  Device |<span class="hljs-string">      bulk data      </span>| |<span class="hljs-string"> ------------------&gt; </span>| |<span class="hljs-string">      bulk data      </span>| |<span class="hljs-string"> &lt;------------------ </span>|</code></pre><p>USB协议定义了一种命令格式（称为设备请求），并在此格式下定义了一些标准的命令，USB设备供应商还可在此种格式下定义自己的命令。此外，USB协议还定义了一种数据格式（称为描述符），在此格式下定义了一些标准的描述符，这些标准描述符中带有关于设备以及设备内部各层次组件的各类信息。这些结构性的数据在Message Pipe中传输。另一些无结构的原始数据流（如存储设备读写）则在Stream Piep中传输。</p><h4 id="设备请求（Device-Request）"><a href="#设备请求（Device-Request）" class="headerlink" title="设备请求（Device Request）"></a>设备请求（Device Request）</h4><p>Host通过设备请求获取USB设备信息或对设备进行配置。Host通过Setup事务向USBS设备发送请求，并在Setup事务的Data Phase中携带请求参数。</p><p>Setup Data（Data Phase中携带的参数）格式如下：</p><pre><code class="hljs angelscript"> <span class="hljs-number">0</span>                   <span class="hljs-number">1</span>                   <span class="hljs-number">2</span>                   <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bmRequestType |   bRequest    |            wValue             |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|             wIndex            |            wLength            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+字段             大小       说明----             ----      ----bmRequestType    <span class="hljs-number">1</span>B        请求类型。                           bit[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]: 接收方                               <span class="hljs-number">0</span> = Device。                               <span class="hljs-number">1</span> = Interface                               <span class="hljs-number">2</span> = Endpoint                               <span class="hljs-number">3</span> = Other                               其他保留。                           bit[<span class="hljs-number">5</span>:<span class="hljs-number">6</span>]：类型                               <span class="hljs-number">0</span> = Standard                               <span class="hljs-number">1</span> = Class                               <span class="hljs-number">2</span> = Vendor                               其他保留。                           bit[<span class="hljs-number">7</span>]：Data Stage中数据传输的方向                               <span class="hljs-number">0</span> = Host-to-device                               <span class="hljs-number">1</span> = Device-to-hostbRequest         <span class="hljs-number">1</span>B        具体的请求。wValue           <span class="hljs-number">2</span>B        参数，由具体的request决定。wIndex           <span class="hljs-number">2</span>B        参数，由具体的request决定。                           当bmRequestType.bit[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>（Endpoint）时，                               bit[<span class="hljs-number">7</span>]：方向                               bit[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]：Endpoint编号。                           当bmRequestType.bit[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>（Interface）时，                               bit[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>]：Interface编号。wLength          <span class="hljs-number">2</span>B        如果存在Data Stage，则此域标识要传输的字节数。                           如果此字段为<span class="hljs-number">0</span>，则不存在second phase of 控制传输（Data                           Stage），并且bmRequestType.bit[<span class="hljs-number">7</span>]为<span class="hljs-number">0</span>。</code></pre><h5 id="标准的设备请求（Standard-Device-Requests）"><a href="#标准的设备请求（Standard-Device-Requests）" class="headerlink" title="标准的设备请求（Standard Device Requests）"></a>标准的设备请求（Standard Device Requests）</h5><p>所有USB设备必须支持的请求。</p><p>Clear Feature：【TODO】。<br>Get Configuration：获取当前使用的Configuration的Value（编号）。一个Control Read传输（含Setup、In、Out事务）。<br>Get Descriptor：获取Device、Configuration或String描述符。获取Configuration描述符时，其下的Interface、Endpoint描述符也会带出。<br>Get Interface：获取指定接口当前使用的Alternate Setting。一个Control Read传输（含Setup、In、Out事务）。<br>Get Status：获取Device或Interface或Endpoint状态。一个Control Read传输（含Setup、In、Out事务）。<br>Set Address：设置设备地址。一个No-Data Control传输（含Setup、In事务）。<br>Set Configuration：选择设备的某个配置。一个No-Data Control传输（含Setup、In事务）。<br>Set Descriptor：【TODO】。<br>Set Feature：【TODO】。<br>Set Interface：选择设备当前配置中的某个接口的某个Alternate Setting。一个No-Data Control传输（含Setup、In事务）。<br>Synch Frame：【TODO】。</p><h4 id="描述符（Descriptor）"><a href="#描述符（Descriptor）" class="headerlink" title="描述符（Descriptor）"></a>描述符（Descriptor）</h4><p>USB设备通过描述符汇报其属性。</p><p>描述符格式：</p><pre><code class="hljs angelscript"> <span class="hljs-number">0</span>                   <span class="hljs-number">1</span>                   <span class="hljs-number">2</span>                   <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          |bDescriptorType|              nData ...        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+字段             大小       说明----             ----      ----bLen             <span class="hljs-number">1</span>B        描述符长度（含bLen和bDescriptorType）。bDescriptorType  <span class="hljs-number">1</span>B        描述符类型。nData            (bLen<span class="hljs-number">-1</span>)B 具体属性。</code></pre><h5 id="标准设备描述符"><a href="#标准设备描述符" class="headerlink" title="标准设备描述符"></a>标准设备描述符</h5><div class="table-container"><table><thead><tr><th>描述符类型</th><th>bDescriptorType值</th></tr></thead><tbody><tr><td>Device描述符</td><td>1</td></tr><tr><td>Configuration描述符</td><td>2</td></tr><tr><td>String描述符</td><td>3</td></tr><tr><td>Interface描述符</td><td>4</td></tr><tr><td>Endpoint描述符</td><td>5</td></tr><tr><td>Device Qualifier描述符</td><td>6</td></tr><tr><td>Other Speed Configuration描述符</td><td>7</td></tr><tr><td>Interface Power描述符</td><td>8</td></tr></tbody></table></div><pre><code class="hljs C"><span class="hljs-keyword">enum</span> usb_desc_type&#123;    USB_DEVICE_DESC_TYPE = <span class="hljs-number">1</span>,    USB_CONFIGURATION_DESC_TYPE,    USB_STRING_DESC_TYPE,    USB_INTERFACE_DESC_TYPE,    USB_ENDPOINT_DESC_TYPE,    USB_DEVICE_QUALIFIER_DESC_TYPE,    USB_OTHER_SPEED_CONFIGURATION_DESC_TYPE,    USB_INTERFACE_POWER_DESC_TYPE,&#125;;</code></pre><h6 id="Device描述符"><a href="#Device描述符" class="headerlink" title="Device描述符"></a>Device描述符</h6><p>Device描述符带有设备USB版本、产品、制造商、Ep0、Configuration等信息。一个USB设备仅有一个Device描述符。如果High-Speed设备针对Full-Speed和High-Speed有不同的设备信息，则必须使用Device_Qualifier描述符。</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bLen          |bDescriptorType| <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            bcdUSB             |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|     bClass    |    bSubClass  |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|   bProtocol   |bMaxPacketSize0|<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            idVendor           |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            idProduct          |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            bcdDevice          |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| iManufacturer |    iProduct   |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| iSerialNumber |   bNumConfs   |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段               大小    说明<span class="hljs-bullet">----               </span>----    ----bLen               1B      描述符长度（含bLen和bDescriptorType）。bDescriptorType    1B      1 = Device描述符。bcdUSB             2B      设备兼容的USB协议版本，BCD码。JJ.M.N，JJ表示Major <span class="hljs-code">                           Number，M表示Mirror Number，N表示Sub-Mirror Number，</span><span class="hljs-code">                           例如：0x210表示2.10。</span>bClass             1B      Device的Class（由USB-IF分配）。bSubClass          1B      Device的SubClass（由USB-IF分配）。bProtocol          1B      Device的Protocol（由USB-IF分配）。bMaxPacketSize0    1B      Endpoint0的【Packet？还是Packet.Data】的最大长度。可选<span class="hljs-code">                           值包括&#123;8, 16, 32, 64&#125;，如果是Hight-Speed设备，只能选</span><span class="hljs-code">                           64。</span>idVendor           2B      供应商ID（由USB-IF分配）。idProduct          2B      产品ID（由制造商分配）。bcdDevice          2B      设备发布编号，BCD码。iManufacturer      1B      制造商描述的字符串，String描述符索引。iProduct           1B      产品描述的字符串，String描述符索引。iSerialNumber      1B      设备序列号的字符串，String描述符索引。bNumConfs          1B      设备在当前速度（如Full-Speed或Hight-Speed）下的<span class="hljs-code">                           Configuration数量。</span></code></pre><h6 id="Device-Qualifier描述符"><a href="#Device-Qualifier描述符" class="headerlink" title="Device_Qualifier描述符"></a>Device_Qualifier描述符</h6><p>【TODO】</p><h6 id="Configuration描述符"><a href="#Configuration描述符" class="headerlink" title="Configuration描述符"></a>Configuration描述符</h6><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bLen          |bDescriptorType| <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|          wTotalLength         |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bNumInterfaces|   bConfValue  |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| iConfiguration|  bmAttributes |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|   bMaxPower   |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段               大小    说明<span class="hljs-bullet">----               </span>----    ----bLen               1B      描述符长度（含bLen和bDescriptorType）。bDescriptorType    1B      2 = Device描述符。wTotalLength       2B      请求此Configuration时，返回给Host的数据的总长度。含所有<span class="hljs-code">                           描述符（Configuration、Interface、Endpoint以及</span><span class="hljs-code">                           Class-specific及Vendor-specific描述符）。</span>bNumInterfaces     1B      此Configuration的Interface数量。bConfValue         1B      Configuration编号，用于SetConfiguration的参数，以选中<span class="hljs-code">                           对应的Configuration。</span>iConfiguration     1B      Configuration描述字符串，String描述符索引。bmAttributes       1B      Configuration属性【TODO】。bMaxPower          1B      此Configuration时，USB设备的最大Power consumption<span class="hljs-code">                           【TODO】。</span></code></pre><h6 id="Other-Speed-Configuration描述符"><a href="#Other-Speed-Configuration描述符" class="headerlink" title="Other_Speed_Configuration描述符"></a>Other_Speed_Configuration描述符</h6><p>【TODO】</p><h6 id="Interface描述符"><a href="#Interface描述符" class="headerlink" title="Interface描述符"></a>Interface描述符</h6><p>Interface描述符带有Interface、其备用Setting和Endpoint等信息。</p><p>Interface描述符总是作为Configuration描述符的一部分，在GetConfiguration()时被提取。GetDescriptor()和SetDescriptor()不能直接访问到Interface描述符。如果Interface有Endpoint，则Endpoint的描述符会跟随在Interface描述符之后被Host通过GetConfiguration()提取。</p><pre><code class="hljs jboss-cli">Host <span class="hljs-params">---</span>&gt;                   GetConfiguration<span class="hljs-params">()</span>                   <span class="hljs-params">---</span>&gt; Device                 <span class="hljs-string">/Eps</span> of Interface0\     <span class="hljs-string">/Eps</span> of Interface1\Host &lt;-- <span class="hljs-string">...</span> I0.Desc E1.Desc E3.Desc I1.Desc E1.Desc E2.Desc <span class="hljs-string">...</span> &lt;<span class="hljs-params">---</span> Device         \<span class="hljs-params">-----</span>               Configuration               <span class="hljs-params">-----/</span></code></pre><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bLen          |bDescriptorType| <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|    bNumber    | bAlterSetting | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bNumEndpoints |     bClass    | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|   bSubClass   |   bProtocol   |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|   iInterface  |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段               大小    说明<span class="hljs-bullet">----               </span>----    ----bLen               1B      描述符长度（含bLen和bDescriptorType）。bDescriptorType    1B      4 = Interface描述符。bNumber            1B      Interface编号。bAlterSetting      1B      Interface Setting编号（一个Interface可能有多个<span class="hljs-code">                           Setting）。</span>bNumEndpoints      1B      Interface中包含的Endpoint的数量（不包括Ep0）。bClass             1B      Interface的Class（由USB-IF分配）。bSubClass          1B      Interface的SubClass（由USB-IF分配）。bProtocol          1B      Interface的Protocol（由USB-IF分配）。iInterface         1B      描述Interface的字符串，String描述符索引。</code></pre><h6 id="Endpoint描述符"><a href="#Endpoint描述符" class="headerlink" title="Endpoint描述符"></a>Endpoint描述符</h6><p>Endpoint描述符总是作为Configuration描述符的一部分，在GetDescriptor(Configuration)时被提取。GetDescriptor()和SetDescriptor()不能直接访问到Endpoint描述符。Ep0没有描述符。</p><pre><code class="hljs angelscript"> <span class="hljs-number">0</span>                   <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          |bDescriptorType| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bEndpointAddr |  bmAttributes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|        wMaxPacketSize         | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|   bInterval   |+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----bLen               <span class="hljs-number">1</span>B      描述符长度（含bLen和bDescriptorType）。bDescriptorType    <span class="hljs-number">1</span>B      <span class="hljs-number">5</span> = Endpoint描述符。bEndpointAddr      <span class="hljs-number">1</span>B      Endpoint地址，唯一确定一个Endpoint，包括编号和方向。                               bit[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]：Endpoint编号。                               bit[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>]：保留，必须设置为<span class="hljs-number">0</span>。                               bit[<span class="hljs-number">7</span>]：传输方向（控制Endpoint不适用此域）。                                   bit[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>: OUT Endpoint。                                   bit[<span class="hljs-number">7</span>] = <span class="hljs-number">1</span>: IN Endpoint。bmAttributes       <span class="hljs-number">1</span>B      Endpoint属性（传输类型及其子属性）。                               bit[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]: 传输类型                                   bit[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = <span class="hljs-number">00</span> = <span class="hljs-number">0x00</span>：Control                                   bit[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = <span class="hljs-number">01</span> = <span class="hljs-number">0x01</span>：Isochronous                                   bit[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = <span class="hljs-number">10</span> = <span class="hljs-number">0x02</span>：Bulk                                   bit[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = <span class="hljs-number">11</span> = <span class="hljs-number">0x03</span>：Interrupt                               bit[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]：                                   如果传输类型不是Isochronous，则保留，                                   否则：                                       bit[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>]：同步类型 【TODO】                                       bit[<span class="hljs-number">4</span>:<span class="hljs-number">5</span>]：使用类型 【TODO】                               bit[<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]：保留，必须设置为<span class="hljs-number">0</span>。wMaxPacketSize     <span class="hljs-number">2</span>B      Endpoint发送或接收时【Packet?还是Packet.Data】的最大长                           度。                               bit[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]：最大长度（单位byte）。                               bit[<span class="hljs-number">11</span>:<span class="hljs-number">12</span>]：                                   如果不是是High-Speed的Isochronous或Interrupt                                    Endpoint，则保留，                                   否则：                                       bit[<span class="hljs-number">11</span>:<span class="hljs-number">12</span>]【TODO】                               bit[<span class="hljs-number">13</span>:<span class="hljs-number">15</span>]：保留，必须设置为<span class="hljs-number">0</span>。bInterval          <span class="hljs-number">1</span>B      【TODO】</code></pre><h6 id="String描述符"><a href="#String描述符" class="headerlink" title="String描述符"></a>String描述符</h6><p>从程序员的角度看，USB设备中存在一个由String描述符构成的数组string_descs，其他标准描述符通过String描述符数组的索引引用字符串。String使用Unicode编码，并且支持多国语言的字符串，所以使用了一个特殊的String描述符string_descs[0]来表明了当前USB设备支持哪些语言。</p><p>string_descs[0]描述符格式：</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bLen          |bDescriptorType| <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            wLANGID[0]         | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|              ...              | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            wLANGID[n]         | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             大小       说明<span class="hljs-bullet">----             </span>----      ----bLen             1B        描述符长度（含bLen和bDescriptorType）。bDescriptorType  1B        3 = String描述符。wLANGID[0]       2B        语言ID，定义在http://www.usb.org/developers/docs.html...wLANGID[n]       2B        语言ID，定义在http://www.usb.org/developers/docs.html</code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USB_STRING_DESC_STRING_LANGID_LEN x</span><span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> string_desc_string_langid[USB_STRING_DESC_STRING_LANGID_LEN] = &#123;    USB_STRING_DESC_STRING_LANGID_LEN    USB_STRING_DESC_TYPE,    <span class="hljs-comment">//...</span>&#125;;</code></pre><p>实际String描述符格式：</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+| bLen          |bDescriptorType| <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            bString            | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             大小       说明<span class="hljs-bullet">----             </span>----      ----bLen             1B        描述符长度（含bLen和bDescriptorType）。bDescriptorType  1B        3 = String描述符。bString          (bLen-2)B Unicode编码字符串。</code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USB_STRING_DESC_PRODUCE_ID_LEN x</span><span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> string_desc_product_id[USB_STRING_DESC_PRODUCE_ID_LEN] = &#123;    USB_STRING_DESC_PRODUCE_ID_LEN    USB_STRING_DESC_TYPE,    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USB_STRING_DESC_VENDER_ID_LEN x</span><span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> string_desc_vender_id[USB_STRING_DESC_VENDER_ID_LEN] = &#123;    USB_STRING_DESC_VENDER_ID_LEN    USB_STRING_DESC_TYPE,    <span class="hljs-comment">//...</span>&#125;;</code></pre><pre><code class="hljs C"><span class="hljs-keyword">uint8_t</span> *string_descs[] = &#123;    string_desc_string_langid,    string_desc_product_id,    string_desc_vender_id,    <span class="hljs-comment">//...</span>&#125;;</code></pre><h3 id="6-USB枚举过程"><a href="#6-USB枚举过程" class="headerlink" title="6 USB枚举过程"></a>6 USB枚举过程</h3><p>本章对USB总线进行监控，并通过抓包分析设备枚举过程。</p><p>整个枚举的传输过程如下图所示：</p><p><img src="https://ftp.bmp.ovh/imgs/2021/02/d72007213bcd6e5f.png" alt="p3"></p><p>大致步骤包括：</p><ol><li><p>Reset信号（电平信号）</p></li><li><p>GetDescriptor(0, 0, Device)</p></li><li><p>SetAddress(new_address, 0)</p></li><li><p>GetDescriptor(new_address, 0, Device)</p></li><li><p>GetDescriptor(new_address, 0, Configuration)</p></li><li><p>GetDescriptor(new_address, 0, String)</p></li><li><p>SetConfiguration(new_address, 0, index)</p></li><li><p>Class-specific Process</p></li></ol><p><strong>GetDescriptor(0, 0, Device)</strong></p><p>这里以最初的Control传输：GetDescriptor(0, 0, Device)为例，细说单个Transfer中所含的Transaction及Packet。可以看到该传输中包含了5个事务，按时间顺序分别为Setup、In、In、Out、Out。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/02/6b9ba871efe42f90.png" alt="p1"></p><p>Host首先向Device发送GetDescriptor(0, 0, Device)设备请求，该请求的实际数据在Setup事务的Data Phase中，长度为8字节，对应图中的Packet 43。随后设备Nak了Host，表示暂时无法处理。第二次In事务才将Device描述符带出，长度为18字节，对应Packet 50。最后由Host以Out事务作为Status阶段的事务结束整个Control传输。</p><p>前边有提到，实际在USB总线上传输的只有Packet，Transfer、Transaction实际上都是某种逻辑数据，由不同含义的物理数据Packet组成。</p><p><strong>SetAddress</strong></p><p><img src="https://ftp.bmp.ovh/imgs/2021/02/1eb8c7542b6cfe07.png" alt="p2"></p><p><strong>SetConfiguration</strong></p><p><img src="https://ftp.bmp.ovh/imgs/2021/02/14eb8b7fe740a135.png" alt="p4"></p><h4 id="USB设备状态迁移"><a href="#USB设备状态迁移" class="headerlink" title="USB设备状态迁移"></a>USB设备状态迁移</h4><pre><code class="hljs txt">+-----------------+                             |  +---------+----+----------&gt;+----------+      |  | powered |    |           | attached |      |  +---------+&lt;---+-----------+----------+      |    |     ^      |                             |reset     |      |                             |    |     |      |                             |    v     |      |                             |  +---------+    |                             |  | default |    |                             |  +---------+    |                             |    |     ^      |                             |address   |      |                             |assgined  |      |                             |    v     |      |                             |  +---------+    |                             |  | address |    |                             |  +---------+    |                             |    |     ^      |                             |device    |      |                             |config    |      -,    bus inactive            |    |     |      | `&#x27;-,                        |    v     |      |     `&#x27;-,                    |  +------------+ |         `&gt;+-----------+     |  | configured | |           | suspended |     |  +------------+ |&lt;----------+-----------+     +-----------------+ bus active</code></pre><h3 id="7-USB-Class规范"><a href="#7-USB-Class规范" class="headerlink" title="7 USB Class规范"></a>7 USB Class规范</h3><p>本章侧重从如何实现USB虚拟串口及USB存储设备的角度，分析USB Class相关规范。虚拟串口涉及的规范有：USBCDC1.2、USBPSTN1.2。</p><p>Class、SubClass、Protocol仅在Device描述符和Interface描述符中使用，有些Class只能用在Device描述符，有些只能用在Interface描述符，有些都能用于Device和Interface描述符。不同类型的Class由不同的文件进行定义，如02h表示的CDC Control在USBCDC120（也称USBCDC1.2）中定义，且其SubClass定义在SubClass规范中，如USBPSTN120（也成USBPSTN1.2）。</p><pre><code class="hljs routeros">Class   Descriptor Usage    Description-----   ----------------    -----------02h     Both                Communications <span class="hljs-keyword">and</span> CDC Control（USBCDC120）09h     Device              Hub08h    <span class="hljs-built_in"> Interface </span>          Mass Storage0Ah    <span class="hljs-built_in"> Interface </span>          CDC-Data（USBCDC120）</code></pre><p>USB规范文件关系：</p><pre><code class="hljs apache"><span class="hljs-attribute">USB</span>规范     Class规范     SubClass规范<span class="hljs-attribute">USB2</span>.<span class="hljs-number">0</span> --- USBCDC<span class="hljs-number">1</span>.<span class="hljs-number">2</span> --- USBPSTN<span class="hljs-number">1</span>.<span class="hljs-number">2</span></code></pre><h4 id="USBCDC1-2"><a href="#USBCDC1-2" class="headerlink" title="USBCDC1.2"></a>USBCDC1.2</h4><p>USBCDC1.2是众多USB Class规范之一，USB设备可以实现PSTN Modem、Ethernet Networking Device等几种Communication Device（CD），而USBCDC120便对如何实现Communication设备的通用部分做了定义。</p><p>CD设备有两种接口：Communication Class Interface（Communication接口）与Data Class Interface（Data接口）。Communication接口是一个管理接口，所有CD设备都需要支持该接口，Data接口用于传输数据。</p><p>Communication接口包括一个Management Element和一个可选的Notificatioin Element。Management Element用于配置和控制Device，该Element使用Endpoint0。Notification Element用于向Host报告Event，通常使用一个Interrupt Endpoint，也可以是Bulk Endpoint。</p><p>Management Element又细分为Device Management和Call Management，前者用于管理Device的状态、响应数据、事件通知，后者用于控制拨号的建立/断开以及拨号相关的控制参数。Call Management在使用Communication接口的同时，也可以可选地使用Data接口。</p><blockquote><p>Call（拨号）</p><p>Call是Telecommunication中的术语之一，Call指通过某种方式在Called（或Callee）与Calling之间建立的连接。<br>Tele-是一个前缀，也是一个词根；来源于希腊语，意为”far”。</p></blockquote><h5 id="Class设备请求"><a href="#Class设备请求" class="headerlink" title="Class设备请求"></a>Class设备请求</h5><p>前边说过，USB定义了一个设备请求格式，设备请求分为标准设备请求、Class设备请求和Vender设备请求，所有USB设备必须支持标准设备请求，以实现对USB设备的统一管理及配置，Class设备请求则是为了实现某种Class的设备而定义的请求。为了完成Management Element的功能，USBCDC120中定义了实现Communication设备的通用的Class设备请求，并引用/收集了SubClass中定义的Class设备请求，此处仅列出部分。</p><pre><code class="hljs txt">bmRequestType   bRequest                        Reference         -------------   --------                        ---------class           SET_LINE_CODING（32）           USBPSTN120class           GET_LINE_CODING（33）           USBPSTN120class           SET_CONTROL_LINE_STATE（34）    USBPSTN120</code></pre><h5 id="Functional描述符"><a href="#Functional描述符" class="headerlink" title="Functional描述符"></a>Functional描述符</h5><p>为了实现Management Element，USBCDC120针对Communication接口定义了一种新的描述符：Functional描述符，该描述符将几个Interface绑定到一个控制/主控Interface上，将Interfaces组合成一个Functional unit。Functional描述符紧跟在Interface描述符之后，由一个Header Functional描述符开头，后边跟着其他Functional描述符，此处仅对Header和Union Functional描述符进行说明，完整描述符说明参考USBCDC120。</p><h6 id="Header-Functional描述符"><a href="#Header-Functional描述符" class="headerlink" title="Header Functional描述符"></a>Header Functional描述符</h6><p>Header Functional描述符作为所有Functional描述符的开头。</p><pre><code class="hljs txt"> 0                   1                   2 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          | bFunDescType  |bFunDescSubType|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|             bcdCDC            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----bLen               1B      此Functional描述符长度（含bLen和bDescriptorType）。bFunDescType       1B      Functional描述符类型，CS_INTERFACE（=0x24）。bFunDescSubType    1B      Functional描述符sub类型。                                0x00：Header Functional Descriptor。bcdCDC             2B      USBCDC规范版本，BCD码。</code></pre><h6 id="Union-Functional描述符"><a href="#Union-Functional描述符" class="headerlink" title="Union Functional描述符"></a>Union Functional描述符</h6><p>Union Functional描述符将多个接口和一个控制接口绑定成一个Functional unit。</p><pre><code class="hljs txt"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          | bFunDescType  |bFunDescSubType| bCtrlInterface| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bInterface0   |       ...          ...        | bInterfaceN   |+-+-+-+-+-+-+-+-+-+-+-+-...-+-+-+-+-+...+-+-+-+-+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----bLen               1B      此Functional描述符长度（含bLen和bDescriptorType）。bFunDescType       1B      Functional描述符类型，CS_INTERFACE（=0x24）。bFunDescSubType    1B      Functional描述符sub类型。                                0x06：Union Functional Descriptor。bCtrlInterface     1B      控制整个Union的Interface的编号（Communication or Data                            Interface）。bInterface0        1B      从属与此Union的Interface的编号。...                ...     从属与此Union的Interface的编号。bInterfaceN        1B      从属与此Union的Interface的编号。</code></pre><h5 id="Event-Message"><a href="#Event-Message" class="headerlink" title="Event Message"></a>Event Message</h5><p>Notification Element使用一个标准的格式向Host汇报事件，该格式包括一个标准的8字节Header和变长数据域。【TODO】</p><h4 id="USBPSTN1-2"><a href="#USBPSTN1-2" class="headerlink" title="USBPSTN1.2"></a>USBPSTN1.2</h4><p>USBCDC120规范针对不同的Communication设备指定了一系列SubClass规范（具体见USBCDC120中的Related Documents部分），因为虚拟串口的实现定义在USBPSTN120中，故本文仅对USBPSTN120进行分析。</p><pre><code class="hljs txt">SubClass    Description--------    -----------00h         REVERSED01h         Direct Line Control Model02h         Abstract Control Model03h         Telephone Control Model</code></pre><p>USBPSTN120规范针对连接到Public Switched Telephone Network (PSTN)的Voiceband Modem和Telephones两种设备提供了实现标准。其中Voiceband Modem又细分为两种：一种为Smart Modem，通过Abtract Control Model实现。另一种Modem依赖于Host的实现方式，由Direct Line Model实现。Telephones则由Telephony Control Model实现。</p><blockquote><p>Modem的历史</p><p>Modem：调制解调器，负责将数字信号转换为模拟信号，或从模拟信号转换为数字信号，使数字信号能够在模拟信号线中传输。1981年，Hayes开发了一种Smart Modem，Smart Modem不再是一个盲目地Converting Serial Data to and from Audio Tones的“哑巴”设备，因为它带有些许“智能”属性：可以接收指令并响应。有了在Serial Line上传输的这些指令，便可以对Smart Modem进行配置、或令其执行某些操作。这些指令集称为Hayes指令集，也是最初的AT指令集（AT：Attention!），AT指令集在ITU的V.250中标准化。</p></blockquote><p>虚拟串口设备框图：</p><pre><code class="hljs gherkin">+------------+             +------------+|<span class="hljs-string">   Virtual  </span>|<span class="hljs-string">             </span>|<span class="hljs-string">  Abstract  </span>|<span class="hljs-string">                 +-----+</span>|<span class="hljs-string">   Serial   </span>|<span class="hljs-string">  +-USB bus--</span>|<span class="hljs-string">  Control   </span>|<span class="hljs-string">---Serial line---</span>|<span class="hljs-string">     </span>|<span class="hljs-string">--Analog line-&gt;</span>|<span class="hljs-string">   Port     </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  Model     </span>|<span class="hljs-string">                 +-----+</span><span class="hljs-string">+------------+  </span>|<span class="hljs-string">          +------------+                  Modem</span>|<span class="hljs-string">   VSerial  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            USB Device</span>|<span class="hljs-string">   Driver   </span>|<span class="hljs-string">--+</span><span class="hljs-string">+------------+</span><span class="hljs-string">      PC</span><span class="hljs-string">+------------+</span>|<span class="hljs-string">   Real     </span>|<span class="hljs-string">                 +-----+</span>|<span class="hljs-string">   Serial   </span>|<span class="hljs-string">---Serial line---</span>|<span class="hljs-string">     </span>|<span class="hljs-string">---Analog line---&gt;</span>|<span class="hljs-string">   Port     </span>|<span class="hljs-string">                 +-----+</span><span class="hljs-string">+------------+                  Modem</span><span class="hljs-string">      PC</span></code></pre><h5 id="Class请求"><a href="#Class请求" class="headerlink" title="Class请求"></a>Class请求</h5><p>USBPSTN1.2中定义了许多Class设备请求，此处仅列举和虚拟串口相关的部分。</p><pre><code class="hljs txt">bmRequestType                   bRequest                        Reference         -------------                   --------                        ---------interface class host-to-device  SET_LINE_CODING（32）           USBPSTN120interface class device-to-host  GET_LINE_CODING（33）           USBPSTN120interface class host-to-device  SET_CONTROL_LINE_STATE（34）    USBPSTN120</code></pre><h6 id="SET-LINE-CODING（32）"><a href="#SET-LINE-CODING（32）" class="headerlink" title="SET_LINE_CODING（32）"></a>SET_LINE_CODING（32）</h6><pre><code class="hljs txt">b7 6 5 4 3 2 1 0+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+| bmRequestType | bRequestCode | wValue | wIndex    | wLength    | Data       |+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+|               |              |        | interface | Size of    |            ||0|0|1|0|0|0|0|1| 32           | 0      | Number    | LineCoding | LineCoding ||               |              |        |           | Structure  |            |+---------------+--------------+--------+-----------+------------+------------+ &lt;------------------------   Setup   ---------------------------&gt; &lt;-Data Out-&gt;</code></pre><p>LineCoding结构见GET_LINE_CODING。</p><h6 id="GET-LINE-CODING（33）"><a href="#GET-LINE-CODING（33）" class="headerlink" title="GET_LINE_CODING（33）"></a>GET_LINE_CODING（33）</h6><pre><code class="hljs txt">b7 6 5 4 3 2 1 0+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+| bmRequestType | bRequestCode | wValue | wIndex    | wLength    | Data       |+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+|               |              |        | interface | Size of    |            ||1|0|1|0|0|0|0|1| 33           | 0      | Number    | LineCoding | LineCoding ||               |              |        |           | Structure  |            |+---------------+--------------+--------+-----------+------------+------------+ &lt;------------------------   Setup   ---------------------------&gt; &lt;-Data Out-&gt;</code></pre><p>Line Coding结构：</p><pre><code class="hljs txt"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                           dwDTERate                           | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bCharFormat   | bParityType   |  bDataBits    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----dwDTERate          4B      通信速率，bit per second（bps）。bCharFormat        1B      停止位。                                0 = 1 Stop bit                                1 = 1.5 Stop bits                                2 = 2 Stop bitsbParityType        1B      校验位。                                0 = None                                1 = Odd                                2 = Even                                3 = Mark                                4 = SpacebDataBits          1B      数据位（可选&#123;5, 6, 7, 8, 16&#125;）。</code></pre><h6 id="SET-CONTROL-LINE-STATE（34）"><a href="#SET-CONTROL-LINE-STATE（34）" class="headerlink" title="SET_CONTROL_LINE_STATE（34）"></a>SET_CONTROL_LINE_STATE（34）</h6><pre><code class="hljs txt">b7 6 5 4 3 2 1 0+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+| bmRequestType | bRequestCode | wValue | wIndex    | wLength    | Data       |+-+-+-+-+-+-+-+-+--------------+--------+-----------+------------+------------+|               |              | Control| interface |            |            ||0|0|1|0|0|0|0|1| 34           | Signal | Number    | 0          | None       ||               |              | Bitmap |           |            |            |+---------------+--------------+--------+-----------+------------+------------+ &lt;------------------------   Setup   ---------------------------&gt; &lt;-Data Out-&gt;字段    大小    说明----    ----    ----wValue  2B      控制信号。                    bit[2:15]：保留。                    bit[1]：RTS。                    bit[0]：DTS。</code></pre><h5 id="Functional描述符-1"><a href="#Functional描述符-1" class="headerlink" title="Functional描述符"></a>Functional描述符</h5><p>USBPSTN120中定义了几个Functional描述符，在此，仅述Call Management描述符和Abstract Control Management描述符。</p><h6 id="Call-Management描述符"><a href="#Call-Management描述符" class="headerlink" title="Call Management描述符"></a>Call Management描述符</h6><pre><code class="hljs txt"> 0                   1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          | bFunDescType  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|bFunDescSubType|bmCapabilities |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|bDataInterface |+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----bLen               1B      此Functional描述符长度（含bLen和bDescriptorType）。bFunDescType       1B      Functional描述符类型，CS_INTERFACE（=0x24）。bFunDescSubType    1B      Functional描述符sub类型。                               0x01: Call Management Functional Descriptor。bmCapabilities     1B      【TODO】bDataInterface     1B      【TODO】</code></pre><h6 id="Abstract-Control-Management描述符"><a href="#Abstract-Control-Management描述符" class="headerlink" title="Abstract Control Management描述符"></a>Abstract Control Management描述符</h6><pre><code class="hljs txt"> 0                   1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| bLen          | bFunDescType  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|bFunDescSubType|bmCapabilities |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+字段               大小    说明----               ----    ----bLen               1B      此Functional描述符长度（含bLen和bDescriptorType）。bFunDescType       1B      Functional描述符类型，CS_INTERFACE（=0x24）。bFunDescSubType    1B      Functional描述符sub类型。                               0x02: Abstract Control Management Functional                                      Descriptor。bmCapabilities     1B      【TODO】</code></pre><h3 id="8-USB设备驱动"><a href="#8-USB设备驱动" class="headerlink" title="8 USB设备驱动"></a>8 USB设备驱动</h3><h4 id="STM32F10X-USB驱动分析"><a href="#STM32F10X-USB驱动分析" class="headerlink" title="STM32F10X USB驱动分析"></a>STM32F10X USB驱动分析</h4><h5 id="Packet内存"><a href="#Packet内存" class="headerlink" title="Packet内存"></a>Packet内存</h5><p>STM32F10X的USB外设内部有一个512B的Packet Buffer Memory，该内存用于缓存Endpoint的输入输出数据。在该内存中存在一个USB Buffer Descriptor Table，Table的起始地址由USB_BTABLE寄存器控制。Table中有8个Item，分别保存了Endpoint0至Endpoint7的Buffer信息，每个Item中包含了输出地址、输出数据数量、输入地址、输入数据数量。其中，输入/输入地址本身又指向Packet Buffer Memory。</p><pre><code class="hljs txt">                    Packet Buffer Memory            0x0000   +----------------+&lt;----+                     |    Endpoint7   |     |                     |    RX Buffer   |     |                     +----------------+     |                     |     ......     |     |USB_BTABLE +--------&gt;+----------------+     |               ^     |  EP0_TX_ADDR   +-----------+               |     +----------------+     |     |               |     |  EP0_TX_COUNT  |     |     |               |     +----------------+     |     |               |     |  EP0_RX_ADDR   +---+ |     |               |     +----------------+   | |     |       USB Buffer    |  EP0_RX_COUNT  |   | |     |       Descriptor    +----------------+   | |     |       Table         |     ......     |   | |     |               |     +----------------+   | |     |               |     |  EP7_TX_ADDR   +-----+     |               |     +----------------+   |       |               |     |  EP7_TX_COUNT  |   |       |               |     +----------------+   |       |               |     |  EP7_RX_ADDR   |   |       |               |     +----------------+   |       |               v     |  EP7_RX_COUNT  |   |       |            ---------+----------------+   |       |                     |     ......     |   |       |                     +--------------------+       |                     |    Endpoint0   |           |                     |    RX Buffer   |           |                     +----------------+           |                     |     ......     |           |                     +-----------------&lt;----------+                     |    Endpoint0   |                     |    TX Buffer   |                     +----------------+                     |     ......     |            0x0200   +----------------+</code></pre><h5 id="处理In事务"><a href="#处理In事务" class="headerlink" title="处理In事务"></a>处理In事务</h5><p>当USB外设收到IN PID时，其首先检查Endpoint的有效性（配置、地址），如果匹配到当前配置中的Endpoint，则USB外设访问对应Endpoint的USB_ADDRn_TX和USB_COUNTn_TX寄存器，将USB_ADDRn_TX及USB_COUNTn_TX的值分别存入内部寄存器ADDR及COUNT，随后开始发送数据，并等待Host的ACK。如果Endpoint无效，则发送NACK或STALL。</p><p>当收ACK后，反转USB_EPnR.DTOG_RX，USB_EPnR.STAT_RX设为10（NAK），USB_EPnR.CTR_RX置1。</p><pre><code class="hljs txt">transmit(usbpkg)&#123;    if (usbpkg.PID == IN) &#123;        if (usbpkg.Address == USB_DADDR &amp;&amp; Ep is a valid Endpoint) &#123;            ADDR = USB_ADDRn_TX[Ep];            COUNT = USB_COUNTn_TX[Ep].COUNTn_RX;            while (COUNT &gt; 0) &#123;                send_data(ADDR, 1);                ADDR++;                COUNT--;            &#125;            // wait host ack            if (host ack) &#123;                USB_EPnR[Ep].CTR_RX = 1;                USB_EPnR[Ep].STAT_RX = 10; // NAK                USB_EPnR[Ep].DTOG_RX = ~USB_EPnR[Ep].DTOG_RX; // Toggle            &#125;        &#125;        else &#123;            // send nack or stall to host        &#125;    &#125;&#125;</code></pre><p>当In事务正常结束后，USB外设向MCU发送CTR中断，收到中断信号后，驱动应按照下面的步骤进行处理：</p><pre><code class="hljs txt">USB_ISR(irq)&#123;    if (irq == CTR) &#123;        Ep = get_endpoint(USB_ISTR.EP_ID, USB_ISTR.DIR);        if (Ep is valid) &#123;            if (USB_EPnR[Ep].CTR_TX) &#123;                // send other packages            &#125;        &#125;    &#125;&#125;</code></pre><p>检查USB_ISTR的EP_ID和DIR，判断哪个Endpoint需要进行处理。检查USB_EPnR的CTR_TX，随后清除中断标志，随后处理下一个需要发送的Package。</p><h5 id="处理Out-Setup事务"><a href="#处理Out-Setup事务" class="headerlink" title="处理Out/Setup事务"></a>处理Out/Setup事务</h5><p>当USB外设收到一个OUT或SETUP的PID时，其首先检查在OUT或SETUP中的地址信息，如果匹配到当前配置中的Endpoint，则USB外设访问对应Endpoint的USB_ADDRn_RX和USB_COUNTn_RX寄存器，将USB_ADDRn_RX的值存入一个内部寄存器ADDR，读取USB_COUNTn_RX的BL_SIZE与NUM_BLOCK，用于初始化内部寄存器BUF_COUNT，并重置USB_COUNTn_RX的COUNTn_RX。当收数据时，BUF_COUNT递减、内部寄存器COUNT递增。当正常收完数据后，USB外设将COUNT的值拷贝到COUNTn_RX，并更新USB_EPnR寄存器：将USB_EPnR.CTR_RX置1，USB_EPnR.STAT_RX设为10（NAK），并反转USB_EPnR.DTOG_RX。最后并向Host发送ACK包。</p><p>上述过程可以下边的伪代码进行描述。</p><pre><code class="hljs txt">received(usbpkg)&#123;    if (usbpkg.PID == OUT || usbpkg.PID == SETUP) &#123;        Ep = usbpkg.Endpoint;        if (usbpkg.Address == USB_DADDR &amp;&amp; Ep is a valid Endpoint) &#123;            ADDR = USB_ADDRn_RX[Ep];            BUF_COUNT = get_buffer_size(USB_COUNTn_RX[Ep].BL_SIZE,                 USB_COUNTn_RX[Ep].NUM_BLOCK);            COUNT = USB_COUNTn_RX[Ep].COUNTn_RX = 0;            rx_cnt = 1;            while (BUF_COUNT &gt; 0)                rx_cnt = recv_data(ADDR, 1);                if (rx_cnt == 1) &#123;                    ADDR++;                    BUF_COUNT--;                    COUNT++;                &#125;                else if (rx_cnt == 0) &#123;                    break; // all data has been handled.                &#125;                else &#123;                    // error                &#125;            &#125;            if (All done without error) &#123;                USB_COUNTn_RX[Ep].COUNTn_RX = COUNT;                USB_EPnR[Ep].CTR_RX = 1;                USB_EPnR[Ep].STAT_RX = 10; // NAK                USB_EPnR[Ep].DTOG_RX = ~USB_EPnR[Ep].DTOG_RX; // Toggle                send_ack();            &#125;        &#125;    &#125;&#125;</code></pre><p>当Out/Setup事务正常结束后，USB外设向MCU发送CTR中断，收到中断信号后，驱动应按照下面的步骤进行处理：</p><p>检查USB_ISTR的EP_ID和DIR，判断哪个Endpoint需要进行处理。检查USB_EPnR的CTR_RX及SETUP，判断是Out事务还是Setup事务，随后清除中断标志。从USB_COUNTn_RX.COUNTn_RX中读取收到的数据的数量，并从USB_COUNTn_RX.ADDRn_RX中读取收到的数据。最后将USB_EPnR.STAT_RX bits设置为11（Valid）以便处理后续Out/Setup事务。</p><p>上述过程可以下边的伪代码进行描述。</p><pre><code class="hljs txt">USB_ISR(irq)&#123;    if (irq == CTR) &#123;        Ep = get_endpoint(USB_ISTR.EP_ID, USB_ISTR.DIR);        if (Ep is valid) &#123;            if (USB_EPnR[Ep].CTR_RX) &#123;                if (USB_EPnR[Ep].SETUP) &#123; // Setup事务                    // do something unique to setup transaction                &#125;                else &#123; // Out事务                    // do something unique to out transaction                &#125;                rx_cnt = USB_COUNTn_RX[Ep].COUNTn_RX;                // copy data from USB_COUNTn_RX[Ep].ADDRn_RX                // dispatch data to endpoint                USB_EPnR[Ep].STAT_RX = 11; // valid            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="USB设备软件模块设计"><a href="#USB设备软件模块设计" class="headerlink" title="USB设备软件模块设计"></a>USB设备软件模块设计</h4><h5 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h5><h5 id="USB设备事件"><a href="#USB设备事件" class="headerlink" title="USB设备事件"></a>USB设备事件</h5><h5 id="Control传输状态机"><a href="#Control传输状态机" class="headerlink" title="Control传输状态机"></a>Control传输状态机</h5><h3 id="9-USB设备应用"><a href="#9-USB设备应用" class="headerlink" title="9 USB设备应用"></a>9 USB设备应用</h3><p>本章以制作USB虚拟串口、USB存储设备、USB以太网网卡为例，说明了USB的具体应用细节。</p><h4 id="制作USB虚拟串口"><a href="#制作USB虚拟串口" class="headerlink" title="制作USB虚拟串口"></a>制作USB虚拟串口</h4><p>设备配置：</p><pre><code class="hljs txt">+---------------+---------------------------+----------------+| Configuration | Interface                 | Endpoint       ||               | (class.subclass.protocol) |                |+---------------+---------------------------+----------------+|               |                           | Control (EP0)  ||               | CDC-Control (02.02.01h)   +----------------+|               |                           | Interrupt (IN) || Legacy Modem  +---------------------------+----------------+|               |                           | Bulk (OUT)     ||               | CDC-Data    (0A.00.00h)   +----------------+|               |                           | Bulk (IN)      |+---------------+---------------------------+----------------+</code></pre><p>描述符角度：</p><pre><code class="hljs txt">+------------------------------------------------------+| Configuration Desc                                   |+   +--------------------------------------------------+|   | Interface Desc (CDC-Control)                     ||   |   +----------------------------------------------+|   |   | Funtional Desc (Header)                      ||   |   +----------------------------------------------+|   |   | Funtional Desc (Call Managemet)              ||   |   +----------------------------------------------+|   |   | Funtional Desc (Abstract Control Management) ||   |   +----------------------------------------------+|   |   | Funtional Desc (Union)                       ||   |   +----------------------------------------------+|   |   | Endpoint Desc (Interrupt IN)                 ||   +---+----------------------------------------------+|   | Interface Desc (CDC-Data)                        ||   +   +----------------------------------------------+|   |   | Endpoint Desc (bulk  OUT)                    ||   |   +----------------------------------------------+|   |   | Endpoint Desc (bulk  IN)                     |+---+--------------------------------------------------+</code></pre><p>控制：CDC-Control.Control</p><pre><code class="hljs txt">SET_LINE_CODING：对串口进行配置（波特率、停止位、检验位、数据位）。GET_LINE_CODING：获取串口当前配置参数。SET_CONTROL_LINE_STATE：控制RTS、DTS信号。</code></pre><p>数据传输：CDC-Data.Bulk OUT与CDC-Data.Bulk IN</p><h4 id="制作USB存储设备"><a href="#制作USB存储设备" class="headerlink" title="制作USB存储设备"></a>制作USB存储设备</h4><p>设备配置：</p><pre><code class="hljs txt">+---------------+---------------------------+----------------+| Configuration | Interface                 | Endpoint       ||               | (class.subclass.protocol) |                |+---------------+---------------------------+----------------+|               |                           | Control (EP0)  ||               |                           +----------------+|  Mass Storage | BBB         (08.00.50h)   | Bulk (OUT)     ||               |                           +----------------+|               |                           | Bulk (IN)      |+---------------+---------------------------+----------------+</code></pre><p>描述符角度：</p><pre><code class="hljs txt">+------------------------------------------------------+| Configuration Desc                                   ||   +--------------------------------------------------+|   | Interface Desc (BBB)                             ||   +   +----------------------------------------------+|   |   | Endpoint Desc (bulk  OUT)                    ||   |   +----------------------------------------------+|   |   | Endpoint Desc (bulk  IN)                     |+---+--------------------------------------------------+</code></pre><h4 id="制作USB以太网网卡"><a href="#制作USB以太网网卡" class="headerlink" title="制作USB以太网网卡"></a>制作USB以太网网卡</h4><p>【TODO】</p><h3 id="A-附录"><a href="#A-附录" class="headerlink" title="A 附录"></a>A 附录</h3><h4 id="A-x-其他"><a href="#A-x-其他" class="headerlink" title="A.x 其他"></a>A.x 其他</h4><ul><li>wireshark抓包时 != 报警：!= may have …，官方建议是 !(x == y) 替代 (x != y)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>[1] <a href="https://www.usb.org/defined-class-codes">Defined Class Codes</a></p></li><li><p>[2] Universal Serial Bus Class Definitions for Communications Devices Revision 1.2 (Errata 1)</p></li><li><p>[2] Universal Serial Bus Communications Class Subclass Specification for PSTN Devices 1.2</p></li><li><p>[3] <a href="https://en.m.wikibooks.org/wiki/Serial_Programming">Serial Programming</a></p></li><li><p>[4] <a href="https://en.m.wikipedia.org/wiki/Telephone_call">Telephone Call</a></p></li><li><p>[5] ST, RM0008 Reference manual</p></li><li><p>[6] <a href="http://www.usbpacketviewer.com">USB Packet Viewer, 抓包工具官网</a></p></li><li><p>[7] Universal Serial Bus Specification 2.0</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>通信协议</tag>
      
      <tag>USB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F10x-FreeRTOS-MDK移植</title>
    <link href="/2021/01/29/STM32F10x-FreeRTOS-MDK%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/29/STM32F10x-FreeRTOS-MDK%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="STM32F10x-FreeRTOS-MDK移植"><a href="#STM32F10x-FreeRTOS-MDK移植" class="headerlink" title="STM32F10x+FreeRTOS+MDK移植"></a>STM32F10x+FreeRTOS+MDK移植</h2><p>此项目代码见<a href="https://github.com/Doerthous/dts.embedded">stm32f10x-mdk-freertos_empty</a>。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F103ZE </li></ul><p>软件：</p><ul><li>MDK 5.26.2.0</li><li>FreeRTOS 10.0.0</li><li>STM32F10x StdPeriph Lib 3.5.0 </li></ul><p>目录结构：</p><p>以下是移植过程中的项目目录结构。此处的目录结构非必须，可根据个人代码管理喜好进行。</p><pre><code class="hljs lua">embedded├─bsp├─<span class="hljs-built_in">os</span>└─project   └─stm32f10x-mdk-freertos_empty      ├─bsp      ├─<span class="hljs-built_in">os</span>      └─mdk</code></pre><h3 id="1-获取源码"><a href="#1-获取源码" class="headerlink" title="1. 获取源码"></a>1. 获取源码</h3><h4 id="获取BSP源码"><a href="#获取BSP源码" class="headerlink" title="获取BSP源码"></a>获取BSP源码</h4><p>下载STM32F10x对应的<a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">bsp源码</a>，拷贝到<code>embedded/bsp</code>目录中。</p><pre><code class="hljs erlang">embedded├─bsp│  ├─CMSIS│  └─STM32F10x_StdPeriph_Driver├─os|  ...└─project   ...</code></pre><h4 id="获取OS源码"><a href="#获取OS源码" class="headerlink" title="获取OS源码"></a>获取OS源码</h4><p>获取FreeRTOS源码可通过下面两种方式进行，本教程使用第二种方式。</p><ul><li><p>直接下载某个版本的源码</p></li><li><p>使用<code>git submodule</code>将源码仓库拉到本地，并切换到指定版本</p></li></ul><p>进入<code>embedded/os</code>目录，执行<code>git submodule add https://github.com/FreeRTOS/FreeRTOS.git</code>，待拉取结束后，<code>embedded/os</code>目录下将新增<code>FreeRTOS</code>目录，即为FreeRTOS源码。</p><pre><code class="hljs 1c">embedded├─bsp<span class="hljs-string">|  ...</span>├─os<span class="hljs-string">|  └─FreeRTOS</span>└─project   ...</code></pre><h3 id="2-拷贝项目相关源码"><a href="#2-拷贝项目相关源码" class="headerlink" title="2. 拷贝项目相关源码"></a>2. 拷贝项目相关源码</h3><ul><li>将和本项目直接相关的源码拷贝到<code>embedded/project/stm32f10x-mdk-freertos_empty</code>（本节及其小节内简记为<code>stm32f10x-mdk-freertos_empty</code>）及其子目录下。</li></ul><h4 id="拷贝BSP相关源码"><a href="#拷贝BSP相关源码" class="headerlink" title="拷贝BSP相关源码"></a>拷贝BSP相关源码</h4><ul><li>将<code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/startup_stm32f10x_hd.s</code>拷贝到<code>stm32f10x-mdk-freertos_empty/bsp</code>目录下（后边会稍微修改此文件）。</li></ul><h4 id="移植或从OS源码中拷贝相关源码"><a href="#移植或从OS源码中拷贝相关源码" class="headerlink" title="移植或从OS源码中拷贝相关源码"></a>移植或从OS源码中拷贝相关源码</h4><ul><li>将<code>FreeRTOSConfig.h</code>（可在FreeRTOS源码目录的Demo中找到）拷贝到<code>stm32f10x-mdk-freertos_empty/os</code>目录下。</li></ul><h3 id="3-新建项目"><a href="#3-新建项目" class="headerlink" title="3. 新建项目"></a>3. 新建项目</h3><p>新建keil项目，并将项目文件(.uvprojx等文件)保存到<code>embedded/project/stm32f10x-mdk-freertos_empty/mdk</code>中。</p><h3 id="4-将源码导入项目"><a href="#4-将源码导入项目" class="headerlink" title="4. 将源码导入项目"></a>4. 将源码导入项目</h3><h4 id="导入BSP源码"><a href="#导入BSP源码" class="headerlink" title="导入BSP源码"></a>导入BSP源码</h4><p>将下述文件导入到项目的bsp目录中</p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport/core_cm3.c</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c</code></p><p><code>embedded/project/stm32f10x-mdk-freertos_empty/bsp/startup_stm32f10x_hd.s</code></p><h4 id="导入OS源码"><a href="#导入OS源码" class="headerlink" title="导入OS源码"></a>导入OS源码</h4><p>将下述文件导入到项目的os目录中，</p><p><code>embedded/os/FreeRTOS/FreeRTOS/Source/portable/RVDS/ARM_CM3/port.c</code><br><code>embedded/os/FreeRTOS/FreeRTOS/Source/portable/MemMang/heap_4.c</code><br><code>embedded/os/FreeRTOS/FreeRTOS/Source/</code>下的<code>timer.c</code>、<code>list.c</code>、<code>queue.c</code>、<code>tasks.c</code></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>最终结果如下图，</p><p><img src="https://ftp.bmp.ovh/imgs/2021/01/a34f603328f07c28.png" alt="p1"></p><h3 id="5-配置"><a href="#5-配置" class="headerlink" title="5. 配置"></a>5. 配置</h3><h4 id="配置项目include路径"><a href="#配置项目include路径" class="headerlink" title="配置项目include路径"></a>配置项目include路径</h4><p>将以下目录设置为include目录，</p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x</code></p><p><code>embedded/os/FreeRTOS/FreeRTOS/Source/include</code><br><code>embedded/os/FreeRTOS/FreeRTOS/Source/portable/RVDS/ARM_CM3</code></p><p><code>embedded/project/stm32f10x-mdk-freertos_empty/os</code></p><h4 id="配置BSP"><a href="#配置BSP" class="headerlink" title="配置BSP"></a>配置BSP</h4><h5 id="配置ST-BSP"><a href="#配置ST-BSP" class="headerlink" title="配置ST BSP"></a>配置ST BSP</h5><p>在keil中添加宏定义和<code>STM32F10X_HD</code>。</p><p>在<code>embedded/project/stm32f10x-mdk-freertos_empty/bsp/startup_stm32f10x_hd.s</code>文件中导入FreeRTOS符号及中断处理函数。</p><pre><code class="hljs armasm"><span class="hljs-symbol">__heap_limit</span>                <span class="hljs-meta">IMPORT</span> xPortPendSVHandler                <span class="hljs-meta">IMPORT</span> xPortSysTickHandler                <span class="hljs-meta">IMPORT</span> vPortSVCHandler<span class="hljs-symbol">...</span><span class="hljs-symbol">__Vectors</span>       <span class="hljs-meta">DCD</span>     __initial_sp               <span class="hljs-comment">; Top of Stack</span>                <span class="hljs-meta">DCD</span>     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><span class="hljs-symbol">...</span>                <span class="hljs-meta">DCD</span>     vPortSVCHandler            <span class="hljs-comment">; SVCall Handler</span><span class="hljs-symbol">...</span>                <span class="hljs-meta">DCD</span>     xPortPendSVHandler         <span class="hljs-comment">; PendSV Handler</span>                <span class="hljs-meta">DCD</span>     xPortSysTickHandler        <span class="hljs-comment">; SysTick Handler</span></code></pre><h4 id="配置OS"><a href="#配置OS" class="headerlink" title="配置OS"></a>配置OS</h4><p>按需要修改<code>stm32f10x-mdk-freertos_empty/os/FreeRTOSConfig.h</code>配置，需要注意，<code>configTICK_RATE_HZ</code>应与提供给FreeRTOS的心跳时钟频率一致。</p><pre><code class="hljs lisp">#define configTICK_RATE_HZ( ( <span class="hljs-name">TickType_t</span> ) <span class="hljs-number">1000</span> )</code></pre><h4 id="添加测试程序"><a href="#添加测试程序" class="headerlink" title="添加测试程序"></a>添加测试程序</h4><p><code>main.c</code>:</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stm32f10x.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;FreeRTOS.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;task.h&gt;</span></span><span class="hljs-keyword">static</span> TaskHandle_t AppTask_Handle = <span class="hljs-literal">NULL</span>;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AppTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *param)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        vTaskDelay(<span class="hljs-number">500</span>);        vTaskDelay(<span class="hljs-number">500</span>);            &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    SysTick_Config(SystemCoreClock / <span class="hljs-number">1000</span>);    <span class="hljs-keyword">if</span> (xTaskCreate((TaskFunction_t)AppTask, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)<span class="hljs-string">&quot;AppTask&quot;</span>,        (<span class="hljs-keyword">uint16_t</span>)<span class="hljs-number">512</span>, (<span class="hljs-keyword">void</span> *)<span class="hljs-literal">NULL</span>, (UBaseType_t)<span class="hljs-number">1</span>,         (TaskHandle_t *)&amp;AppTask_Handle) != pdPASS) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);    &#125;    vTaskStartScheduler();    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">STM32F10x StdPeriph Lib 3.5.0</a></p></li><li><p><a href="https://www.freertos.org/">FreeRTOS</a></p></li><li><p><a href="https://www.freertos.org/a00111.html">FreeRTOS - Memory Management</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>RTOS移植</tag>
      
      <tag>MDK</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LwIP移植</title>
    <link href="/2021/01/26/LwIP%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/26/LwIP%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F10XZET6</li><li>ENC28J60</li></ul><p>软件：</p><ul><li>LwIP v2.0.0.release</li></ul><h3 id="1-裸机移植"><a href="#1-裸机移植" class="headerlink" title="1 裸机移植"></a>1 裸机移植</h3><p>此项目代码参考<a href="https://github.com/Doerthous/dts.embedded">project/stm32f10x-mdk-none_lwip</a>。</p><h4 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h4><p>针对平台、操作系统及LwIP进行配置，此处主要涉及cc.h、sys_arch.h、lwipopts.h三个文件。</p><p>cc.h：平台及编译器相关的文件，例如控制大小端的宏定义：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTE_ORDER  LITTLE_ENDIAN</span></code></pre><p>sys_arch.h：RTOS接口（裸机仅需根据需要，定义一些多余的类型）。</p><p>lwipopts.h：lwip配置（根据需要修改）。</p><pre><code class="hljs C"><span class="hljs-comment">// 裸机环境</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_SYS                      1</span><span class="hljs-comment">// 禁用libc的malloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_LIBC_MALLOC             0</span><span class="hljs-comment">// 硬件无padding</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ETH_PAD_SIZE                0</span><span class="hljs-comment">// 此宏控制了ethernet.h中的ethernet头部的padding</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_hdr</span> &#123;</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>    PACK_STRUCT_FLD_8(<span class="hljs-keyword">u8_t</span> padding[ETH_PAD_SIZE]);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    PACK_STRUCT_FLD_S(struct eth_addr dest);    PACK_STRUCT_FLD_S(struct eth_addr src);    PACK_STRUCT_FIELD(<span class="hljs-keyword">u16_t</span> type);&#125; PACK_STRUCT_STRUCT;</code></pre><h4 id="1-2-实现内存管理接口"><a href="#1-2-实现内存管理接口" class="headerlink" title="1.2 实现内存管理接口"></a>1.2 实现内存管理接口</h4><p><code>lwip/mem.h</code>中定义了内存管理相关的接口，需要根据情况实现这些接口，或者使用lwip中已经存在的实现：<code>core/mem.c</code>。由于本文中使用了tlsf的内存管理接口，故本文中的移植不使用<code>core/mem.c</code>。</p><p>在<code>lwipopts.h</code>中引入tlsf接口：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_free                    tlsf_free</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_malloc                  tlsf_malloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_calloc                  tlsf_calloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_realloc                 tlsf_realloc</span></code></pre><p>实现mem_init和mem_trim接口（lwipport.c）：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/mem.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mem_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_POOL_SIZE 10240</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> mem[MEM_POOL_SIZE];    init_memory_pool(MEM_POOL_SIZE, mem);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">mem_trim</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">mem_size_t</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> mem;&#125;</code></pre><blockquote><p>注：<br>按我的理解<code>core/mem.c</code>只是LwIP中提供的对<code>lwip/mem.h</code>的一种实现，如果本身已经有内存管理接口，可以不使用<code>core/mem.c</code>文件。</p></blockquote><h4 id="1-3-接入硬件驱动"><a href="#1-3-接入硬件驱动" class="headerlink" title="1.3 接入硬件驱动"></a>1.3 接入硬件驱动</h4><p>本例程中针对ENC28J60芯片已实现了如下的发送接收接口：</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_send</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_recv</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;</code></pre><p>根据LwIP提供的<code>netif/ethernetif.c</code>，将上述驱动接口填入到<code>netif/ethernetif.c</code>中的指定部分即可，完整内容参考后边的源码部分。</p><h4 id="1-4-实现sys-now接口"><a href="#1-4-实现sys-now接口" class="headerlink" title="1.4 实现sys_now接口"></a>1.4 实现sys_now接口</h4><pre><code class="hljs applescript">/** * @ingroup sys_time * Returns <span class="hljs-keyword">the</span> current <span class="hljs-built_in">time</span> <span class="hljs-keyword">in</span> milliseconds, * may be <span class="hljs-keyword">the</span> same <span class="hljs-keyword">as</span> sys_jiffies <span class="hljs-keyword">or</span> <span class="hljs-keyword">at</span> least based <span class="hljs-keyword">on</span> <span class="hljs-keyword">it</span>. */u32_t sys_now(void);</code></pre><p>随便返回一个时间给LwIP。</p><h4 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h4><pre><code class="hljs reasonml"><span class="hljs-comment">// 设置地址</span>ip_addr_t ipaddr, netmask, gw;<span class="hljs-constructor">IP4_ADDR(&amp;<span class="hljs-params">gw</span>, 10,0,0,1)</span>;<span class="hljs-constructor">IP4_ADDR(&amp;<span class="hljs-params">ipaddr</span>, 10,0,0,2)</span>;<span class="hljs-constructor">IP4_ADDR(&amp;<span class="hljs-params">netmask</span>, 255,255,255,0)</span>;<span class="hljs-comment">// lwIP裸机初始化接口</span>lwip<span class="hljs-constructor">_init()</span>;<span class="hljs-comment">// 添加netif，设置为默认接口，并启动</span>netif<span class="hljs-constructor">_add(&amp;<span class="hljs-params">netif</span>, &amp;<span class="hljs-params">ipaddr</span>, &amp;<span class="hljs-params">netmask</span>, &amp;<span class="hljs-params">gw</span>, NULL, <span class="hljs-params">ethernetif_init</span>, <span class="hljs-params">ethernet_input</span>)</span>;netif<span class="hljs-constructor">_set_default(&amp;<span class="hljs-params">netif</span>)</span>;netif<span class="hljs-constructor">_set_up(&amp;<span class="hljs-params">netif</span>)</span>;</code></pre><p>添加netif时涉及两个接口，一个是硬件及netif初始化接口（init），即上述代码中的ethernetif_init。另一个是硬件数据传入LwIP的接口（input），上述代码中的ethernet_input。</p><p>当硬件收到数据时，调用input接口将输入传入LwIP，input接口在netif_add中会被赋值给netif-&gt;input。所以，硬件收到数据时调用netif-&gt;input即可。</p><p>input接口在LwIP中已有实现，针对ethernet硬件使用ethernet_input（netif/ethernet.c），非ethernet硬件使用ip_input（core/ip.c）.而init接口需要用户实现，此处使用1.3中定义的接口ethernetif_init（netif/ethernetif.c）</p><h4 id="1-6-查询及中断处理"><a href="#1-6-查询及中断处理" class="headerlink" title="1.6 查询及中断处理"></a>1.6 查询及中断处理</h4><p>在主循环（Loop）中查询各种状态：<br><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(1)</span> &#123;    <span class="hljs-comment">// irq poll</span>    sys_check_timeouts<span class="hljs-comment">()</span>;&#125;</code></pre></p><p>中断时通知LwIP收到数据：<br><pre><code class="hljs reasonml">void some<span class="hljs-constructor">_isr(<span class="hljs-params">void</span>)</span>&#123;    <span class="hljs-keyword">struct</span> pbuf *buff = pbuf<span class="hljs-constructor">_alloc(PBUF_RAW, 2048, PBUF_RAM)</span>;    buff-&gt;len = enc28j60<span class="hljs-constructor">_recv(&amp;<span class="hljs-params">enc28j60</span>, <span class="hljs-params">buff</span>-&gt;<span class="hljs-params">payload</span>, 2048)</span>;    <span class="hljs-keyword">if</span> (buff-&gt;len) &#123;        netif.input(buff, &amp;netif); <span class="hljs-comment">// 将输入传入LwIP</span>    &#125;&#125;</code></pre></p><h4 id="1-7-测试"><a href="#1-7-测试" class="headerlink" title="1.7 测试"></a>1.7 测试</h4><p>完成上述步骤后可通过ping进行测试。</p><h4 id="总结及问题"><a href="#总结及问题" class="headerlink" title="总结及问题"></a>总结及问题</h4><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>LwIP文件：core中大部分、core/ipv4中部分、netif中部分。需要指出，由于本文使用tlsf内存管理模块，所以并未使用<code>core/mem.c</code>。根据编译报错情况酌情修改【:-)】。</p><p>新建文件：cc.h、sys_arch.h、lwipopts.h、lwipport.c</p><p>需要实现的接口：内存管理接口、时钟接口、硬件驱动接口（参考netif/ethernetif.c）</p><p>需要注意的调用：LwIP初始化、netif注册、收到数据时调用netif-&gt;input通知LwIP、sys_check_timeouts</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>Q1: ISR中已经直接调用enc28j60_recv将数据传入LwIP了，那ethernetif.c中的low_level_input里调用enc28j60_recv有什么意义？</p><h3 id="2-带OS移植【TODO】"><a href="#2-带OS移植【TODO】" class="headerlink" title="2 带OS移植【TODO】"></a>2 带OS移植【TODO】</h3><h4 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h4><h4 id="2-2-实现内存接口"><a href="#2-2-实现内存接口" class="headerlink" title="2.2 实现内存接口"></a>2.2 实现内存接口</h4><h4 id="2-3-实现OS抽象层"><a href="#2-3-实现OS抽象层" class="headerlink" title="2.3 实现OS抽象层"></a>2.3 实现OS抽象层</h4><p>“doc/sys_arch.txt”</p><p>“lwip/sys.h”</p><blockquote><p>注：<br>为什么不直接用posix接口呢？</p></blockquote><h4 id="2-4-接入硬件驱动"><a href="#2-4-接入硬件驱动" class="headerlink" title="2.4 接入硬件驱动"></a>2.4 接入硬件驱动</h4><h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h4><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;lwip/tcpip.h&quot;</span> 中tcpip_init();</code></pre><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="LwIP内存管理"><a href="#LwIP内存管理" class="headerlink" title="LwIP内存管理"></a>LwIP内存管理</h4><p>LwIP的内存管理接口在<code>lwip/mem.h</code>中定义：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">mem_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mem_trim</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">mem_size_t</span> <span class="hljs-built_in">size</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mem_malloc</span><span class="hljs-params">(<span class="hljs-keyword">mem_size_t</span> <span class="hljs-built_in">size</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mem_calloc</span><span class="hljs-params">(<span class="hljs-keyword">mem_size_t</span> count, <span class="hljs-keyword">mem_size_t</span> <span class="hljs-built_in">size</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">mem_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mem)</span></span>;</code></pre><p>LwIP提供了四种实现上述接口的方式：</p><ol><li>使用C标准库的内存管理模块</li><li>使用LwIP自实现的内存池模块（内存池，本质就是事先定义好一些结构体数组）</li><li>使用LwIP自实现的内存管理模块</li><li>使用其他内存管理模块</li></ol><p>启用逻辑：</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> core/mem.c<span class="hljs-comment">#if MEM_LIBC_MALLOC</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> 使用C标准库的内存管理模块<span class="hljs-comment">#elif MEM_USE_POOLS</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span> 使用LwIP自实现的内存池模块<span class="hljs-comment">#else</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">3</span> 使用LwIP自实现的内存管理模块<span class="hljs-comment">#endif</span><span class="hljs-regexp">//</span> <span class="hljs-number">4</span> 要使用其他内存管理模块时，需要将MEM_LIBC_MALLOC置<span class="hljs-number">1</span>，并从项目中移除`core/mem.c`，<span class="hljs-regexp">//</span>   最后在`lwipopts.h`中用宏对内存管理接口进行替换。</code></pre><h5 id="使用core-mem"><a href="#使用core-mem" class="headerlink" title="使用core/mem"></a>使用core/mem</h5><p>配置：设置MEM_LIBC_MALLOC为1，添加core/mem.c，通过MEM_SIZE配置能够分配的内存的总大小（在<code>lwipopts.h</code>中配置）。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_LIBC_MALLOC             0 <span class="hljs-comment">// 是否使用libc的内存管理接口</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_ALIGNMENT               4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_SIZE                    (10 * 1024) <span class="hljs-comment">// 动态分配内存堆大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_STATS                   0</span></code></pre><h5 id="使用内存池"><a href="#使用内存池" class="headerlink" title="使用内存池"></a>使用内存池</h5><p>配置：设置MEM_LIBC_MALLOC为0，设置MEMP_MEM_MALLOC为1，添加core/mem.c、core/memp.c，通过<code>lwipopts.h</code>对内存池进行配置。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_MEM_MALLOC             1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_PBUF               1024</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_UDP_PCB            20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_PCB            20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_PCB_LISTEN     16</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_SEG            128</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_REASSDATA          32</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_ARP_QUEUE          10</span></code></pre><h5 id="使用其他内存模块"><a href="#使用其他内存模块" class="headerlink" title="使用其他内存模块"></a>使用其他内存模块</h5><p>配置：设置MEM_LIBC_MALLOC为1，移除core/mem.c，在<code>lwipopts.h</code>中用宏对mem_xxx等接口进行替换。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_free                    tlsf_free</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_malloc                  tlsf_malloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_calloc                  tlsf_calloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_realloc                 tlsf_realloc</span><span class="hljs-comment">//...</span></code></pre><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><pre><code class="hljs 1c">                        LwIP                         <span class="hljs-string">|</span>                         <span class="hljs-string">| 依赖</span>                         vcore/mem.c  ---实现---&gt; lwip/mem.h <span class="hljs-string">|        \</span> <span class="hljs-string">| 依赖     \ 依赖</span> <span class="hljs-string">|           \</span> v            &gt; libc.malloc/free/...core/memp.c</code></pre><h4 id="LwIP系统抽象层"><a href="#LwIP系统抽象层" class="headerlink" title="LwIP系统抽象层"></a>LwIP系统抽象层</h4><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>邮箱</p><h5 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h5><p>如果系统不支持互斥锁，可以通过二元信号量实现</p><pre><code class="hljs reasonml">#<span class="hljs-keyword">if</span> LWIP_COMPAT_MUTEX<span class="hljs-comment">/* for old ports that don&#x27;t have mutexes: define them to binary semaphores */</span>#define sys_mutex_t                   sys_sem_t#define sys<span class="hljs-constructor">_mutex_new(<span class="hljs-params">mutex</span>)</span>          sys<span class="hljs-constructor">_sem_new(<span class="hljs-params">mutex</span>, 1)</span>#define sys<span class="hljs-constructor">_mutex_lock(<span class="hljs-params">mutex</span>)</span>         sys<span class="hljs-constructor">_sem_wait(<span class="hljs-params">mutex</span>)</span>#define sys<span class="hljs-constructor">_mutex_unlock(<span class="hljs-params">mutex</span>)</span>       sys<span class="hljs-constructor">_sem_signal(<span class="hljs-params">mutex</span>)</span>#define sys<span class="hljs-constructor">_mutex_free(<span class="hljs-params">mutex</span>)</span>         sys<span class="hljs-constructor">_sem_free(<span class="hljs-params">mutex</span>)</span>#define sys<span class="hljs-constructor">_mutex_valid(<span class="hljs-params">mutex</span>)</span>        sys<span class="hljs-constructor">_sem_valid(<span class="hljs-params">mutex</span>)</span>#define sys<span class="hljs-constructor">_mutex_set_invalid(<span class="hljs-params">mutex</span>)</span>  sys<span class="hljs-constructor">_sem_set_invalid(<span class="hljs-params">mutex</span>)</span>#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* LWIP_COMPAT_MUTEX */</span></code></pre><p>线程</p><h4 id="裸机移植参考源码"><a href="#裸机移植参考源码" class="headerlink" title="裸机移植参考源码"></a>裸机移植参考源码</h4><h5 id="arch-cc-h"><a href="#arch-cc-h" class="headerlink" title="arch/cc.h"></a>arch/cc.h</h5><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __ARCH_CC_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __ARCH_CC_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTE_ORDER  LITTLE_ENDIAN</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint8_t</span>     <span class="hljs-keyword">u8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int8_t</span>      <span class="hljs-keyword">s8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span>    <span class="hljs-keyword">u16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int16_t</span>     <span class="hljs-keyword">s16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span>    <span class="hljs-keyword">u32_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int32_t</span>     <span class="hljs-keyword">s32_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uintptr_t</span>   <span class="hljs-keyword">mem_ptr_t</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_ERR_T  int</span><span class="hljs-comment">/* Define (sn)printf formatters for these lwIP types */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> U16_F <span class="hljs-meta-string">&quot;hu&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S16_F <span class="hljs-meta-string">&quot;hd&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X16_F <span class="hljs-meta-string">&quot;hx&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> U32_F <span class="hljs-meta-string">&quot;u&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S32_F <span class="hljs-meta-string">&quot;d&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X32_F <span class="hljs-meta-string">&quot;x&quot;</span></span><span class="hljs-comment">/* Compiler hints for packing structures */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK_STRUCT_FIELD(x)    x</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK_STRUCT_STRUCT  __attribute__((packed))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK_STRUCT_BEGIN</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK_STRUCT_END</span><span class="hljs-comment">/* Plaform specific diagnostic output */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_PLATFORM_DIAG(x)   do &#123;&#125; while (0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_PLATFORM_ASSERT(x) do &#123;&#125; while (0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;arch/sys_arch.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* __ARCH_CC_H__ */</span></span></code></pre><h5 id="arch-sys-arch-h"><a href="#arch-sys-arch-h" class="headerlink" title="arch/sys_arch.h"></a>arch/sys_arch.h</h5><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __ARCH_SYS_ARCH_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __ARCH_SYS_ARCH_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_MBOX_NULL   NULL</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_SEM_NULL    NULL</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">sys_prot_t</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* __ARCH_SYS_ARCH_H__ */</span></span></code></pre><h5 id="lwipopts-h"><a href="#lwipopts-h" class="headerlink" title="lwipopts.h"></a>lwipopts.h</h5><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __LWIPOPTS_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __LWIPOPTS_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mem/tlsf.h&gt; // tlsf内存管理接口</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_SYS                      1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_LIBC_MALLOC             0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_MEM_MALLOC             1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_ALIGNMENT               4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_SIZE                    (4 * 1024 * 1024)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_PBUF               1024</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_UDP_PCB            20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_PCB            20</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_PCB_LISTEN     16</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_TCP_SEG            128</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_REASSDATA          32</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_NUM_ARP_QUEUE          10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PBUF_POOL_SIZE              512</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_ARP                    1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_REASS_MAX_PBUFS          64</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_FRAG_USES_STATIC_BUF     0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_DEFAULT_TTL              255</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_SOF_BROADCAST            1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_SOF_BROADCAST_RECV       1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_ICMP                   1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_BROADCAST_PING         1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_MULTICAST_PING         1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_RAW                    1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_WND                     (4 * TCP_MSS)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_MSS                     1460</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_SND_BUF                 (8 * TCP_MSS)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_LISTEN_BACKLOG          1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_NETIF_STATUS_CALLBACK  1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_NETIF_LINK_CALLBACK    1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_NETIF_HWADDRHINT       1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_NETCONN                0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_SOCKET                 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_STATS_DISPLAY          1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_STATS                   0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_STATS                   0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_STATS                  0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LINK_STATS                  0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ETHARP_TRUST_IP_MAC         0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ETH_PAD_SIZE                0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_CHKSUM_ALGORITHM       2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_TCP_KEEPALIVE          1</span><span class="hljs-comment">// Keepalive values, compliant with RFC 1122. Don&#x27;t change this unless you know what you&#x27;re doing</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_KEEPIDLE_DEFAULT        10000UL <span class="hljs-comment">// Default KEEPALIVE timer in milliseconds</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_KEEPINTVL_DEFAULT       2000UL  <span class="hljs-comment">// Default Time between KEEPALIVE probes in milliseconds</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_KEEPCNT_DEFAULT         9U      <span class="hljs-comment">// Default Counter for KEEPALIVE probes</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_free                    tlsf_free</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_malloc                  tlsf_malloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_calloc                  tlsf_calloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem_realloc                 tlsf_realloc</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LWIP_DEBUG                  0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ETHARP_DEBUG                LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NETIF_DEBUG                 LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PBUF_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> API_LIB_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> API_MSG_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOCKETS_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ICMP_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_DEBUG                    LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_REASS_DEBUG              LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAW_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMP_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_INPUT_DEBUG             LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_OUTPUT_DEBUG            LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_RTO_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_CWND_DEBUG              LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_WND_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_FR_DEBUG                LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_QLEN_DEBUG              LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_RST_DEBUG               LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UDP_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCPIP_DEBUG                 LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PPP_DEBUG                   LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLIP_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHCP_DEBUG                  LWIP_DBG_OFF</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* __LWIPOPTS_H__ */</span></span></code></pre><h5 id="netif-ethernetif-c"><a href="#netif-ethernetif-c" class="headerlink" title="netif/ethernetif.c"></a>netif/ethernetif.c</h5><pre><code class="hljs C"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @file</span><span class="hljs-comment"> * Ethernet Interface Skeleton</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright (c) 2001-2004 Swedish Institute of Computer Science.</span><span class="hljs-comment"> * All rights reserved.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Redistribution and use in source and binary forms, with or without modification,</span><span class="hljs-comment"> * are permitted provided that the following conditions are met:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 1. Redistributions of source code must retain the above copyright notice,</span><span class="hljs-comment"> *    this list of conditions and the following disclaimer.</span><span class="hljs-comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span><span class="hljs-comment"> *    this list of conditions and the following disclaimer in the documentation</span><span class="hljs-comment"> *    and/or other materials provided with the distribution.</span><span class="hljs-comment"> * 3. The name of the author may not be used to endorse or promote products</span><span class="hljs-comment"> *    derived from this software without specific prior written permission.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#x27;&#x27; AND ANY EXPRESS OR IMPLIED</span><span class="hljs-comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span><span class="hljs-comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span><span class="hljs-comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span><span class="hljs-comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span><span class="hljs-comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span><span class="hljs-comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span><span class="hljs-comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span><span class="hljs-comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span><span class="hljs-comment"> * OF SUCH DAMAGE.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * This file is part of the lwIP TCP/IP stack.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * This file is a skeleton for developing Ethernet network interface</span><span class="hljs-comment"> * drivers for lwIP. Add code to the low_level functions and do a</span><span class="hljs-comment"> * search-and-replace for the word &quot;ethernetif&quot; to replace it with</span><span class="hljs-comment"> * something that better describes your network interface.</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/opt.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1 <span class="hljs-comment">/* don&#x27;t build, this is only a skeleton, see previous comment */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/def.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/mem.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/pbuf.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/stats.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/snmp.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/ethip6.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/etharp.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;netif/ppp/pppoe.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;enc28j60.h&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">enc28j60_t</span> enc28j60;<span class="hljs-comment">/* Define those to better describe your network interface. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNAME0 <span class="hljs-meta-string">&#x27;e&#x27;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNAME1 <span class="hljs-meta-string">&#x27;n&#x27;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Helper struct to hold private data used to operate your ethernet interface.</span><span class="hljs-comment"> * Keeping the ethernet address of the MAC in this struct is not necessary</span><span class="hljs-comment"> * as it is already kept in the struct netif.</span><span class="hljs-comment"> * But this is only an example, anyway...</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethernetif</span> &#123;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_addr</span> *<span class="hljs-title">ethaddr</span>;</span>  <span class="hljs-comment">/* Add whatever per-interface state that is needed here. */</span>&#125;;<span class="hljs-comment">/* Forward declarations. */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">ethernetif_input</span><span class="hljs-params">(struct netif *netif)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * In this function, the hardware should be initialized.</span><span class="hljs-comment"> * Called from ethernetif_init().</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param netif the already initialized lwip network interface structure</span><span class="hljs-comment"> *        for this ethernetif</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>low_level_init(struct netif *netif)&#123;  <span class="hljs-comment">//struct ethernetif *ethernetif = netif-&gt;state;</span>  <span class="hljs-comment">/* set MAC hardware address length */</span>  netif-&gt;hwaddr_len = ETHARP_HWADDR_LEN;  <span class="hljs-comment">/* set MAC hardware address */</span>  <span class="hljs-built_in">memcpy</span>(netif-&gt;hwaddr, enc28j60.mac_addr, <span class="hljs-number">6</span>); <span class="hljs-comment">// 这里设置MAC地址</span>  <span class="hljs-comment">/* maximum transfer unit */</span>  netif-&gt;mtu = <span class="hljs-number">1500</span>;  <span class="hljs-comment">/* device capabilities */</span>  <span class="hljs-comment">/* don&#x27;t set NETIF_FLAG_ETHARP if this device is not an ethernet one */</span>  netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">   * For hardware/netifs that implement MAC filtering.</span><span class="hljs-comment">   * All-nodes link-local is handled by default, so we must let the hardware know</span><span class="hljs-comment">   * to allow multicast packets in.</span><span class="hljs-comment">   * Should set mld_mac_filter previously. */</span>  <span class="hljs-keyword">if</span> (netif-&gt;mld_mac_filter != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-keyword">ip6_addr_t</span> ip6_allnodes_ll;    ip6_addr_set_allnodes_linklocal(&amp;ip6_allnodes_ll);    netif-&gt;mld_mac_filter(netif, &amp;ip6_allnodes_ll, NETIF_ADD_MAC_FILTER);  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD */</span></span>  <span class="hljs-comment">/* Do whatever else is needed to initialize interface. */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * This function should do the actual transmission of the packet. The packet is</span><span class="hljs-comment"> * contained in the pbuf that is passed to the function. This pbuf</span><span class="hljs-comment"> * might be chained.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param netif the lwip network interface structure for this ethernetif</span><span class="hljs-comment"> * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)</span><span class="hljs-comment"> * @return ERR_OK if the packet could be sent</span><span class="hljs-comment"> *         an err_t value if the packet couldn&#x27;t be sent</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to</span><span class="hljs-comment"> *       strange results. You might consider waiting for space in the DMA queue</span><span class="hljs-comment"> *       to become available since the stack doesn&#x27;t retry to send a packet</span><span class="hljs-comment"> *       dropped because of memory failure (except for the TCP timers).</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">err_t</span>low_level_output(struct netif *netif, struct pbuf *p)&#123;  <span class="hljs-comment">//struct ethernetif *ethernetif = netif-&gt;state;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pbuf</span> *<span class="hljs-title">q</span>;</span>  <span class="hljs-comment">//initiate transfer();</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>  pbuf_header(p, -ETH_PAD_SIZE); <span class="hljs-comment">/* drop the padding word */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-keyword">for</span> (q = p; q != <span class="hljs-literal">NULL</span>; q = q-&gt;next) &#123;    <span class="hljs-comment">/* Send the data from the pbuf to the interface, one pbuf at a</span><span class="hljs-comment">       time. The size of the data in each pbuf is kept in the -&gt;len</span><span class="hljs-comment">       variable. */</span>    <span class="hljs-comment">//send data from(q-&gt;payload, q-&gt;len);</span>    enc28j60_send(&amp;enc28j60, q-&gt;payload, q-&gt;len); <span class="hljs-comment">// 这里发送</span>  &#125;  <span class="hljs-comment">//signal that packet should be sent();</span>  MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p-&gt;tot_len);  <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">u8_t</span>*)p-&gt;payload)[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">/* broadcast or multicast packet*/</span>    MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">/* unicast packet */</span>    MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);  &#125;  <span class="hljs-comment">/* increase ifoutdiscards or ifouterrors on error */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>  pbuf_header(p, ETH_PAD_SIZE); <span class="hljs-comment">/* reclaim the padding word */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  LINK_STATS_INC(link.xmit);  <span class="hljs-keyword">return</span> ERR_OK;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Should allocate a pbuf and transfer the bytes of the incoming</span><span class="hljs-comment"> * packet from the interface into the pbuf.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param netif the lwip network interface structure for this ethernetif</span><span class="hljs-comment"> * @return a pbuf filled with the received packet (including MAC header)</span><span class="hljs-comment"> *         NULL on memory error</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pbuf</span> *</span><span class="hljs-class"><span class="hljs-title">low_level_input</span>(<span class="hljs-title">struct</span> <span class="hljs-title">netif</span> *<span class="hljs-title">netif</span>)</span><span class="hljs-class">&#123;</span>  <span class="hljs-comment">//struct ethernetif *ethernetif = netif-&gt;state;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pbuf</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>;</span>  <span class="hljs-keyword">u16_t</span> len;  <span class="hljs-comment">/* Obtain the size of the packet and put it into the &quot;len&quot;</span><span class="hljs-comment">     variable. */</span>  len = <span class="hljs-number">1518</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>  len += ETH_PAD_SIZE; <span class="hljs-comment">/* allow room for Ethernet padding */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-comment">/* We allocate a pbuf chain of pbufs from the pool. */</span>  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);  <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>    pbuf_header(p, -ETH_PAD_SIZE); <span class="hljs-comment">/* drop the padding word */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">/* We iterate over the pbuf chain until we have read the entire</span><span class="hljs-comment">     * packet into the pbuf. */</span>    <span class="hljs-keyword">for</span> (q = p; q != <span class="hljs-literal">NULL</span>; q = q-&gt;next) &#123;      <span class="hljs-comment">/* Read enough bytes to fill this pbuf in the chain. The</span><span class="hljs-comment">       * available data in the pbuf is given by the q-&gt;len</span><span class="hljs-comment">       * variable.</span><span class="hljs-comment">       * This does not necessarily have to be a memcpy, you can also preallocate</span><span class="hljs-comment">       * pbufs for a DMA-enabled MAC and after receiving truncate it to the</span><span class="hljs-comment">       * actually received size. In this case, ensure the tot_len member of the</span><span class="hljs-comment">       * pbuf is the sum of the chained pbuf len members.</span><span class="hljs-comment">       */</span>      <span class="hljs-comment">//read data into(q-&gt;payload, q-&gt;len);</span>      <span class="hljs-keyword">if</span> (enc28j60_recv(&amp;enc28j60, q-&gt;payload, q-&gt;len)) &#123; <span class="hljs-comment">// 这里接收</span>        <span class="hljs-comment">//netif.input(buff, &amp;netif);</span>      &#125;    &#125;    <span class="hljs-comment">//acknowledge that packet has been read();</span>    MIB2_STATS_NETIF_ADD(netif, ifinoctets, p-&gt;tot_len);    <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">u8_t</span>*)p-&gt;payload)[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">/* broadcast or multicast packet*/</span>      MIB2_STATS_NETIF_INC(netif, ifinnucastpkts);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">/* unicast packet*/</span>      MIB2_STATS_NETIF_INC(netif, ifinucastpkts);    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ETH_PAD_SIZE</span>    pbuf_header(p, ETH_PAD_SIZE); <span class="hljs-comment">/* reclaim the padding word */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    LINK_STATS_INC(link.recv);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//drop packet();</span>    LINK_STATS_INC(link.memerr);    LINK_STATS_INC(link.drop);    MIB2_STATS_NETIF_INC(netif, ifindiscards);  &#125;  <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * This function should be called when a packet is ready to be read</span><span class="hljs-comment"> * from the interface. It uses the function low_level_input() that</span><span class="hljs-comment"> * should handle the actual reception of bytes from the network</span><span class="hljs-comment"> * interface. Then the type of the received packet is determined and</span><span class="hljs-comment"> * the appropriate input function is called.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param netif the lwip network interface structure for this ethernetif</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>ethernetif_input(struct netif *netif)&#123;  <span class="hljs-comment">//struct ethernetif *ethernetif;</span>  <span class="hljs-comment">//struct eth_hdr *ethhdr;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pbuf</span> *<span class="hljs-title">p</span>;</span>  <span class="hljs-comment">//ethernetif = netif-&gt;state;</span>  <span class="hljs-comment">/* move received packet into a new pbuf */</span>  p = low_level_input(netif);  <span class="hljs-comment">/* if no packet could be read, silently ignore this */</span>  <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-comment">/* pass all packets to ethernet_input, which decides what packets it supports */</span>    <span class="hljs-keyword">if</span> (netif-&gt;input(p, netif) != ERR_OK) &#123;      LWIP_DEBUGF(NETIF_DEBUG, (<span class="hljs-string">&quot;ethernetif_input: IP input error\n&quot;</span>));      pbuf_free(p);      p = <span class="hljs-literal">NULL</span>;    &#125;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Should be called at the beginning of the program to set up the</span><span class="hljs-comment"> * network interface. It calls the function low_level_init() to do the</span><span class="hljs-comment"> * actual setup of the hardware.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * This function should be passed as a parameter to netif_add().</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param netif the lwip network interface structure for this ethernetif</span><span class="hljs-comment"> * @return ERR_OK if the loopif is initialized</span><span class="hljs-comment"> *         ERR_MEM if private data couldn&#x27;t be allocated</span><span class="hljs-comment"> *         any other err_t on error</span><span class="hljs-comment"> */</span><span class="hljs-keyword">err_t</span>ethernetif_init(struct netif *netif)&#123;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethernetif</span> *<span class="hljs-title">ethernetif</span>;</span>  LWIP_ASSERT(<span class="hljs-string">&quot;netif != NULL&quot;</span>, (netif != <span class="hljs-literal">NULL</span>));  ethernetif = mem_malloc(<span class="hljs-keyword">sizeof</span>(struct ethernetif));  <span class="hljs-keyword">if</span> (ethernetif == <span class="hljs-literal">NULL</span>) &#123;    LWIP_DEBUGF(NETIF_DEBUG, (<span class="hljs-string">&quot;ethernetif_init: out of memory\n&quot;</span>));    <span class="hljs-keyword">return</span> ERR_MEM;  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LWIP_NETIF_HOSTNAME</span>  <span class="hljs-comment">/* Initialize interface hostname */</span>  netif-&gt;hostname = <span class="hljs-string">&quot;lwip&quot;</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* LWIP_NETIF_HOSTNAME */</span></span>  <span class="hljs-comment">/*</span><span class="hljs-comment">   * Initialize the snmp variables and counters inside the struct netif.</span><span class="hljs-comment">   * The last argument should be replaced with your link speed, in units</span><span class="hljs-comment">   * of bits per second.</span><span class="hljs-comment">   */</span>  MIB2_INIT_NETIF(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);  netif-&gt;state = ethernetif;  netif-&gt;name[<span class="hljs-number">0</span>] = IFNAME0;  netif-&gt;name[<span class="hljs-number">1</span>] = IFNAME1;  <span class="hljs-comment">/* We directly use etharp_output() here to save a function call.</span><span class="hljs-comment">   * You can instead declare your own function an call etharp_output()</span><span class="hljs-comment">   * from it if you have to do some checks before sending (e.g. if link</span><span class="hljs-comment">   * is available...) */</span>  netif-&gt;output = etharp_output;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LWIP_IPV6</span>  netif-&gt;output_ip6 = ethip6_output;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* LWIP_IPV6 */</span></span>  netif-&gt;linkoutput = low_level_output;  ethernetif-&gt;ethaddr = (struct eth_addr *)&amp;(netif-&gt;hwaddr[<span class="hljs-number">0</span>]);  <span class="hljs-comment">/* initialize the hardware */</span>  low_level_init(netif);  <span class="hljs-keyword">return</span> ERR_OK;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* 0 */</span></span></code></pre><h5 id="lwipport-c"><a href="#lwipport-c" class="headerlink" title="lwipport.c"></a>lwipport.c</h5><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lwip/mem.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mem_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEM_POOL_SIZE 10240</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> mem[MEM_POOL_SIZE];    init_memory_pool(MEM_POOL_SIZE, mem);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">mem_trim</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">mem_size_t</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> mem;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>[1] <a href="https://lwip.fandom.com/wiki/LwIP_Wiki">LwIP Wiki</a></p></li><li><p>[2] <a href="https://lwip.fandom.com/wiki/LwIP_Platform_Developers_Manual">LwIP Platform Developers Manual</a></p></li><li><p>[3] <a href="https://lwip.fandom.com/wiki/Porting_For_Bare_Metal">Porting For Bare Metal</a></p></li><li><p>[4] <a href="https://lwip.fandom.com/wiki/Writing_a_device_driver">Writing a device driver</a></p></li><li><p>[5] <a href="https://lwip.fandom.com/wiki/Initialization_for_simple_lwIP">Initialization for simple lwIP</a></p></li><li><p>[6] <a href="https://lwip.fandom.com/wiki/LwIP_with_or_without_an_operating_system">LwIP with or without an operating system</a></p></li><li><p>[7] <a href="https://github.com/lwip-tcpip/lwip">LwIP github mirror</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6 TCP协议</title>
    <link href="/2021/01/15/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/15/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><strong>术语</strong></p><p>Otect：八位字节（可直接理解成字节）。</p><p>TCP Segment：TCP段。</p><p>Max Segment Lifetime：MSL，TCP段最长寿命。</p><p>Connection Termination Request：CRT，连接终止请求。</p><h3 id="1-TCP的序列思想"><a href="#1-TCP的序列思想" class="headerlink" title="1 TCP的序列思想"></a>1 TCP的序列思想</h3><p>TCP为<strong>某些控制标志</strong>和<strong>用户数据中的每个octet</strong>进行编号（序列号，递增，详细编号规则说明见<strong>第3章</strong>），逻辑上类似于把用户数据拷贝进一个2^32大的环型缓冲区中。TCP通过序列化的设计，将其操作的对象（原本碎片化的用户数据）直接抽象成一个环型缓冲区。</p><p>TCP发送时，会从<strong>某个序列号</strong>开始往另一端发送数据，每次发送<strong>一段序列</strong>（本质上是一段数据）。可以对任意一个序列号进行ACK，收到一个值为X的ACK表示之前所有直到X-1的otects都已经被收到。所以接收方的ACK值也表明了发送方下次发送数据时要从哪个otect（或者说哪个序列号）开始。由于ACK的设计，随着一次次或成功或失败的发送，可以想象序列号一直向前移动，直到用户的数据被发送完毕为止，接收过程同理。</p><p>按照上述描述，每个TCP都管理了两个环型缓存区，一个用于发送数据到另一端，一个用于接收另一端的数据。如果把序列号想象为内存地址，那么一个TCP发送操作类似于把从某个内存地址开始的某段数据传给另一端。</p><pre><code class="hljs fortran">struct &#123; u8 *tx_mem; u32 seq; <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span> &#125; <span class="hljs-keyword">local</span>;struct &#123; u8 *rx_mem; u32 ack; <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span> &#125; remote;<span class="hljs-keyword">local</span>                                                            remote                       <span class="hljs-keyword">data</span>(<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq, <span class="hljs-built_in">size</span>)-&gt;                                                 remote<span class="hljs-number">.</span>ack=<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq+x                                                              (x&lt;=<span class="hljs-built_in">size</span>)                          &lt;-ack(remote<span class="hljs-number">.</span>ack)<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq=remote<span class="hljs-number">.</span>ack                       <span class="hljs-keyword">data</span>(<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq, <span class="hljs-built_in">size</span>)-&gt;                                <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span></code></pre><blockquote><p>注：<br>data(local.seq,size)-&gt;表示把<br>[local.tx_mem+local.seq, local.tx_mem+local.seq+local.size)<br>这段内存数据发送给远端。</p></blockquote><p>一个满足上述需求是段格式如下：</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|          Source Port          |       Destination Port        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                        Sequence Number                        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Acknowledgment Number                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|           Checksum            |            Reserved           |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                             Data                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+</code></pre><h3 id="2-序列重叠问题"><a href="#2-序列重叠问题" class="headerlink" title="2 序列重叠问题"></a>2 序列重叠问题</h3><p>按照正常思路，每次启动传输时，序列号应该总是从0开始，一直到size-1结束（假设要传输的数据大小为size）。然而，如果一端的TCP频繁打开、发送、关闭，又打开、发送、关闭。那么可以想象，<strong>网络中</strong>可能会存在序列号重叠但数据不同的TCP段：</p><pre><code class="hljs gherkin">0            size1|<span class="hljs-string">------------</span>||<span class="hljs-string">------</span>|0      size2</code></pre><p>为了避免这个问题，TCP每次传输时不再从序列号0开始，而是将选择和一个32bit的时钟绑定，TCP假设该时钟每4us自增1，所以序列号大约需要4.55个小时才会回到原点（重复）。由于TCP假定所有TCP段在网络中存在的时长最多不过MSL（Max Segment Lifetime），而MSL小于4.55小时，所以上述措施保证了序列号在网络中不会重复。换言之就是，TCP并非从0开始传输，而是从某个序列号开始，而这个序列号的选择和一个32bit的时钟相关，这个序列号又被称为初始序列号（ISN, Initial Sequence Number）。</p><p>然而这样一来，每次TCP传输数据前，就需要事先交换彼此当前的序列号（同步信息）：</p><pre><code class="hljs ada"><span class="hljs-number">1</span>) A <span class="hljs-comment">--&gt; B  我的序列号是 X</span><span class="hljs-number">2</span>) A &lt;<span class="hljs-comment">-- B  你的序列号是 X</span><span class="hljs-number">3</span>) A &lt;<span class="hljs-comment">-- B  我的序列号是 Y</span><span class="hljs-number">4</span>) A <span class="hljs-comment">--&gt; B  你的序列号是 Y</span></code></pre><p>其中2)和3)可以合并进行，合并后便成了TCP中著名的“三次握手”。</p><p>此时，TCP段格式中的Sequence Number有了两层含义，一是最开始提到的指示<strong>数据的传输状态</strong>的序列号，另一个是此处提到的，在传输数据之前，作为彼此交换信息的初始序列号。TCP在其段中设计了一个SYN标志，以便区分Sequence Number的两种状态。当SYN为1时，Sequence Number字段表示ISN，否则则表示传输过程中使用的序列号。同理，由于Acknowledgment Number和Sequence Number是一对对应的参数，第一个发送ISN的TCP，其报文中的Acknowledgment Number是一个无效值，为此，TCP引入ACK标志表明Acknowledgment Number的有效无效状态。</p><pre><code class="hljs tp"><span class="hljs-number">1</span>) A --&gt; B  SYN      我的序列号是 <span class="hljs-keyword">X</span><span class="hljs-number">2</span>) A &lt;-- B  SYN,ACK  你的序列号是 <span class="hljs-keyword">X</span>，我的序列号是 <span class="hljs-keyword">Y</span><span class="hljs-number">4</span>) A --&gt; B  ACK      你的序列号是 <span class="hljs-keyword">Y</span></code></pre><p>通过上述描述可知，每个TCP都有两个序列号需要维护，一个是初始发送序列号（ISS, Initial Send Sequence），此序列号由本地TCP从上述提到的32bit时钟中产生，另一个是初始接收序列号（IRS, Initial Receive Sequence），此序列号在三次握手后从远端TCP得到，是远端的ISS。</p><pre><code class="hljs applescript"><span class="hljs-keyword">local</span>   remoteISS  <span class="hljs-comment">---  IRS</span>IRS  <span class="hljs-comment">---  ISS</span></code></pre><p>TCP传输数据的过程，逻辑上就是交换彼此序列空间的过程。</p><h4 id="连接的概念"><a href="#连接的概念" class="headerlink" title="连接的概念"></a>连接的概念</h4><p>至此，在开始实际的数据传输之前，一对TCP必须交换（同步）彼此的状态，除了需要同步的状态外，TCP内部本身也有一些状态需要在数据传输前初始化，然后才能进行传输。在数据传输过程中，这些状态也需要维护。数据传输结束后还需释放这些状态占用的资源。TCP将这些状态（信息）定义为连接，在实际数据传输之前需要先建立连接，在传输结束后需要关闭连接。建立连接前与关闭连接后，TCP处于一个虚拟的CLOSED状态，因为此时TCP并不存在。</p><p>TCP的状态信息被存放在一个传输控制块（TCB, Transmission Control Block）中。TCB中可能包含：本地和远程socket信息，当前连接的安全及优先权，指向用户发送及接收缓冲区的指针，指向重传队列以及当前TCP段的指针。此外一些涉及发送和接收序列的变量也在TCB中。</p><p><strong>发送序列变量</strong></p><ul><li>SND.UNA：已发送但未被ACK的最大序列号</li><li>SND.NXT：下一次要发送的序列号</li><li>SND.WND：发送窗口</li><li>SND.UP：发送紧急指针</li><li>SND.WL1：segment sequence number used for last window update【TODO】</li><li>SND.WL2：segment acknowledgment number used for last window update【TODO】</li><li>ISS：初始发送序列号</li></ul><p>发送序列空间：</p><pre><code class="hljs angelscript">    <span class="hljs-number">1</span>         <span class="hljs-number">2</span>          <span class="hljs-number">3</span>          <span class="hljs-number">4</span>----------|----------|----------|----------        SND.UNA    SND.NXT    SND.UNA+SND.WND<span class="hljs-number">1</span> - 已经被ACK的序列号<span class="hljs-number">2</span> - 没有被ACK的序列号<span class="hljs-number">3</span> - 允许传输的序列号<span class="hljs-number">4</span> - 禁止传输的序列号</code></pre><p><strong>接收序列变量</strong></p><ul><li>RCV.NXT：下一个要接受的序列号</li><li>RCV.WND：接收窗口</li><li>RCV.UP：接收紧急指针</li><li>IRS：初始接收序列号</li></ul><p>接收序列空间：</p><pre><code class="hljs angelscript">    <span class="hljs-number">1</span>          <span class="hljs-number">2</span>          <span class="hljs-number">3</span>----------|----------|----------        RCV.NXT    RCV.NXT+RCV.WND<span class="hljs-number">1</span> - 已经被ACK的序列号<span class="hljs-number">2</span> - 允许接收的序列号<span class="hljs-number">3</span> - 尚未允许接收的序列号</code></pre><p><strong>TCP段变量</strong></p><ul><li>SEG.SEQ：段的序列号</li><li>SEG.ACK：段的Ack值</li><li>SEG.LEN：段长度</li></ul><h4 id="TCB变量创建与维护"><a href="#TCB变量创建与维护" class="headerlink" title="TCB变量创建与维护"></a>TCB变量创建与维护</h4><p>在OPEN时，初始化以下变量：</p><pre><code class="hljs ini"><span class="hljs-attr">ISS</span> = ? // 根据<span class="hljs-number">32</span>bit时钟<span class="hljs-attr">SND.UNA</span> = ISS<span class="hljs-attr">SND.NXT</span> = ISS+<span class="hljs-number">1</span><span class="hljs-attr">RCV.WND</span> = ? // 根据本地tcp配置设置</code></pre><p>在同步过程中，初始化以下变量（从对方状态信息中提取初始化数据）：</p><pre><code class="hljs ini"><span class="hljs-attr">SND.WND</span> = SYN.RCV.WND<span class="hljs-attr">IRS</span> = SYN.SEQ<span class="hljs-attr">RCV.NXT</span> = SYN.SEQ+<span class="hljs-number">1</span></code></pre><p>传输数据的过程中（基本上只要维护好SND.UNA和RCV.NXT）：</p><pre><code class="hljs x86asm">    A              B<span class="hljs-number">1</span>) A<span class="hljs-number">.</span>snd<span class="hljs-number">.</span>una &lt;--- B<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>ack <span class="hljs-number">4</span>)           =|      ^            v      |=<span class="hljs-number">2</span>) A<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>seq ---&gt; B<span class="hljs-number">.</span>rcv<span class="hljs-number">.</span>nxt <span class="hljs-number">3</span>)发送时：<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ = SND<span class="hljs-number">.</span>UNA<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK = RCV<span class="hljs-number">.</span>NXTSND<span class="hljs-number">.</span>NXT += <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>LEN（段长度）接收时：SND<span class="hljs-number">.</span>UNA = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK（如果该<span class="hljs-built_in">SEG</span>中的ACK合法）RCV<span class="hljs-number">.</span>NXT = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ（如果该<span class="hljs-built_in">SEG</span>中的数据合法）</code></pre><h3 id="3-TCP的编号规则"><a href="#3-TCP的编号规则" class="headerlink" title="3 TCP的编号规则"></a>3 TCP的编号规则</h3><p>根据前边的描述，TCP处理的对象是一段由序列号构成的序列，所有序列号构成整个序列空间。TCP将序列分段成TCP段进行传输，因此TCP段占了序列空间的一部分，TCP段长度就是这一部分序列空间的大小，或者说段长度就是这个段传了多少个序列号。</p><p><strong>注意！本文中的段长度并不是指TCP段的头部加data部分的总长度</strong>。TCP段头部加data部分的总长度可以根据IP报文计算得出。</p><pre><code class="hljs brainfuck"><span class="hljs-comment">一段序列A（大小为n）：</span><span class="hljs-comment"></span>               <span class="hljs-comment">S0</span>                            <span class="hljs-comment">Sn</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-comment"></span>               --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">将序列拆分成多个段进行传输：</span><span class="hljs-comment"></span>              --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">|</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">|</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>                   <span class="hljs-comment">/</span>          <span class="hljs-comment">|</span>          <span class="hljs-comment">\</span><span class="hljs-comment"></span>            --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>   --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>   --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>            <span class="hljs-comment">S0</span>       <span class="hljs-comment">Sq</span>  <span class="hljs-comment">Sq</span><span class="hljs-literal">+</span><span class="hljs-comment">1</span>      <span class="hljs-comment">Sp</span>  <span class="hljs-comment">Sp</span><span class="hljs-literal">+</span><span class="hljs-comment">1</span>     <span class="hljs-comment">Sn</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-comment"></span>            <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg0</span>     <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg1</span>      <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg2</span></code></pre><p>如上图所示，TCP将序列A分成三个segment进行传输，其中seg0的段长度为q+1。</p><p>TCP将序列号分配给TCP段的data域中的每个otect，以及SYN、FIN。举例来说，一个不包含data的SYN段其段长度为1（因为data占用了0个序列号，而SYN占用了1个序列号），一个不包含data的FIN段长度也是1。</p><p>一个包含data（data大小为4）的SYN段其段长度为5，此时编号规则如下：</p><pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   |序   号 <span class="hljs-attribute">SYN</span>    D<span class="hljs-number">0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     |数据控制</code></pre><p>一个包含data（data大小为5）的FIN段其长度为6，此时编号规则如下：</p><pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">5</span>   |序   号 <span class="hljs-attribute">D0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     D<span class="hljs-number">4</span>     FIN    |数据控制</code></pre><p>假设一个更具体的例子，如果需要通过TCP将<code>&quot;Hello!&quot;</code>传输给远端，并且传输结束后就关闭连接，那么，我们将发送8个序列号给远端。假设初始发送序列号为x，则序列号及其对应的数据（或控制信息）关系如下：</p><pre><code class="hljs gml">S[<span class="hljs-symbol">x</span>  ] = SYNS[<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;H&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;e&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;l&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;l&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;o&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;!&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">7</span>] = FIN</code></pre><h3 id="4-传输前的状态"><a href="#4-传输前的状态" class="headerlink" title="4 传输前的状态"></a>4 传输前的状态</h3><p>根据2中的描述，在此仔细考察一下TCP交换信息的过程。两种情况：1)一端先发起SYN，2)两端同时发起SYN。</p><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><pre><code class="hljs clean">B     A       B        B            A           A        B监听-&gt;发送SYN-&gt;收到SYN-&gt;发送SYN,ACK-&gt;收到SYN,ACK-&gt;发送ACK-&gt;收到ACK</code></pre><p>起初，在没有人尝试连接的时候，B一直处于监听状态（B处于LISTEN状态），随后A向B发送一个<code>&lt;SYN&gt;</code>，然后等待B的<code>&lt;ACK&gt;</code>（A处于SYN-SENT状态），B收到A的<code>&lt;SYN&gt;</code>后向A发出<code>&lt;SYN,ACK&gt;</code>然后等待A的<code>&lt;ACK&gt;</code>（B处于SYN-RECEIVED状态）</p><blockquote><p>注：为什么B发SYN却不是SYN-SENT状态？怎么理解状态？</p><p>状态是对<strong>一段过程</strong>中存在<strong>持续部分</strong>的描述，比如说打电话这个过程，有拨号（等待接通），通话（等待信息传递完毕），挂断（过程结束）三个状态。所以状态有两个特点：对于一段过程来说，状态是这段过程的流程、步骤。对于持续部分来说，状态是会持续的，是会等待外部事件引起改变的。所以状态机设计时，一个状态到底是不是状态可以从这两方面进行考虑，它是不是一段过程中的某个步骤，它是不是需要等待外部引起变化。</p><p>从过程的角度想：<code>LISTEN-&gt;SENT-&gt;RECEIVED-&gt;ESTABLISHED</code>比<code>LISTEN-&gt;SENT-&gt;ESTABLISHED</code>更合适。</p></blockquote><pre><code class="hljs django"><span class="xml">    TCP A                                                TCP B</span><span class="xml">1.                                                       LISTEN</span><span class="xml">2.  SYN-SENT    --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN</span>&gt;</span>               --&gt; SYN-RECEIVED</span><span class="xml">3.  ESTABLISHED <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span> <span class="hljs-attr">SYN-RECEIVED</span></span></span><span class="xml">4.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>       --&gt; ESTABLISHED</span><span class="xml">5.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">DATA</span>&gt;</span> --&gt; ESTABLISHED</span></code></pre><p>这个过程中，两端的TCP至少有四种状态：</p><ol><li><p>LISTEN：等待其他TCP的<code>&lt;SYN&gt;</code>。</p></li><li><p>SYN-SENT：发送<code>&lt;SYN&gt;</code>后，等待远端TCP的<code>&lt;SYN,ACK&gt;</code>。</p></li><li><p>SYN-RECEIVED：发送<code>&lt;SYN,ACK&gt;</code>后，等待远端TCP的<code>&lt;ACK&gt;</code>。</p></li><li><p>ESTABLISHED：同步完成。</p></li></ol><p>状态迁移图（横线上方是事件，下方是动作）：</p><pre><code class="hljs gherkin">                             +---------+     ?                                 |<span class="hljs-string">  LISTEN </span>|<span class="hljs-string">&lt;----------    </span><span class="hljs-string">                             +---------+                     </span>|<span class="hljs-string">     ?</span><span class="hljs-string">                  rcv SYN      </span>|<span class="hljs-string">                             </span>|<span class="hljs-string"> ---------</span><span class="hljs-string">                 -----------   </span>|<span class="hljs-string">                             v  snd SYN</span><span class="hljs-string">+---------+      snd SYN,ACK  /                            +---------+</span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;-----------------                              </span>|<span class="hljs-string">         </span>||<span class="hljs-string">   SYN   </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">   SYN   </span>||<span class="hljs-string">   RCVD  </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">   SENT  </span>||<span class="hljs-string">         </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">         </span>||<span class="hljs-string">         </span>|<span class="hljs-string">------------------           -------------------</span>|<span class="hljs-string">         </span>|+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+              --------------   |<span class="hljs-string">     </span>|<span class="hljs-string">   -----------</span><span class="hljs-string">                     x         </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     snd ACK</span><span class="hljs-string">                               V     V</span><span class="hljs-string">                             +---------+</span><span class="hljs-string">                             </span>|<span class="hljs-string">  ESTAB  </span>|                             +---------+</code></pre><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>【TODO】</p><h3 id="5-传输过程及机制"><a href="#5-传输过程及机制" class="headerlink" title="5 传输过程及机制"></a>5 传输过程及机制</h3><h4 id="有效响应及数据"><a href="#有效响应及数据" class="headerlink" title="有效响应及数据"></a>有效响应及数据</h4><p>当收到一个ACK段时，一个有效响应指该ACK段中的ACK号满足：</p><pre><code class="hljs stylus">SND<span class="hljs-selector-class">.UNA</span> &lt; SEG<span class="hljs-selector-class">.ACK</span> =&lt; SND.NXT。</code></pre><p>当收到一个数据段时，需要根据以下四种情况判别收到的段是否有效。</p><pre><code class="hljs stylus">段长度   接收窗口  判别条件------- --------  -------------------------------------------<span class="hljs-number">0</span>       <span class="hljs-number">0</span>         SEG<span class="hljs-selector-class">.SEQ</span> = RCV.NXT<span class="hljs-number">0</span>       &gt;<span class="hljs-number">0</span>        RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG<span class="hljs-selector-class">.SEQ</span> &lt; RCV.NXT+RCV.WND&gt;<span class="hljs-number">0</span>      <span class="hljs-number">0</span>         not acceptable&gt;<span class="hljs-number">0</span>      &gt;<span class="hljs-number">0</span>        RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG<span class="hljs-selector-class">.SEQ</span> &lt; RCV.NXT+RCV.WND               or RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG.SEQ+SEG<span class="hljs-selector-class">.LEN-1</span> &lt; RCV.NXT+RCV.WND</code></pre><p>当接收窗口为0时，所有除ACK、RST、URG段外的段都是无效段。因此，对于一个只发送数据的TCP来说，可以用0接收窗口传输数据，并仅接收ACK段。</p><h4 id="数据处理及TCB维护"><a href="#数据处理及TCB维护" class="headerlink" title="数据处理及TCB维护"></a>数据处理及TCB维护</h4><p>用户调用SEND接口时，TCP首先把数据缓存到内部的发送缓冲区（如果缓冲区还有剩余空间的话），然后在合适的时机从发送缓冲区中提取数据并构造TCP段发送给远端。收到数据时，TCP需要验证数据的有效性，然后按序将其推入接收缓冲区，用户调用RECEIVE接口时，便从接收缓冲区中提取数据。发送和接收过程可能都涉及到对TCP段进行拆分的操作。</p><p>在传输数据的过程中对TCB进行维护（基本上只要维护好SND.UNA和RCV.NXT）：</p><pre><code class="hljs x86asm">    A              B<span class="hljs-number">1</span>) A<span class="hljs-number">.</span>snd<span class="hljs-number">.</span>una &lt;--- B<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>ack <span class="hljs-number">4</span>)           =|      ^            v      |=<span class="hljs-number">2</span>) A<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>seq ---&gt; B<span class="hljs-number">.</span>rcv<span class="hljs-number">.</span>nxt <span class="hljs-number">3</span>)发送时（需要构造<span class="hljs-built_in">SEG</span>，<span class="hljs-built_in">SEG</span>的某些值从TCB中的相关变量中提取）：<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ = SND<span class="hljs-number">.</span>UNA<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK = RCV<span class="hljs-number">.</span>NXTSND<span class="hljs-number">.</span>NXT += <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>LEN（段长度）接收时（需要更新TCB中的变量，这些变量更新的值从<span class="hljs-built_in">SEG</span>中提取）：SND<span class="hljs-number">.</span>UNA = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK（如果该<span class="hljs-built_in">SEG</span>中的ACK合法）RCV<span class="hljs-number">.</span>NXT = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ（如果该<span class="hljs-built_in">SEG</span>中的数据合法）</code></pre><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>TCP发送一个段后会等待ACK，如果超时没有收到ACK，则进行重传，超时时间是根据网络情况动态计算得到的，该算法在RFC793中有定义，详细见<a href="https://tools.ietf.org/html/rfc793#section-3.7">RFC793 3.7 Data Communication</a></p><h4 id="Urgent机制"><a href="#Urgent机制" class="headerlink" title="Urgent机制"></a>Urgent机制</h4><p>TCP的Urgent机制使得发送数据的用户可以通知接收数据的用户去处理（接收）一些紧急的数据，并允许接收端的TCP在当前紧急数据接收完毕后，告知接收用户数据已全部接收。</p><p>当收到一个URG标志为1的TCP段时，Urgent Pointer字段生效，TCP模块必须提取段中的Sequence Number（SN）和Urgent Pointer（UP），此时的SN+UP可以得到一个序列号，该序列号指向Urgent数据的末尾，即：在SN+UP前的所有序列号（数据）都是紧急数据。</p><pre><code class="hljs angelscript">       SN         SN+UP -<span class="hljs-number">-1</span>---|---<span class="hljs-number">-2</span>-----|--<span class="hljs-number">-3</span>---<span class="hljs-number">1</span>：可能是Urgent数据，也可能不是Urgent数据。<span class="hljs-number">2</span>：Urgent数据。<span class="hljs-number">3</span>：非Urgent数据。</code></pre><p>Urgent数据没有接收完毕之前，接收端的TCP需告知用户当前处于Urgent模式，当接收完Urgent数据后，TCP需告知用户当前处于正常模式。</p><h4 id="Push机制"><a href="#Push机制" class="headerlink" title="Push机制"></a>Push机制</h4><pre><code class="hljs asciidoc">-------------------------用户     data     data----------v---------^----TCP    tx-seq     rx-seq-------------------------</code></pre><p>TCP会缓存外部数据到内部的逻辑意义上的环型缓冲区中，也就是说，用户如果调用了多次TCP.Send，TCP仅仅只是把数据拷贝到缓冲区中，并在其合适的时候将数据发送出去，并非调用一次Send就发送一个TCP段。接收过程类似。</p><p>为了能够让用户立即发送数据，TCP提供了一个PUSH标志。用户发送数据并告知TCP需要PUSH时，TCP会立即将所有未发送的数据发送。接收到带有PUSH标志的TCP段时，TCP会将所有缓存在接收缓冲区中的数据交给用户。</p><h4 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h4><p>TCP在段中设计了一个window字段，用于表明发送该段的TCP能接收多少数据，用于流控。接收窗口取决于TCP所在主机的硬件资源及系统资源。</p><pre><code class="hljs angelscript">L &lt;-- &lt;WND:<span class="hljs-number">500</span>&gt; &lt;-- R 我的（R的）窗口大小是<span class="hljs-number">500</span> L --&gt; &lt;WND:<span class="hljs-number">300</span>&gt; --&gt; R 我的（L的）窗口大小是<span class="hljs-number">300</span></code></pre><p>当TCP知道了另一端的接收窗口大小后，其发送窗口也就被限制到最大不超过另一端的接收窗口下，因为发多了对面也收不完，所以发送窗口取决于对面的接收窗口。</p><pre><code class="hljs lasso">struct &#123; u8 *tx_mem; u32 seq; u32 swnd; <span class="hljs-params">...</span> &#125; <span class="hljs-built_in">local</span>;struct &#123; u8 *rx_mem; u32 ack; u32 rwnd; <span class="hljs-params">...</span> &#125; remote;<span class="hljs-built_in">local</span>                                                                   remote                         <span class="hljs-built_in">data</span>(<span class="hljs-built_in">local</span>.seq, <span class="hljs-built_in">local</span>.swnd)-&gt;                                                        remote.ack=<span class="hljs-built_in">local</span>.seq+x                                                                     (x&lt;=size)                         &lt;<span class="hljs-params">-ack</span>(remote.ack,remote.rwnd)<span class="hljs-built_in">local</span>.seq=remote.ack <span class="hljs-built_in">local</span>.swnd=remote.rwnd                          <span class="hljs-built_in">data</span>(<span class="hljs-built_in">local</span>.seq, <span class="hljs-built_in">local</span>.swnd)-&gt;                                      <span class="hljs-params">...</span></code></pre><p>对于窗口的管理，TCP规范中提到了以下内容。</p><ol><li><p>发送TCP必须准备好接受用户的请求，并发送至少一个字节的新数据，即使发送窗口为零。发送TCP必须定期向接收TCP重传，即使窗口为零。当窗口为0时，建议重传间隔为2分钟。这种重传对于保证当任何一个TCP有一个零窗口时，窗口的重新打开将可靠地报告给另一个是至关重要的。</p><p> 对于这句话的理解，因为远程TCP的接收窗口为零，所以本地TCP的发送窗口为零，尽管本地TCP的发送窗口为零，但本地TCP仍需要能够接收用户的发送请求，并且发送至少一个字节的数据给远程TCP。这样一来，便可以周期性的探测远程TCP接收窗口的情况，如果远程TCP接收窗口重新打开，便可以继续传输数据。见Q7。</p></li><li><p>接收TCP的接收窗口为零，并且收到一个TCP段时，它仍然必须发送一个ACK给对方，表明它的下一个预期序列号和当前窗口(零)。</p><p> 如果接收TCP的接收窗口打开了，便可以通过这个ACK告知对方。</p></li><li><p>In a connection with a one-way data flow, the window information will be carried in acknowledgment segments that all have the same sequence number so there will be no way to reorder them if they arrive out of order.  This is not a serious problem, but it will allow the window information to be on occasion temporarily based on old reports from the data receiver.  A refinement to avoid this problem is to act on the window information from segments that carry the highest acknowledgment number (that is segments with acknowledgment number equal or greater than the highest previously received).</p><p> 【不理解】</p></li></ol><h3 id="6-传输后的处理"><a href="#6-传输后的处理" class="headerlink" title="6 传输后的处理"></a>6 传输后的处理</h3><p>TCP规定，关闭连接的用户可以继续接收数据，直到它被告知另一端已经被关闭。这意味着，一个程序在接连发送数据并关闭连接后，仍旧可以接收数据，直到由于另一端连接关闭而导致接收失败。规范假定TCP组件会通知用户另一端已经关闭。TCP会在连接关闭之前将所有数据发送出去。只发数据的用户必须一直读取他们发送数据后关闭的连接，直到TCP告知他们连接已关闭。</p><p>TCP通过一个FIN标志来标识一个TCP段为FIN段，当用户关闭TCP时，TCP会向另一端发送一个FIN，以告知另一端，本端的连接已经关闭。</p><p>关闭连接的三种情况：</p><ol><li><p>本地用户关闭连接</p><p> 这种情况下，TCP会构造一个FIN段添加到发送队列中，不再接受用户的发送请求，并进入FIN-WAIT-1状态，此时仍旧可以接收数据，如收到另一端对FIN段的ACK后，连接进入TIME-WAIT状态（这里之所以没有立即进入CLOSED的状态是考虑另一端可能发FIN段并等待ACK），超时后连接进入CLOSED状态。只有本地用户主动关闭连接的情况下，TCP才会发送FIN段。这意味着，一个收到FIN段的TCP仅仅会发送ACK，但不会自动发送FIN给另一端。</p></li><li><p>远端用户关闭连接（收到来自远端的FIN段）</p><p> 收到来自另一端的FIN段的TCP要对该FIN段进行ACK，并告知用户连接正在关闭，进入CLOSE-WAIT状态，等待用户关闭连接。用户收到关闭通知后应关闭TCP连接，用户关闭连接后，TCP在发送完用户数据后发送FIN段给另一端，进入LAST-ACK状态等待另一端对FIN段的ACK。如果一直没收到另一端对FIN段的ACK，连接将被中断，并告知用户。</p></li><li><p>两端用户同时关闭连接</p><p> TCP发送FIN段后又收到另一端的FIN段，进入CLOSING状态，再收到另一端的ACK后进入TIME-WAIT状态，超时后进入CLOSED状态。</p></li></ol><p>正常关闭的情况：</p><pre><code class="hljs angelscript">  TCP A                                                TCP B<span class="hljs-number">1.</span>  ESTABLISHED                                          ESTABLISHED<span class="hljs-number">2.</span>  (Close)    FIN-WAIT<span class="hljs-number">-1</span>  --&gt; &lt;SEQ=<span class="hljs-number">100</span>&gt;&lt;ACK=<span class="hljs-number">300</span>&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT<span class="hljs-number">3.</span>  FIN-WAIT<span class="hljs-number">-2</span>  &lt;-- &lt;SEQ=<span class="hljs-number">300</span>&gt;&lt;ACK=<span class="hljs-number">101</span>&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT<span class="hljs-number">4.</span>                                                       (Close)    TIME-WAIT   &lt;-- &lt;SEQ=<span class="hljs-number">300</span>&gt;&lt;ACK=<span class="hljs-number">101</span>&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK<span class="hljs-number">5.</span>  TIME-WAIT   --&gt; &lt;SEQ=<span class="hljs-number">101</span>&gt;&lt;ACK=<span class="hljs-number">301</span>&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED<span class="hljs-number">6.</span>  (<span class="hljs-number">2</span> MSL)    CLOSED</code></pre><p>两端同时关闭的情况：</p><pre><code class="hljs django"><span class="xml">  TCP A                                                TCP B</span><span class="xml">1.  ESTABLISHED                                          ESTABLISHED</span><span class="xml">2.  (Close)                                              (Close)</span><span class="xml">    FIN-WAIT-1  --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  ... FIN-WAIT-1</span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span></span></span><span class="xml">                ... <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  --&gt;</span><span class="xml">3.  CLOSING     --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      ... CLOSING</span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">--</span></span></span><span class="xml">                ... <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      --&gt;</span><span class="xml">4.  TIME-WAIT                                            TIME-WAIT</span><span class="xml">    (2 MSL)                                              (2 MSL)</span><span class="xml">    CLOSED                                               CLOSED</span></code></pre><p>状态迁移：</p><pre><code class="hljs gherkin">                             +---------+                             |<span class="hljs-string">  ESTAB  </span>|                             +---------+                      CLOSE    |<span class="hljs-string">     </span>|<span class="hljs-string">    rcv FIN</span><span class="hljs-string">                     -------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    -------</span><span class="hljs-string">+---------+          snd FIN  /       \   snd ACK          +---------+</span>|<span class="hljs-string">  FIN    </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">  CLOSE  </span>||<span class="hljs-string"> WAIT-1  </span>|<span class="hljs-string">------------------                              </span>|<span class="hljs-string">   WAIT  </span>|+---------+          rcv FIN  \                            +---------+  |<span class="hljs-string"> rcv ACK of FIN   -------   </span>|<span class="hljs-string">                            CLOSE  </span>|  |<span class="hljs-string"> --------------   snd ACK   </span>|<span class="hljs-string">                           ------- </span>|  V        x                   V                           snd FIN V+---------+                  +---------+                   +---------+|<span class="hljs-string">FINWAIT-2</span>|<span class="hljs-string">                  </span>|<span class="hljs-string"> CLOSING </span>|<span class="hljs-string">                   </span>|<span class="hljs-string"> LAST-ACK</span>|+---------+                  +---------+                   +---------+  |<span class="hljs-string">                rcv ACK of FIN </span>|<span class="hljs-string">                 rcv ACK of FIN </span>|  |<span class="hljs-string">  rcv FIN       -------------- </span>|<span class="hljs-string">    Timeout=2MSL -------------- </span>|  |<span class="hljs-string">  -------              x       V    ------------        x       V</span><span class="hljs-string">   \ snd ACK                 +---------+delete TCB         +---------+</span><span class="hljs-string">    ------------------------&gt;</span>|<span class="hljs-string">TIME WAIT</span>|<span class="hljs-string">------------------&gt;</span>|<span class="hljs-string"> CLOSED  </span>|                             +---------+                   +---------+</code></pre><h3 id="7-异常情况处理"><a href="#7-异常情况处理" class="headerlink" title="7 异常情况处理"></a>7 异常情况处理</h3><h4 id="半开连接"><a href="#半开连接" class="headerlink" title="半开连接"></a>半开连接</h4><p>如果已经建立连接的双方，1)一方在另一方不知情的情况下关闭或中断连接，或者2)同步失效，则此种连接被称为半开连接（Half Open Connectino）。当一方尝试发送数据到另一方时，连接可能会被重置（Reset）。</p><p>针对情况1)，异常的一端可能是因为连接已关闭或系统异常。针对连接关闭的情况，假设有如下连接：</p><pre><code class="hljs haskell"><span class="hljs-type">A</span>      &lt;-<span class="hljs-comment">----&gt;      B</span>         ...<span class="hljs-type">A</span> dead    x         <span class="hljs-type">B</span>         ...       &lt;--<span class="hljs-class"><span class="hljs-keyword">data</span>      <span class="hljs-type">B</span></span><span class="hljs-type">O</span>      <span class="hljs-type">RST</span><span class="hljs-comment">---&gt;      B</span></code></pre><p>起初，A与B之间已经建立连接，一段时间后，A因为某种原因中断或关闭了连接，并且B不知情。当B向A发送数据时，由于A不存在，所以TCP模块或系统内核O代替A向B发送了一个RST段。</p><p>如果系统异常（O也无法发送任何消息），B将无法收到任何回应。【不知道是否如此？】</p><p>针对情况2)，即任意一端处于LISTEN、SYN-SENT、SYN-RECEIVED状态下，如果一方收到的段中包含了<strong>不可接受的ACK</strong>，或者安全等级不匹配，则向对方发送RST段。</p><h4 id="RST段"><a href="#RST段" class="headerlink" title="RST段"></a>RST段</h4><h5 id="RST段生成"><a href="#RST段生成" class="headerlink" title="RST段生成"></a>RST段生成</h5><p>一般来说，如果收到一个明显不属于当前连接的段时，必须发送一个RST段。这种情况分为以下三种：</p><ol><li><p>连接不存在（对面向本地发送TCP段，然而本地并不存在TCP端）。</p><ol><li>如果收到的TCP段SEG中ACK域有效，则RST.SEQ=SEG.ACK，否则RST.SEQ=0并且RST.ACK=SEG.SEQ+SEG.LEN</li></ol></li><li><p>连接处于失步状态（即任意一端处于LISTEN、SYN-SENT、SYN-RECEIVED状态）</p><ol><li><p>此时收到了一个带ACK的段，并且该ACK值超过了当前的窗口（即SEG.ACK &gt; SND.UNA+SND.WND），则发送一个RST段。如果收到的TCP段SEG中ACK域有效，则RST.SEQ=SEG.ACK，否则RST.SEQ=0并且RST.ACK=SEG.SEQ+SEG.LEN</p></li><li><p>和安全相关的部分（本文暂不考虑）</p></li></ol></li><li><p>连接处于同步状态（即两端均处在ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT状态），【感觉原文中没把话说话，不好理解，见<a href="https://tools.ietf.org/html/rfc793#section-3.4">Establishing a Connection</a>中的Reset a Connection部分】</p></li></ol><h5 id="处理收到的RST段"><a href="#处理收到的RST段" class="headerlink" title="处理收到的RST段"></a>处理收到的RST段</h5><ol><li><p>检查RST段是否合法</p><p> 除SYN-SENT状态外，如果RST段的SEQ在接收窗口中，则其为合法的RST段。SYN-SENT状态下，如果RST段的ACK响应了SYN（RST-SEG.ACK=SYN.SEQ+1），则其为合法的RST段。</p></li><li><p>状态变更</p><p> 如果收到一个合法的RST段，并且接收RST段的TCP处于LISTEN状态下，则忽视该RST。如果接收RST段的TCP处于SYN-RECEIVED状态并且之前处于LISTEN状态，则重新回到LISTEN状态。其余情况下，中断连接并进入CLOSED状态。</p></li></ol><h3 id="8-接口"><a href="#8-接口" class="headerlink" title="8 接口"></a>8 接口</h3><p>详细说明见<a href="https://tools.ietf.org/html/rfc793#section-3.8">RFC793 3.8 Interfaces</a>。</p><h4 id="TCP与高层的接口"><a href="#TCP与高层的接口" class="headerlink" title="TCP与高层的接口"></a>TCP与高层的接口</h4><p>open、close、send、receive、status、abort</p><h4 id="TCP与底层的接口"><a href="#TCP与底层的接口" class="headerlink" title="TCP与底层的接口"></a>TCP与底层的接口</h4><p>如果使用IP作为TCP底层，TCP使用了IP定义的以下参数：</p><ul><li><p>Type of Service：（00000000）。</p></li><li><p>Time to Live：1分钟（00111100）。</p></li><li><p>安全选项</p></li><li><p>伪头部校验时用到的<code>source address</code>，<code>dest address</code>以及<code>protocol</code></p></li></ul><h3 id="A-附录"><a href="#A-附录" class="headerlink" title="A 附录"></a>A 附录</h3><h4 id="A-1-TCP段完整格式"><a href="#A-1-TCP段完整格式" class="headerlink" title="A.1 TCP段完整格式"></a>A.1 TCP段完整格式</h4><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|          Source Port          |       Destination Port        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                        Sequence Number                        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Acknowledgment Number                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|           Checksum            |         Urgent Pointer        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Options                    |    Padding    |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                             Data                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             大小       说明<span class="hljs-bullet">----             </span>----      ----Source Port      2B        源端口。Destination Port 2B        目的端口。Sequence Number  4B        TCP段中Data部分第一个字节的序列号。如果SYN被置位，则表示<span class="hljs-code">                           初始序列号（ISN），此时TCP段的第一个字节的序列号为ISN+1。</span>Acknowledgment   4B        下一个期望收到序列号。一旦一个连接建立后，这个字段会一直<span class="hljs-code">                           发送。由ACK标识是否有效，ACK=1时有效。</span>Data Offset      4b        TCP头部长度，单位4B。Reserved         6b        保留。URG              1b        紧急数据指针启用标志。ACK              1b        ACK标志。PSH              1b        PUSH标志。RST              1b        重置连接标志。SYN              1b        同步序列号标志。FIN              1b        发送方无更多数据。Window           2B        接收窗口大小，指示发送该WINDOW的一端接收数据时能够接收的<span class="hljs-code">                           数据量</span>Checksum         2B        校验和Urgent Pointer   2B        禁止数据指针Options          n         TCP选项Padding          m         填充字段Data             x         用户数据</code></pre><h4 id="A-2-TCP状态汇总"><a href="#A-2-TCP状态汇总" class="headerlink" title="A.2 TCP状态汇总"></a>A.2 TCP状态汇总</h4><p>连接终止请求（Connection Termination Request，CTR），可理解为向对端发送FIN段。由用户调用CLOSE接口触发发送FIN段的动作。</p><ul><li><p>LISTEN：表示正在等待远端任意的TCP连接。</p></li><li><p>SYN-SENT：发送SYN，并等待响应。</p></li><li><p>SYN-RECEIVED：收到SYN，并发送SYN,ACK，等待响应。</p></li><li><p>ESTABLISHED：收到对于SYN的ACK，进入数据传输状态。</p></li><li><p>FIN-WAIT-1：本地用户发起CTR（用户调用CLOSE，发送FIN,ACK，并等待ACK）。</p></li><li><p>FIN-WAIT-2：收到对于FIN,ACK的ACK，等待对面发起FIN,ACK。</p></li><li><p>CLOSE-WAIT：等待本地用户发起CTR（等待本地用户调用CLOSE）。</p></li><li><p>CLOSING：等待远程TCP对于CTR的ACK。</p></li><li><p>LAST-ACK：等待之前发送给远程TCP的CTR的ACK。</p></li><li><p>TIME-WAIT：等待足够的时间（在这段时间中看看对面会不会发送什么东西过来，并进行合适的回复），保证远程TCP收到了它发起的CTR的ACK</p></li><li><p>CLOSED（虚构的状态）：表示没有连接存在。</p></li></ul><h5 id="导致状态转移的事件"><a href="#导致状态转移的事件" class="headerlink" title="导致状态转移的事件"></a>导致状态转移的事件</h5><ul><li><p>OPEN、SEND、RECEIVE、CLOSE、ABORT、STATUS。</p></li><li><p>SEGMENT ARRIVES。</p></li><li><p>USER TIMEOUT、RETRANSMISSION TIMEOUT、TIME-WAIT TIMEOUT。</p></li></ul><h5 id="状态迁移图"><a href="#状态迁移图" class="headerlink" title="状态迁移图"></a>状态迁移图</h5><p>此状态图仅表示了状态转移时的事件及处理，完整逻辑见RFC793中<a href="https://tools.ietf.org/html/rfc793#section-3.9">3.9 Event Processing</a>一节。</p><pre><code class="hljs gherkin">                             +---------+ ---------\      active OPEN                             |<span class="hljs-string">  CLOSED </span>|<span class="hljs-string">            \    -----------</span><span class="hljs-string">                             +---------+&lt;---------\   \   create TCB</span><span class="hljs-string">                               </span>|<span class="hljs-string">     ^              \   \  snd SYN</span><span class="hljs-string">                  passive OPEN </span>|<span class="hljs-string">     </span>|<span class="hljs-string">   CLOSE        \   \</span><span class="hljs-string">                  ------------ </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> ----------       \   \</span><span class="hljs-string">                   create TCB  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> delete TCB         \   \</span><span class="hljs-string">                               V     </span>|<span class="hljs-string">                      \   \</span><span class="hljs-string">                             +---------+            CLOSE    </span>|<span class="hljs-string">    \</span><span class="hljs-string">                             </span>|<span class="hljs-string">  LISTEN </span>|<span class="hljs-string">          ---------- </span>|<span class="hljs-string">     </span>|                             +---------+          delete TCB |<span class="hljs-string">     </span>|                  rcv SYN      |<span class="hljs-string">     </span>|<span class="hljs-string">     SEND              </span>|<span class="hljs-string">     </span>|                 -----------   |<span class="hljs-string">     </span>|<span class="hljs-string">    -------            </span>|<span class="hljs-string">     V</span><span class="hljs-string">+---------+      snd SYN,ACK  /       \   snd SYN          +---------+</span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">         </span>||<span class="hljs-string">   SYN   </span>|<span class="hljs-string">                    rcv SYN                     </span>|<span class="hljs-string">   SYN   </span>||<span class="hljs-string">   RCVD  </span>|<span class="hljs-string">&lt;-----------------------------------------------</span>|<span class="hljs-string">   SENT  </span>||<span class="hljs-string">         </span>|<span class="hljs-string">                    snd ACK                     </span>|<span class="hljs-string">         </span>||<span class="hljs-string">         </span>|<span class="hljs-string">------------------           -------------------</span>|<span class="hljs-string">         </span>|+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+  |<span class="hljs-string">           --------------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">   -----------</span><span class="hljs-string">  </span>|<span class="hljs-string">                  x         </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     snd ACK</span><span class="hljs-string">  </span>|<span class="hljs-string">                            V     V</span><span class="hljs-string">  </span>|<span class="hljs-string">  CLOSE                   +---------+</span><span class="hljs-string">  </span>|<span class="hljs-string"> -------                  </span>|<span class="hljs-string">  ESTAB  </span>|  |<span class="hljs-string"> snd FIN                  +---------+</span><span class="hljs-string">  </span>|<span class="hljs-string">                   CLOSE    </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    rcv FIN</span><span class="hljs-string">  V                  -------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    -------</span><span class="hljs-string">+---------+          snd FIN  /       \   snd ACK          +---------+</span>|<span class="hljs-string">  FIN    </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">  CLOSE  </span>||<span class="hljs-string"> WAIT-1  </span>|<span class="hljs-string">------------------                              </span>|<span class="hljs-string">   WAIT  </span>|+---------+          rcv FIN  \                            +---------+  |<span class="hljs-string"> rcv ACK of FIN   -------   </span>|<span class="hljs-string">                            CLOSE  </span>|  |<span class="hljs-string"> --------------   snd ACK   </span>|<span class="hljs-string">                           ------- </span>|  V        x                   V                           snd FIN V+---------+                  +---------+                   +---------+|<span class="hljs-string">FINWAIT-2</span>|<span class="hljs-string">                  </span>|<span class="hljs-string"> CLOSING </span>|<span class="hljs-string">                   </span>|<span class="hljs-string"> LAST-ACK</span>|+---------+                  +---------+                   +---------+  |<span class="hljs-string">                rcv ACK of FIN </span>|<span class="hljs-string">                 rcv ACK of FIN </span>|  |<span class="hljs-string">  rcv FIN       -------------- </span>|<span class="hljs-string">    Timeout=2MSL -------------- </span>|  |<span class="hljs-string">  -------              x       V    ------------        x       V</span><span class="hljs-string">   \ snd ACK                 +---------+delete TCB         +---------+</span><span class="hljs-string">    ------------------------&gt;</span>|<span class="hljs-string">TIME WAIT</span>|<span class="hljs-string">------------------&gt;</span>|<span class="hljs-string"> CLOSED  </span>|                             +---------+                   +---------+</code></pre><h4 id="A-3-TCP事件处理备注"><a href="#A-3-TCP事件处理备注" class="headerlink" title="A.3 TCP事件处理备注"></a>A.3 TCP事件处理备注</h4><h5 id="CLOSE事件"><a href="#CLOSE事件" class="headerlink" title="CLOSE事件"></a>CLOSE事件</h5><ul><li>CLOSE<ul><li>CLOSE-WAIT STATE<br>  Queue this request until all preceding SENDs have been<br>  segmentized; then send a FIN segment, enter CLOSING state.<br>  【这里是不是应该enter LAST-ACK state？】</li></ul></li></ul><h4 id="A-4-使用TCP"><a href="#A-4-使用TCP" class="headerlink" title="A.4 使用TCP"></a>A.4 使用TCP</h4><ul><li><p>抓包<br>  sudo tcpdump -vvv -s0 host 10.0.0.1 （可以显示TCP checksum是否错误）<br>  sudo tcpdump -x -i eth0（抓网口以太网帧）</p></li><li><p>静态IP配置<br>  sudo ifconfig eth0 donw<br>  sudo ifconfig eth0 10.0.0.1 netmask 255.255.255.0<br>  sudo ifconfig eth0 up</p></li><li><p>端口占用的两种查询方式<br>  netstat -anp | grep 12345<br>  lsof -i:12345</p></li><li><p>其他</p><ul><li><p>在linux下ctrl+c杀死进程模拟close tcp，按理close后应发送fin,ack并进入FIN_WAIT_1，但实际只发了一个ack并进入FIN_WAIT_1</p></li><li><p>send() -&gt; close() -&gt; recv() -&gt; recv失败 = 连接已关闭 = 数据发送到远端。</p></li></ul></li></ul><h4 id="A-5-问题汇总"><a href="#A-5-问题汇总" class="headerlink" title="A.5 问题汇总"></a>A.5 问题汇总</h4><ul><li><p>Q1. 如果三次握手的第三次ACK没被收到会怎么样？</p><p>  将设三次握手过程如下</p>  <pre><code class="hljs django"><span class="xml">    TCP A                                                TCP B</span><span class="xml">1.                                                       LISTEN</span><span class="xml">2.  SYN-SENT    --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN</span>&gt;</span>               --&gt; SYN-RECEIVED</span><span class="xml">3.  ESTABLISHED <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span> <span class="hljs-attr">SYN-RECEIVED</span></span></span><span class="xml">4.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>       x  ESTABLISHED</span><span class="xml">5.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">DATA</span>&gt;</span> --&gt; ESTABLISHED</span></code></pre><p>  如果4的<code>&lt;ACK&gt;</code>没被B收到，可能会有几种情况发生：</p><ol><li><p>发完<code>&lt;ACK&gt;</code>后，A便开始向B传输数据，由于数据中带<code>&lt;ACK&gt;</code>，所以B会根据数据段中的<code>&lt;ACK&gt;</code>值判断连接是否建立。</p></li><li><p>发完<code>&lt;ACK&gt;</code>后，A没有立即发送数据，此时B会重传<code>&lt;SYN,ACK&gt;</code>。</p></li><li><p>异常情况下，B会重置（RST段）A。</p></li></ol></li><li><p>Q2. 如果我发送之后立即关闭，并且不做recv操作，是不是意味着数据可能没有被发送完毕？</p></li><li><p>Q3. 如果我发送之后立即关闭，然后又打开，又发送关闭，会出现什么问题？</p></li><li><p>Q4. 如果重传仍旧收不到ACK呢，比如对端主机已宕机？</p></li><li><p>Q5. 如果已建立连接的两端，一端宕机后，另一端仍旧是ESTABLISHED状态？它如何发现对面已经断开连接？</p><p>  给对面发送数据，如果异常则表明有问题（同Q4）。另一个问题：如果一直不给对面发数据，就会一直保持一个虚假的ESTABLISHED状态吗？能否主动发现对面已经挂了？</p></li><li><p>Q6. 什么时候两端会同时发SYN呢？</p></li><li><p>Q7. 发送窗口是不是仅仅取决于接收窗口，难道它不考虑本地资源？</p></li><li><p>Q8. 段长度（segment length）指什么？</p><p>  通过<strong>RFC793中关于segment length的表述</strong>可知，TCP的段长度指一个段所占用的序列空间的大小（一个段占用了一段序列，这段序列的长度就是段长度）。比如，一个段占用了序列[1,2,3,4,5]，则其段长度为5。序列中的序列号会分配给TCP段中data域中的每个otect，以及SYN、FIN。</p><p>  举例来说，一个不包含data的SYN段其段长度为1（因为data占用了0个序列号，而SYN占用了1个序列号），一个不包含data的FIN段长度也是1。</p><p>  一个包含data（data大小为4）的SYN段其段长度为5，此时编号规则如下：</p>  <pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   |序   号 <span class="hljs-attribute">SYN</span>    D<span class="hljs-number">0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     |数据控制</code></pre><p>  一个包含data（data大小为5）的FIN段其长度为6，此时编号规则如下：</p>  <pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">5</span>   |序   号 <span class="hljs-attribute">D0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     D<span class="hljs-number">4</span>     FIN    |数据控制</code></pre><p>  <strong>RFC793中关于segment length的表述</strong><br>  &gt;</p><blockquote><p>SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN).</p><p>segment length = The amount of sequence number space occupied by a segment, including any controls which occupy sequence space.</p><p>SEG.LEN - segment length</p><p>The segment length (SEG.LEN) includes both data and sequence space occupying controls.</p><p>We have taken advantage of the numbering scheme to protect certain control information as well.  This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  Control information is not physically carried in the segment data space.  Consequently, we must adopt rules for implicitly assigning sequence numbers to control.  The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  The segment length (SEG.LEN) includes both data and sequence space occupying controls.  When a SYN is present then SEG.SEQ is the sequence number of the SYN.</p></blockquote></li><li><p>Q9. 为什么初始化时（OPEN）要把SND.NXT设置为ISS+1而不是直接设置为ISS？（因为测试时，SND.NXT=ISS目前也没有遇到问题，反而ISS+1有问题）</p></li></ul><h4 id="A-6-关于协议设计的思考"><a href="#A-6-关于协议设计的思考" class="headerlink" title="A.6 关于协议设计的思考"></a>A.6 关于协议设计的思考</h4><p>协议的功能：用什么方法或机制，实现什么目标。</p><p>协议的组成：传输格式，交互过程，状态机（状态、事件、动作、状态转移），接口（对外依赖，对外提供）。</p><p>协议中有哪些角色：比如TCP中有1)发送数据的用户，2)接收数据的用户，3)发送数据的TCP，4)接收数据的TCP。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://tools.ietf.org/html/rfc793">TRANSMISSION CONTROL PROTOCOL, RFC793</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有趣的C宏</title>
    <link href="/2021/01/14/%E6%9C%89%E8%B6%A3%E7%9A%84C%E5%AE%8F/"/>
    <url>/2021/01/14/%E6%9C%89%E8%B6%A3%E7%9A%84C%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="有趣的C宏"><a href="#有趣的C宏" class="headerlink" title="有趣的C宏"></a>有趣的C宏</h2><p>不定时更新一些C宏用法</p><h3 id="1-变量后添加行号"><a href="#1-变量后添加行号" class="headerlink" title="1 变量后添加行号"></a>1 变量后添加行号</h3><p>想法来源：在一些自动生成变量而又不会<strong>直接</strong>使用到该变量的情况。</p><pre><code class="hljs reasonml">#define <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> x##y#define <span class="hljs-constructor">CONCAT(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>#define <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">v</span>)</span> <span class="hljs-constructor">CONCAT(<span class="hljs-params">v</span>,<span class="hljs-params">__LINE__</span>)</span><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span>&#123;    <span class="hljs-built_in">int</span> <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">a</span>)</span>;    return <span class="hljs-number">0</span>;&#125;</code></pre><p>预编译后：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> main()&#123;    <span class="hljs-built_in">int</span> a7;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>用法举例：</p><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;#<span class="hljs-keyword">include</span> &lt;stdint.h&gt;#<span class="hljs-keyword">include</span> &lt;<span class="hljs-built_in">string</span>.h&gt;#define <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> x##y#define <span class="hljs-constructor">CONCAT(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>#define <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">v</span>)</span> <span class="hljs-constructor">CONCAT(<span class="hljs-params">v</span>,<span class="hljs-params">__LINE__</span>)</span>#define alloc<span class="hljs-constructor">_from_stack(<span class="hljs-params">pp</span>, <span class="hljs-params">size</span>)</span> \    uint8_t <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">stack_memory</span>)</span><span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>; \    *(pp) = <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">stack_memory</span>)</span>;<span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span>&#123;    uint8_t *p;    alloc<span class="hljs-constructor">_from_stack(&amp;<span class="hljs-params">p</span>, 12)</span>;    memcpy(p, <span class="hljs-string">&quot;Hello world\0&quot;</span>, <span class="hljs-number">12</span>);    printf(<span class="hljs-string">&quot;%s\n&quot;</span>, p);    return <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="2-List-foreach"><a href="#2-List-foreach" class="headerlink" title="2 List foreach"></a>2 List foreach</h3><p>来源：如何在遍历list的同时删除其中的节点，又不暴露list内部的next指针。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">// list.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> *<span class="hljs-title">next</span>;</span>&#125; <span class="hljs-keyword">list_t</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_append(list, node) do \</span>&#123; \    <span class="hljs-keyword">list_t</span> **it = &amp;(((<span class="hljs-keyword">list_t</span> *)(<span class="hljs-built_in">list</span>))-&gt;next); \    ((<span class="hljs-keyword">list_t</span> *)node)-&gt;next = <span class="hljs-literal">NULL</span>; \    <span class="hljs-keyword">while</span> (*it) &#123; \        it = &amp;((*it)-&gt;next); \    &#125; \    (*it) = (<span class="hljs-keyword">list_t</span> *)node; \&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_foreach_remove(node) list_foreach_rm = 1; *node = (*(node))-&gt;next;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_foreach(type, name, list, do_something) \</span>    <span class="hljs-keyword">for</span> (type **name = (type **)&amp;((<span class="hljs-built_in">list</span>)-&gt;next); *name; ) &#123; \        <span class="hljs-keyword">int</span> list_foreach_rm = <span class="hljs-number">0</span>; \        do_something \        <span class="hljs-keyword">if</span> (*name &amp;&amp; !list_foreach_rm) &#123; \            name = &amp;((*name)-&gt;next); \        &#125; \    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_INIT(list) (list)-&gt;next = NULL;</span><span class="hljs-comment">// something.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">int_node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">int_node</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">int</span> val;&#125; <span class="hljs-keyword">int_node_t</span>;<span class="hljs-comment">// main.c</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">list_t</span> <span class="hljs-built_in">list</span>;    <span class="hljs-keyword">int_node_t</span> n[<span class="hljs-number">5</span>];    LIST_INIT(&amp;<span class="hljs-built_in">list</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;        n[i].val = i;        list_append(&amp;<span class="hljs-built_in">list</span>, &amp;n[i]);    &#125;    <span class="hljs-comment">// 输出：0 1 2 3 4</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (*item)-&gt;val);    &#125;);    <span class="hljs-comment">// 删除0，1，4节点</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-keyword">if</span> ((*item)-&gt;val == <span class="hljs-number">0</span> || (*item)-&gt;val == <span class="hljs-number">1</span> || (*item)-&gt;val == <span class="hljs-number">4</span>) &#123;            list_foreach_remove(item);        &#125;    &#125;);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-comment">// 输出：2 3</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (*item)-&gt;val);    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 完整输出：</span><span class="hljs-comment">0 1 2 3 4</span><span class="hljs-comment">2 3</span><span class="hljs-comment">*/</span></code></pre><h3 id="3-协程"><a href="#3-协程" class="headerlink" title="3 协程"></a>3 协程</h3><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_start() static int __c_break_point;switch(__c_break_point)default:&#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_end() &#125; return 0;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_yield() do&#123;__c_break_point=__LINE__;return 1;case __LINE__:;&#125;while(0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_yield_val(val) do &#123; *c_yval = (val); c_yield(); &#125; while (0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> c_call(c_func, ...) do \</span>&#123; \    <span class="hljs-keyword">case</span> __LINE__: <span class="hljs-keyword">if</span> (c_func(__VA_ARGS__)) &#123; \        __c_break_point = __LINE__; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; \    &#125; \&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">c_level_3</span><span class="hljs-params">()</span> </span>&#123;    c_start();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l3: c_yield()\n&quot;</span>); c_yield();    c_end();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">c_level_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *c_yval)</span> </span>&#123;    c_start();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l2: c_yield_val(201)\n&quot;</span>); c_yield_val(<span class="hljs-number">201</span>);    c_call(c_level_3);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l2: c_yield_val(202)\n&quot;</span>); c_yield_val(<span class="hljs-number">202</span>);    c_end();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">c_level_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *c_yval)</span> </span>&#123;    c_start();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l1: c_yield_val(101)\n&quot;</span>); c_yield_val(<span class="hljs-number">101</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l1: c_yield()\n&quot;</span>); c_yield();    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;    <span class="hljs-keyword">while</span>(--i) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;l1: c_yield_val(i*4+100), i=%d\n&quot;</span>, i); c_yield_val(i*<span class="hljs-number">4</span>+<span class="hljs-number">100</span>);    &#125;    c_call(c_level_2, c_yval);    c_end();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;    <span class="hljs-keyword">while</span> (c_level_1(&amp;argc))        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yield: %d\n&quot;</span>, argc);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出：<br><pre><code class="hljs yaml"><span class="hljs-attr">l1:</span> <span class="hljs-string">c_yield_val(101)</span><span class="hljs-attr">yield:</span> <span class="hljs-number">101</span><span class="hljs-attr">l1:</span> <span class="hljs-string">c_yield()</span><span class="hljs-attr">yield:</span> <span class="hljs-number">101</span><span class="hljs-attr">l1:</span> <span class="hljs-string">c_yield_val(i*4+100),</span> <span class="hljs-string">i=2</span><span class="hljs-attr">yield:</span> <span class="hljs-number">108</span><span class="hljs-attr">l1:</span> <span class="hljs-string">c_yield_val(i*4+100),</span> <span class="hljs-string">i=1</span><span class="hljs-attr">yield:</span> <span class="hljs-number">104</span><span class="hljs-attr">l2:</span> <span class="hljs-string">c_yield_val(201)</span><span class="hljs-attr">yield:</span> <span class="hljs-number">201</span><span class="hljs-attr">l3:</span> <span class="hljs-string">c_yield()</span><span class="hljs-attr">yield:</span> <span class="hljs-number">201</span><span class="hljs-attr">l2:</span> <span class="hljs-string">c_yield_val(202)</span><span class="hljs-attr">yield:</span> <span class="hljs-number">202</span></code></pre></p>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>E1 一种灵活的内存块数据结构设计</title>
    <link href="/2021/01/13/%E4%B8%80%E7%A7%8D%E7%81%B5%E6%B4%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/01/13/%E4%B8%80%E7%A7%8D%E7%81%B5%E6%B4%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一种灵活的内存块数据结构设计"><a href="#一种灵活的内存块数据结构设计" class="headerlink" title="一种灵活的内存块数据结构设计"></a>一种灵活的内存块数据结构设计</h2><p>初衷：在dts.net中提供一个数据块结构，用于在网络各层模块中传递数据的同时，尽可能的将动态内存分配推迟到用户层。</p><p>完整代码及其实现见<a href="https://github.com/Doerthous/dts.net">dts.net.dblk</a>。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Node：节点<br>Block：逻辑数据块</p><h3 id="1-UDP到IP时的数据变化"><a href="#1-UDP到IP时的数据变化" class="headerlink" title="1 UDP到IP时的数据变化"></a>1 UDP到IP时的数据变化</h3><p>假设UDP数据为A，到IP层后，IP层需要在上层的数据的头部新增一个IP头部B，其结构形如链表：B-&gt;A。</p><p>故此，我们设计一个如下链表进行处理：</p><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">uint8_t</span> *data; <span class="hljs-comment">// 实际数据</span>    <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>; <span class="hljs-comment">// data大小</span>&#125; <span class="hljs-keyword">dblk_t</span>;<span class="hljs-keyword">dblk_t</span> *udp;<span class="hljs-keyword">dblk_t</span> *ip = ip_pack(udp) &#123; <span class="hljs-comment">// IP模块组包接口</span>    dblk *ip_header;    <span class="hljs-comment">// ...</span>    ip_header-&gt;next = udp;    <span class="hljs-keyword">return</span> ip_header; &#125;</code></pre><h3 id="2-链表数据管理"><a href="#2-链表数据管理" class="headerlink" title="2 链表数据管理"></a>2 链表数据管理</h3><p>按照1中的分析，假设当前有一个三层网络，每层都会添加头部，那么，加上原始载荷，有：</p><p>C-&gt;B-&gt;A-&gt;P。</p><p>其中P表示原始载荷，A表示最高层协议，B表示中间层协议，C表示最底层协议。随着层次逐渐降低，链表中的节点逐渐增加。</p><pre><code class="hljs clean"><span class="hljs-number">0</span>层          PA层          A-&gt;PB层          B-&gt;A-&gt;PC层          C-&gt;B-&gt;A-&gt;P</code></pre><p>如此，可遍历C、B、A、P节点中的数据完成一个完整协议栈数据的发送或解析操作。</p><pre><code class="hljs arduino"><span class="hljs-comment">// 将dblk数据拷贝到指定内存</span><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">dblk_copy_to</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> *dblk, <span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;    <span class="hljs-keyword">size_t</span> do_size;    <span class="hljs-keyword">size_t</span> done_size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (dblk) &#123;        do_size = <span class="hljs-built_in">size</span> &lt; dblk-&gt;<span class="hljs-built_in">size</span> ? <span class="hljs-built_in">size</span> : dblk-&gt;<span class="hljs-built_in">size</span>;        <span class="hljs-built_in">memcpy</span>(mem, dblk-&gt;data, do_size);        done_size += do_size;        mem += do_size;        <span class="hljs-keyword">if</span> (done_size == <span class="hljs-built_in">size</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        dblk = dblk-&gt;next;    &#125;    <span class="hljs-keyword">return</span> done_size;&#125;send(dblk) &#123;    <span class="hljs-keyword">uint8_t</span> buff[SOME_SIZE];    <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span> = dblk_copy_to(dblk, buff, SOME_SIZE);    low_level_send(buff, <span class="hljs-built_in">size</span>);&#125;</code></pre><h3 id="3-2-中存在的问题"><a href="#3-2-中存在的问题" class="headerlink" title="3 [2]中存在的问题"></a>3 [2]中存在的问题</h3><p>考虑到底层可能由于硬件原因，无法及时发送数据，导致多个完整协议栈数据被缓存。为管理这些数据，可添加用于表示后续节点是否属于当前<strong>逻辑数据块</strong>的more标志，区分不同的逻辑数据块，具体解释如下图：</p><pre><code class="hljs apache"><span class="hljs-attribute">C1</span> -&gt; B<span class="hljs-number">1</span> -&gt; A<span class="hljs-number">1</span> -&gt; P<span class="hljs-number">1</span> -&gt; C<span class="hljs-number">2</span> -&gt; B<span class="hljs-number">2</span> -&gt; A<span class="hljs-number">2</span> -&gt; P<span class="hljs-number">2</span> -&gt; ...<span class="hljs-attribute">m</span>:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">0</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">0</span>   ...</code></pre><p>上述链表虽有8个节点（C1 ~ P2），但是只有两个逻辑数据块，其中（C1 ~ P1）是一个，（C2 ~ P2）是另一个（m：more）。在处理一个节点的数据时，需要判断more标志，如果more标志为1则表示后续节点仍属于当前逻辑数据块，否者则表示当前节点为当前逻辑数据块的最后一个节点。类似IP报文中的More Fragment标志。</p><p>如此，在处理时可按照逻辑数据块进行区分：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">dblk_copy_to</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> *dblk, <span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;    <span class="hljs-keyword">size_t</span> do_size;    <span class="hljs-keyword">size_t</span> done_size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (dblk) &#123;        do_size = <span class="hljs-built_in">size</span> &lt; dblk-&gt;<span class="hljs-built_in">size</span> ? <span class="hljs-built_in">size</span> : dblk-&gt;<span class="hljs-built_in">size</span>;        <span class="hljs-built_in">memcpy</span>(mem, dblk-&gt;data, do_size);        done_size += do_size;        mem += do_size;        <span class="hljs-keyword">if</span> (done_size == <span class="hljs-built_in">size</span> || !dblk-&gt;more) &#123; <span class="hljs-comment">// 按逻辑数据块进行处理</span>            <span class="hljs-keyword">break</span>;        &#125;        dblk = dblk-&gt;next;    &#125;    <span class="hljs-keyword">return</span> done_size;&#125;</code></pre><p>除上述方法外，也可引入另一个指针来连接不同的逻辑数据块。</p><pre><code class="hljs coq">C1 -&gt; B1 -&gt; A1 -&gt; P1 |<span class="hljs-type"></span><span class="hljs-type"> v</span>C2 -&gt; B2 -&gt; A2 -&gt; P2</code></pre><h3 id="4-分片及内存对齐问题"><a href="#4-分片及内存对齐问题" class="headerlink" title="4 分片及内存对齐问题"></a>4 分片及内存对齐问题</h3><p>假设某个双层应用层协议需通过UDP传输，最终形成如下内存：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">U</span>  <span class="hljs-literal">-</span>&gt;  <span class="hljs-comment">L1</span>    <span class="hljs-literal">-</span>&gt;    <span class="hljs-comment">L2</span><span class="hljs-comment">\</span>       <span class="hljs-comment">\</span>           <span class="hljs-comment">\</span><span class="hljs-comment"></span><span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span><span class="hljs-comment">|</span>  <span class="hljs-comment">U</span>  <span class="hljs-comment">|</span>   <span class="hljs-comment">|</span>  <span class="hljs-comment">L1</span>  <span class="hljs-comment">|</span>   <span class="hljs-comment">|</span>  <span class="hljs-comment">L2</span>  <span class="hljs-comment">|</span><span class="hljs-comment"></span><span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span></code></pre><p>在逻辑上，我们可以将上述内存想象成一大块连续分配的虚拟内存：</p><pre><code class="hljs asciidoc"><span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span></code></pre><p>到IP层时，由于逻辑数据块长度太大，IP模块需要进行分片，为了最大化节省空间，我们可让IP层节点指向上述虚拟内存。例如，假设经计算上述内存需被分为4个IP分片报文：</p><pre><code class="hljs asciidoc">F1   F2   F3   F4|    |    |    |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>IP1 -&gt; F1IP2 -&gt; F2IP3 -&gt; F3IP4 -&gt; F4</code></pre><p>每个IPx节点的内存中包含了IP Header的数据，而Fx节点包含了传给IP层的上层数据分片。按照上述虚拟的连续内存思路，我们可以实现利用<strong>原数据</strong>而<strong>无需重新拷贝</strong>而得到分片的操作。然而，由于IP层在分片时对载荷有对齐要求（8B对齐），如果U、L1、L2内存本身没有满足8B对齐，那么就会出现上图中类似F2与F3的情况：一个dblk节点的所代表的内存块在实际物理内存上并不连续！</p><p>为此，我们引入一个vsize和类型为dblk_t *的vmem指针，用vsize表示当前节点虚拟内存的大小，当当前节点的data的大小无法满足vsize时，我们继续从vmem中取内存，直到其大小为vsize为止。</p><p>在保持原有链表不动的情况下，假设U、L1、L2的data指针分别为u、l1、l2，大小分别为us、l1s、l2s，如下所示，</p><pre><code class="hljs apache"><span class="hljs-attribute">U</span>  -&gt;  L<span class="hljs-number">1</span>  -&gt;  L<span class="hljs-number">2</span><span class="hljs-attribute">d</span>:u    d:l<span class="hljs-number">1</span>    d:l<span class="hljs-number">2</span><span class="hljs-attribute">s</span>:us   s:l<span class="hljs-number">1</span>s   s:l<span class="hljs-number">2</span>s</code></pre><p>再设分片后，每个分片报文大小为x，则，F1 ~ F4的data指针及其内容如下：</p><pre><code class="hljs sas">F1   -&gt;   F2   -&gt;   F3  -&gt;                 F4d:u       d:u+<span class="hljs-meta">x</span>     d:l1+(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))        d:l2+(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))s:us      s:us-<span class="hljs-meta">x</span>    s:l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))       s:l2s-(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))vs:<span class="hljs-meta">x</span>      vs:<span class="hljs-meta">x</span>      vs:<span class="hljs-meta">x</span>                   vs:l2s-(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))vm:<span class="hljs-meta">NULL</span>   vm:L1     vm:L2                  vm:<span class="hljs-meta">NULL</span></code></pre><p>推导：</p><ol><li><p>F1节点，d指向u；s为d的大小us；vs=x；由于us&gt;x，故F1无需再取内存，故vm为NULL。</p></li><li><p>F2节点，由于F1没能占完u，故F2的d指向u加上F1占用u后剩下的内存，F1占了x，所以F2的d指向u+x；s为d的大小(us-x)；vs=x；从图中可看出，仅仅u无法满足F2的vs大小，F2后续还占用了l1，故vm=L1。</p></li><li><p>F3，F4思路类似。</p></li></ol><p>需要注意的是F4作为尾节点，可能没有vmem使用，故其vs可能不一定等于x。此外一个vmem-节点可能占用原来链表的多个节点内存，如下图，Fa占用了三块原节点内存。</p><pre><code class="hljs asciidoc">Fa             Fb|              |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span></code></pre><p>在此过程中，size字段的含义不变，仍旧表示data的大小。只是当未启用vmem时，节点的内存大小正好等于data的大小。而vmem启用时，节点的内存大小未必等于data的大小。按照上述思路，可以设计一个如下接口，实现将dblk内存分割成按任意字节对齐的片段。需要注意，此处的dblk参数必须是未启用vmem模式的节点。</p><p><code>dblk_t *dblk_fragments(dblk_t *dblk, size_t frag_size);</code></p><p>至此，当上层数据超长需要分片时，仅需调用<code>dblk_fragments</code>进行处理即可。可以引入一个将vmem节点还原回正常节点的操作，如此便可无限制地使用分片接口。</p><h3 id="5-类文件的随机访问接口"><a href="#5-类文件的随机访问接口" class="headerlink" title="5 类文件的随机访问接口"></a>5 类文件的随机访问接口</h3><p>read、write、seek</p><h3 id="6-接口"><a href="#6-接口" class="headerlink" title="6 接口"></a>6 接口</h3><h4 id="Node结构及接口"><a href="#Node结构及接口" class="headerlink" title="Node结构及接口"></a>Node结构及接口</h4><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">uint8_t</span> *data;    <span class="hljs-keyword">uint16_t</span> <span class="hljs-built_in">size</span>;    <span class="hljs-keyword">uint16_t</span> data_malloc:<span class="hljs-number">1</span>; <span class="hljs-comment">// 指示data字段是否来自malloc</span>    <span class="hljs-keyword">uint16_t</span> node_malloc:<span class="hljs-number">1</span>; <span class="hljs-comment">// 指示此Node是否来自malloc。</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @brief 指示后续Node与当前Node同属一个Block。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *  假设有如下dblk链表:</span><span class="hljs-comment">     *   Nodes:</span><span class="hljs-comment">     *   n1    -&gt;    n2    -&gt;   n3    -&gt;    n4    -&gt;    n5    -&gt;  n6</span><span class="hljs-comment">     *   more:1      more:1     more:0      more:1      more:1    more:0</span><span class="hljs-comment">     *   -----------------------------      ----------------------------</span><span class="hljs-comment">     *   Block1                             Block2</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">uint16_t</span> more:<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @brief vmem模式.</span><span class="hljs-comment">     * </span><span class="hljs-comment">     *  当vsize != 0的Node属于vmem-Node，反之为rmem-Node。vsize表示当前vmem-Node所</span><span class="hljs-comment">     *  带内存大小，而size表示data的大小。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">uint16_t</span> vsize;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">vmem</span>;</span>&#125; <span class="hljs-keyword">dblk_t</span>;</code></pre><pre><code class="hljs reasonml"><span class="hljs-comment">// 将两个Node按序纳入同一个Block</span>void dblk<span class="hljs-constructor">_node_concat(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk1</span>, <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk2</span>)</span>;<span class="hljs-comment">// 初始化Node参数</span>dblk_t *dblk<span class="hljs-constructor">_node_init(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 分配一个Node并设置其内存</span>dblk_t *dblk<span class="hljs-constructor">_node_new(<span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 从栈上分配一个Node并设置其内存</span>void dblk<span class="hljs-constructor">_node_new_from_stack(<span class="hljs-operator">**</span><span class="hljs-params">ppdblk</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 分配一个Node及其内存</span>dblk_t *dblk<span class="hljs-constructor">_node_new_with_buff(<span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;...</code></pre><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><pre><code class="hljs cpp"><span class="hljs-comment">// 释放所有Node</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dblk_list_delete</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> * dblk)</span></span>;...</code></pre><h4 id="Block接口"><a href="#Block接口" class="headerlink" title="Block接口"></a>Block接口</h4><pre><code class="hljs reasonml"><span class="hljs-comment">// 删除第一个Block，并返回后一个块</span>dblk_t *dblk<span class="hljs-constructor">_delete(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 获取第一个Block大小</span>size_t dblk<span class="hljs-constructor">_size(<span class="hljs-params">const</span> <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 获取下一个Block</span>dblk_t *dblk<span class="hljs-constructor">_next(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 将第一个Block的数据拷贝到指定内存，并返回拷贝数量</span>size_t dblk<span class="hljs-constructor">_copy_to(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">mem</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 将指定内存中的数据拷贝到第一个Block，并返回拷贝数量</span><span class="hljs-comment">// 不支持 vmem Node</span>size_t dblk<span class="hljs-constructor">_copy_from(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">mem</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 将第一个逻辑数据块按照给定大小分割，分割后，每个片段独立成Block</span><span class="hljs-comment">// 不支持 vmem Node</span>dblk_t *dblk<span class="hljs-constructor">_fragment(<span class="hljs-params">const</span> <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">fsize</span>)</span>;...</code></pre><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h3><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">dblk_t</span> *b1 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    <span class="hljs-keyword">dblk_t</span> *b2 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    <span class="hljs-keyword">dblk_t</span> *b3 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    dblk_node_concat(b1, b2);    dblk_node_concat(b2, b3);    <span class="hljs-keyword">dblk_t</span> *it = b1;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; it-&gt;size; ++i) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, it-&gt;data[i]);        &#125;        it = dblk_node_next(it);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    dblk_copy_from(b1, <span class="hljs-string">&quot;123456789098765432101234567890123456&quot;</span>, <span class="hljs-number">36</span>);    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">36</span>];    &#123;        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(b1, buff, <span class="hljs-number">36</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">dblk_t</span> *fragments = dblk_fragment(b1, <span class="hljs-number">7</span>);    it = fragments;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        it = dblk_next(it);    &#125;    <span class="hljs-keyword">if</span> (dblk_list_to_rmem_list(fragments)) &#123;        it = fragments;        <span class="hljs-keyword">while</span> (it) &#123;            <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);            <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);            it = dblk_next(it);        &#125;    &#125;    dblk_list_delete(fragments);    fragments = dblk_fragment(b1, <span class="hljs-number">5</span>);    it = fragments;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        it = dblk_next(it);    &#125;    dblk_list_delete(fragments);    dblk_list_delete(b1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;输出：CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span>vn: <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span>vn: <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span>vn: <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span>vn: <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> n: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> n: <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> n: <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> n: <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> n: <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> n: <span class="hljs-number">36</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>数据结构</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5 UDP协议</title>
    <link href="/2021/01/13/UDP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/13/UDP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP基于IP协议，为上层提供一个协议机制最少的通信协议。</p><h3 id="1-UDP报文格式"><a href="#1-UDP报文格式" class="headerlink" title="1 UDP报文格式"></a>1 UDP报文格式</h3><pre><code class="hljs asciidoc"><span class="hljs-code"> 0      7 8     15 16    23 24    31</span><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|     Source      |   Destination   ||      Port       |      Port       |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|     Length      |    Checksum     |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|               Data                ||                ...                |<span class="hljs-code">+-----------------------------------+</span>字段             大小       说明<span class="hljs-bullet">----             </span>----      ----Source Port      2B        源端口。Destination Port 2B        目标端口。Length           2B        长度（从Source Port到Data结束）。Checksum         2B        校验和（包括伪头部及UDP完整报文）。Data             n         数据。</code></pre><h3 id="2-伪头部"><a href="#2-伪头部" class="headerlink" title="2 伪头部"></a>2 伪头部</h3><p>在网络数据传递中，伪头部并不存在，其仅为了计算校验和而产生。</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0      7 8     15 16    23 24    31</span><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|              source               |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|            destination            |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|  zero  |protocol|   UDP length    |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+字段         大小       说明<span class="hljs-bullet">----         </span>----      ----source       4B        IP源地址destination  4B        IP目的地址zero         1B        0。protocol     1B        IP报文头部的protocol字段。UDP length   n         UDP报文长度（从Source Port到Data结束，其值和UDP报文中的<span class="hljs-code">                       length相等）。</span></code></pre><h3 id="3-实现考虑"><a href="#3-实现考虑" class="headerlink" title="3 实现考虑"></a>3 实现考虑</h3><h4 id="检验和计算"><a href="#检验和计算" class="headerlink" title="检验和计算"></a>检验和计算</h4><ul><li>伪头部模块</li></ul><h4 id="提供给高层的接口"><a href="#提供给高层的接口" class="headerlink" title="提供给高层的接口"></a>提供给高层的接口</h4><ul><li><p>创建新的接收端口。</p></li><li><p>接收操作，接收报文后向高层传递UDP Data、Source Port、Source Address（IP）。</p><p>  <code>udp_recv_callback(data, size, src_ip, src_port)</code></p></li><li><p>发送操作，允许高层指定数据、源及目的的端口和IP地址。</p><p>  <code>udp_send(ip_src, src_port, ip_dest, dest_port, data, size)</code></p></li></ul><h4 id="对IP层的依赖"><a href="#对IP层的依赖" class="headerlink" title="对IP层的依赖"></a>对IP层的依赖</h4><ul><li><p>UDP要求IP模块提供至少能够确定IP头部中的source address、destination address以及protocol字段的接口。</p><p>  <code>udp_recv_from_ip(data, size, ip_src, ip_dest, ip_protocol)</code></p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://tools.ietf.org/html/rfc768">User Datagram Protocol</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2 Ethernet帧及其软件模块实现</title>
    <link href="/2021/01/12/Ethernet%E5%B8%A7%E5%8F%8A%E5%85%B6%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/01/12/Ethernet%E5%B8%A7%E5%8F%8A%E5%85%B6%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Ethernet帧及其软件模块实现"><a href="#Ethernet帧及其软件模块实现" class="headerlink" title="Ethernet帧及其软件模块实现"></a>Ethernet帧及其软件模块实现</h2><h3 id="1-Ethernet帧"><a href="#1-Ethernet帧" class="headerlink" title="1 Ethernet帧"></a>1 Ethernet帧</h3><pre><code class="hljs asciidoc"><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                       target address (6)                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                       source address (6)                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                         type/length (2)                       |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                           payload (n)                         | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            crc (4)                            | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             字节数     说明<span class="hljs-bullet">----             </span>----      ----target address   6         目标地址。source address   6         源地址。type/length      2         类型/长度。payload          n         载荷。crc              4         校验。</code></pre><p>一般和IEEE 802.3标准相兼容的帧的长度在64和1518（0x5EE）个字节之间。当type/length的值超过最大长度时，该字段含义为type（例如0x800表示IP协议），反之为length。另外，当有效载荷小于46（46+6+6+2+4）个字节时需对载荷进行填充，使帧达到最小长度。</p><h3 id="2-实现考虑"><a href="#2-实现考虑" class="headerlink" title="2 实现考虑"></a>2 实现考虑</h3><p>Ether模块功能：</p><ul><li><p>提供接口给上下层</p>  <pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |   high level   |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">  |</span><span class="hljs-comment">  v ether_hl_send</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |     ether      |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">  ^ ether_ll_recv</span><span class="hljs-comment">  | </span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |   low level    |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 底层调用此函数通知Ether模块接收帧数据</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_ll_recv</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;<span class="hljs-comment">// 高层调用此函数发送帧数据</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_hl_send</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;</code></pre></li><li><p>拆帧组帧</p>  <pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">uint8_t</span> *dest_mac_addr;    <span class="hljs-keyword">uint8_t</span> *src_mac_addr;    <span class="hljs-keyword">dblk_t</span> *payload;    <span class="hljs-keyword">uint16_t</span> type;    <span class="hljs-keyword">uint32_t</span> crc;    <span class="hljs-comment">//</span>    <span class="hljs-keyword">uint8_t</span> *data;    <span class="hljs-keyword">size_t</span> data_size;&#125; <span class="hljs-keyword">ether_frame_t</span>;<span class="hljs-comment">// 拆帧</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_unpack</span><span class="hljs-params">(<span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;<span class="hljs-comment">// 组帧</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_pack</span><span class="hljs-params">(<span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;</code></pre></li><li><p>硬件抽象</p>  <pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">// 驱动抽象</span>    <span class="hljs-keyword">size_t</span> (*send)(<span class="hljs-keyword">void</span> *interface, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size);    <span class="hljs-keyword">size_t</span> (*recv)(<span class="hljs-keyword">void</span> *interface, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size);    <span class="hljs-keyword">void</span> *interface;    <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">ether_t</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_hl_send</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span> </span>&#123;    frame-&gt;src_mac_addr = ether-&gt;mac_address,    ether_pack(frame); <span class="hljs-comment">// 组帧</span>    <span class="hljs-keyword">return</span> ether-&gt;send(ether-&gt;interface, frame-&gt;data, frame-&gt;data_size); <span class="hljs-comment">// 发送</span>&#125;</code></pre></li><li><p>帧分发</p><p>  ether收到数据且拆包正常后，根据type/length字段将载荷分发到高层模块。</p>  <pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_ll_recv</span><span class="hljs-params">(<span class="hljs-keyword">ehter_t</span> *e, <span class="hljs-keyword">ether_frame_t</span> *f)</span> </span>&#123;    f-&gt;data_size = e-&gt;recv(e-&gt;interface, f-&gt;data, f-&gt;data_size); <span class="hljs-comment">// 接收</span>    <span class="hljs-keyword">if</span> (f-&gt;data_size &gt; <span class="hljs-number">0</span> &amp;&amp; ether_unpack(f)) &#123; <span class="hljs-comment">// 拆帧</span>        <span class="hljs-keyword">switch</span> (f-&gt;type) &#123;            <span class="hljs-keyword">case</span> HIGH_LEVEL_1_TYPE: &#123;                <span class="hljs-comment">//...</span>                hl1_ll_recv(frame-&gt;payload)            &#125; <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//...</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><p>此代码见<a href="https://github.com/Doerthous/dts.net">dts.net</a>中的<code>ether</code>模块。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://tools.ietf.org/html/rfc894">A Standard for the Transmission of IP Datagrams over Ethernet Networks</a></p></li><li><p><a href="http://decnet.ipv7.net/docs/dundas/aa-k759a-tk.pdf">The Ethernet - A Local Area Network, Version 1.0, Digital Equipment Corporation, Intel Corporation, Xerox Corporation, September 1980</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>Ethernet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7 BOOTP协议</title>
    <link href="/2021/01/12/BOOTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/12/BOOTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="BOOTP协议"><a href="#BOOTP协议" class="headerlink" title="BOOTP协议"></a>BOOTP协议</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1 目的"></a>1 目的</h3><p>为无盘系统<strong>确定IP地址</strong>及<strong>服务器地址</strong>及<strong>镜像文件位置</strong>，使得系统可以自举。</p><h3 id="2-两个阶段"><a href="#2-两个阶段" class="headerlink" title="2 两个阶段"></a>2 两个阶段</h3><ol><li><p>IP地址确定及镜像文件定位（RFC951主要内容）。</p></li><li><p>文件传输（通常为TFTP协议）。</p></li></ol><h4 id="阶段一交互逻辑"><a href="#阶段一交互逻辑" class="headerlink" title="阶段一交互逻辑"></a>阶段一交互逻辑</h4><p>客户端请求，服务端响应（响应数据可能含<strong>分配给客户端的IP地址</strong>及<strong>BOOT文件位置</strong>）。</p><h3 id="3-包格式"><a href="#3-包格式" class="headerlink" title="3 包格式"></a>3 包格式</h3><pre><code class="hljs txt"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |+---------------+---------------+---------------+---------------+|                            xid (4)                            |+-------------------------------+-------------------------------+|           secs (2)            |           reserved (2)        |+-------------------------------+-------------------------------+|                          ciaddr  (4)                          |+---------------------------------------------------------------+|                          yiaddr  (4)                          |+---------------------------------------------------------------+|                          siaddr  (4)                          |+---------------------------------------------------------------+|                          giaddr  (4)                          |+---------------------------------------------------------------+|                          chaddr  (16)                         |+---------------------------------------------------------------+|                          sname   (64)                         |+---------------------------------------------------------------+|                          file    (128)                        |+---------------------------------------------------------------+|                          vend    (64)                         |+---------------------------------------------------------------+字段      字节数     说明----      ----      ----op        1         包类型标志（1=BOOTREQUEST，2=BOOTREPLY）。htype     1         同ARP协议，见RFC826。hlen      1         同ARP协议。hops      1         网关可选使用该字段（客户端填0）。xid       4         会话ID，随机数，客户端产生，用于匹配REQUEST及REPLY。secs      2         自客户端尝试BOOT起所消耗的时间（秒），由客户端填充。reserved  2         保留。ciaddr    4         客户端IP地址（如果客户端BOOT有IP则填充，否则填0）。yiaddr    4         服务端分配给客户端的IP地址（如ciaddr为0则填充该字段）。siaddr    4         服务端IP地址（REPLY中由服务端填充）。giaddr    4         网关IP地址（其他角色填0）。chaddr    16        客户端硬件地址（客户端填充）。sname     64        服务端主机名，可选，null-结尾字符串。file      128       BOOT文件名（null串，通用名，全路径）。vend      64        可选。</code></pre><h3 id="4-“鸡生蛋，蛋生鸡”问题"><a href="#4-“鸡生蛋，蛋生鸡”问题" class="headerlink" title="4 “鸡生蛋，蛋生鸡”问题"></a>4 “鸡生蛋，蛋生鸡”问题</h3><p>问题：客户端没有IP地址，其请求IP地址时，服务端如何回复到客户端？</p><p>思路：如果客户端知道自己的IP地址（ciaddr不为零），则按该地址回复给客户端。如果客户端不知道自己的IP地址，且服务器可以通过某种方式修改ARP表，则将yiaddr与chaddr写入ARP表，然后正常发送。如果都不行，则采用广播。</p><h3 id="5-实现考虑"><a href="#5-实现考虑" class="headerlink" title="5 实现考虑"></a>5 实现考虑</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>ARP实现（要能够响应ARP请求，告知自己的地址）。</p></li><li><p>时间及定时器（超时重传）。</p></li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li><p>BOOTP数据库</p><ul><li><p>BOOTP表（与ARP表作用相反）</p></li><li><p>BOOT文件路径映射表</p></li></ul></li></ul><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h3><ul><li><p>假定IP层不分片</p></li><li><p>为什么使用两个端口</p><p>  避免<strong>其他BOOTP服务端</strong>被<strong>选定的服务端</strong>广播给客户端的REPLY包唤醒。</p></li><li><p>siaddr的作用</p><p>  告知客户端去哪里取BOOT文件。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://tools.ietf.org/html/rfc951">BOOTSTRAP PROTOCOL (BOOTP), RFC951</a></p></li><li><p><a href="https://tools.ietf.org/html/rfc2131">Dynamic Host Configuration Protocol, RFC2131</a></p></li><li><p><a href="https://tools.ietf.org/html/rfc826">An Ethernet Address Resolution Protocol, RFC826</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>BOOTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8 DHCP协议</title>
    <link href="/2021/01/11/DHCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/11/DHCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>DHCP协议是BOOTP协议的扩展，在术语方面，BOOTP的Vend在DHCP协议中被定义为Option。</p><p>DHCP提供了两种service：1)配置参数仓库（客户端可以从服务端获取网络配置参数），2)网络地址分配。</p><h3 id="1-DHCP消息"><a href="#1-DHCP消息" class="headerlink" title="1 DHCP消息"></a>1 DHCP消息</h3><h4 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h4><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |<span class="hljs-code">+---------------+</span>---------------<span class="hljs-code">+---------------+</span>---------------+|                            xid (4)                            |<span class="hljs-code">+-------------------------------+</span>-------------------------------+|           secs (2)            |           flags (2)           |<span class="hljs-code">+-------------------------------+</span>-------------------------------+|                          ciaddr  (4)                          |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          yiaddr  (4)                          |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          siaddr  (4)                          |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          giaddr  (4)                          |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          chaddr  (16)                         |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          sname   (64)                         |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          file    (128)                        |<span class="hljs-code">+---------------------------------------------------------------+</span>|                          options (n)                          |<span class="hljs-code">+---------------------------------------------------------------+</span>字段      字节数     说明<span class="hljs-bullet">----      </span>----      ----op        1         包类型标志（1=BOOTREQUEST，2=BOOTREPLY）。htype     1         同ARP协议，见RFC826。hlen      1         同ARP协议。hops      1         网关可选使用该字段（客户端填0）。xid       4         会话ID，随机数，客户端产生，用于匹配REQUEST及REPLY。secs      2         自客户端尝试BOOT起所消耗的时间（秒），由客户端填充。flags     2                              1 1 1 1 1 1<span class="hljs-code">                     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><span class="hljs-code">                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="hljs-code">                    |B|             MBZ             |</span><span class="hljs-code">                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="hljs-code">                     B:  BROADCAST flag</span><span class="hljs-code">                     MBZ:  MUST BE ZERO (reserved for future use)</span>ciaddr    4         客户端IP地址（如果客户端BOOT有IP则填充，否则填0）。yiaddr    4         服务端分配给客户端的IP地址（如ciaddr为0则填充该字段）。siaddr    4         BOOT文件传输服务端IP地址（REPLY中由服务端填充）。giaddr    4         网关IP地址（其他角色填0）。chaddr    16        客户端硬件地址（客户端填充）。sname     64        服务端主机名，可选，null-结尾字符串。file      128       BOOT文件名（null串，通用名，全路径）。options   n         DHCP选项。</code></pre><p><strong>关于siaddr与server identifier</strong></p><p>按照BOOTP协议的描述，无盘系统自举有两个阶段，一个是获取地址，另一个是获取BOOT文件。一个无盘系统可能从一个服务器获取到其自身的IP地址，然后从另一个服务器获取BOOT文件。在DHCP协议中，siaddr指存放了BOOT文件的服务器地址，这个服务器不一定是DHCP服务器。所以DHCP服务端可能会将自己的地址写入siaddr，如果该DHCP服务端能够提供BOOTP协议中定义的文件传输功能。而DHCP中定义的server identifier选项中指示的地址总是DHCP服务端的地址。</p><p>因此，如在不使用BOOTP的BOOT文件的情况下，尽量使用<code>server identifier</code>。</p><p><strong>Options</strong></p><p>DHCP的Option为变长字段，以magic cookie：99, 130, 83, 99（十进制）开头，以255结尾。Option格式有定长及变长两种（括号中的数字标识Otect的个数）：</p><pre><code class="hljs isbl">定长：<span class="hljs-function"><span class="hljs-title">CODE</span>(<span class="hljs-number">1</span>)</span>变长：<span class="hljs-function"><span class="hljs-title">CODE</span>(<span class="hljs-number">1</span>) <span class="hljs-title">LEN</span>(<span class="hljs-number">1</span>) <span class="hljs-title">DATA</span>(<span class="hljs-variable">LEN</span>)</span></code></pre><p>其中，变长格式中的LEN字段不包含CODE和LEN本身。</p><p>DHCP的定长Option仅有两个，一个是用于填充的PAD选项，其CODE值为0，另一个用于标识Option结尾的END选项，其CODE值为255。</p><p>举例：一个空的Option</p><pre><code class="hljs jboss-cli">Otect:      0    1    2    3    4          +<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+Value:    | 99 |130 | 83 | 99 |255 |          +<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+Meaning:  |    Magic cookie   |END |          +<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+</code></pre><p>动态网络地址分配中涉及到的常见Option主要有：</p><ol><li>DHCP Message Type</li><li>Server Identifier</li><li>Requested IP Address</li><li>Subnet Mask</li><li>IP Lease Time</li></ol><h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>每个DHCP消息中必须包含一个特殊的Option：DHCP Message Type，此Option标识了DHCP消息的类型。</p><p>DHCP中定义了如下的消息类型：</p><ul><li>DISCOVER：客户端广播，探测DHCP服务端</li><li>OFFER：服务端响应DISCOVER（带有分配的地址及网络配置参数）。</li><li>REQUEST：客户端广播，向服务器请求网络地址或参数。</li><li>ACK：服务端发出，带有网络配置参数。</li><li>NAK：服务端发出，暗示客户端网络地址错误或租期过期。</li><li>DECLINE：客户端发出，告知服务端，其分配的地址已被占用。</li><li>RELEASE：客户端发出，表示放弃已分配的地址，取消租用。</li><li>INFORM：客户端发出，向服务端请求网络配置参数。</li></ul><h3 id="2-交互过程"><a href="#2-交互过程" class="headerlink" title="2 交互过程"></a>2 交互过程</h3><p>DHCP使用UDP的67及68端口进行交互：</p><pre><code class="hljs routeros">DHCP<span class="hljs-built_in"> client </span>    DHCP server     | ---udp(67)--&gt; | BOOTREQUEST     | &lt;--udp(68)--- | BOOTREPLY</code></pre><h4 id="动态地址分配"><a href="#动态地址分配" class="headerlink" title="动态地址分配"></a>动态地址分配</h4><ol><li><p>客户端广播discover，并等待offer，期间可能有多个server提供offer，客户端根据offer中的网络参数自行选择一个server。</p></li><li><p>服务端回复offer，offer中yiaddr为服务端分配的IP，有标识服务端IP地址的server identifier，以及其他网络参数。</p></li><li><p>客户端广播request，必须含server identifier选项以指定某个server，requested ip address必须和server发送的offer中的yiaddr相同。如果超时且未收到offer，则客户端重发discover。</p></li><li><p>服务端存储binding并回复ack。如果不能满足客户端，则回复nak。如果分配成功，服务端可以把已分配的地址标记为不可用。如果没有收到客服端的request，服务端应该将分配的地址标记为可用。</p></li><li><p>如果客户端发现分配的地址已经被占用（通过arp协议），则发送decline给服务端，并等待至少10s，然后重启配置流程。如果客户端收到nak，则重启配置流程。如果客户端既没收到ack，也没收到nak，则按照rfc中提到的算法，重发request。如果客户端重传失败，则进入init状态，并重启初始化流程。</p></li><li><p>客户端可以发送release释放已分配的地址。</p></li></ol><pre><code class="hljs gherkin">     Server          Client          Server(未选中的server)                    (选中的server)        v               v               v        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">           开始初始化           </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string"> _____________/</span>|<span class="hljs-string">\____________  </span>|        |<span class="hljs-string">/DHCPDISCOVER  </span>|<span class="hljs-string"> DHCPDISCOVER \</span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|    确定配置参数         |<span class="hljs-string">           确定配置参数</span><span class="hljs-string">        </span>|<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">\              </span>|<span class="hljs-string">  ____________/</span>|        |<span class="hljs-string"> \________     </span>|<span class="hljs-string"> /DHCPOFFER    </span>|        |<span class="hljs-string"> DHCPOFFER\    </span>|<span class="hljs-string">/              </span>|        |<span class="hljs-string">           \   </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">            收集offer          </span>|        |<span class="hljs-string">             \ </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">            选择offer          </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string"> _____________/</span>|<span class="hljs-string">\____________  </span>|        |<span class="hljs-string">/ DHCPREQUEST  </span>|<span class="hljs-string">  DHCPREQUEST\ </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">            提交配置</span><span class="hljs-string">        </span>|<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string"> _____________/</span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">/ DHCPACK      </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">           初始化完成           </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        .               .               .        .               .               .        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">            正常结束            </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">\ ____________ </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string"> DHCPRELEASE  \</span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        |<span class="hljs-string">               </span>|<span class="hljs-string">            取消租用</span><span class="hljs-string">        </span>|<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|        v               v               v</code></pre><h3 id="3-DHCP客户端状态"><a href="#3-DHCP客户端状态" class="headerlink" title="3 DHCP客户端状态"></a>3 DHCP客户端状态</h3><pre><code class="hljs gherkin"> --------                               -------|<span class="hljs-string">        </span>|<span class="hljs-string"> +--------------------------&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">&lt;-------------------+</span>|<span class="hljs-string"> INIT-  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">     +--------------------&gt;</span>|<span class="hljs-string"> INIT  </span>|<span class="hljs-string">                    </span>||<span class="hljs-string"> REBOOT </span>|<span class="hljs-string">DHCPNAK/         +----------&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">&lt;---+               </span>||<span class="hljs-string">        </span>|<span class="hljs-string">Restart</span>|<span class="hljs-string">         </span>|<span class="hljs-string">            -------     </span>|<span class="hljs-string">               </span>| --------  |<span class="hljs-string">  DHCPNAK/     </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                        </span>|    |<span class="hljs-string">      Discard offer   </span>|<span class="hljs-string">      -/Send DHCPDISCOVER               </span>|-/Send DHCPREQUEST         |<span class="hljs-string">               </span>|<span class="hljs-string">                        </span>|    |<span class="hljs-string">      </span>|<span class="hljs-string">     </span>|<span class="hljs-string">      DHCPACK            v        </span>|<span class="hljs-string">               </span>| -----------     |<span class="hljs-string">   (not accept.)/   -----------   </span>|<span class="hljs-string">               </span>||<span class="hljs-string">           </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  Send DHCPDECLINE </span>|<span class="hljs-string">           </span>|<span class="hljs-string">                  </span>||<span class="hljs-string"> REBOOTING </span>|<span class="hljs-string">    </span>|<span class="hljs-string">         </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> SELECTING </span>|<span class="hljs-string">&lt;----+            </span>||<span class="hljs-string">           </span>|<span class="hljs-string">    </span>|<span class="hljs-string">        /          </span>|<span class="hljs-string">           </span>|<span class="hljs-string">     </span>|<span class="hljs-string">DHCPOFFER/  </span>| -----------     |<span class="hljs-string">       /            -----------   </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Collect     </span>|    |<span class="hljs-string">            </span>|<span class="hljs-string">      /                  </span>|<span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  replies   </span>|DHCPACK/         |<span class="hljs-string">     /  +----------------+   +-------+            </span>|Record lease, set|<span class="hljs-string">    </span>|<span class="hljs-string">   v   Select offer/                         </span>|timers T1, T2   ------------  send DHCPREQUEST      |<span class="hljs-string">               </span>|    |<span class="hljs-string">   +-----&gt;</span>|<span class="hljs-string">            </span>|<span class="hljs-string">             DHCPNAK, Lease expired/   </span>|    |<span class="hljs-string">   </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> REQUESTING </span>|<span class="hljs-string">                  Halt network         </span>|    DHCPOFFER/ |<span class="hljs-string">            </span>|<span class="hljs-string">                       </span>|<span class="hljs-string">               </span>|    Discard     ------------                        |<span class="hljs-string">               </span>|    |<span class="hljs-string">   </span>|<span class="hljs-string">        </span>|<span class="hljs-string">        </span>|<span class="hljs-string">                   -----------           </span>|    |<span class="hljs-string">   +--------+     DHCPACK/              </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          </span>|    |<span class="hljs-string">              Record lease, set    -----</span>|<span class="hljs-string"> REBINDING </span>|<span class="hljs-string">          </span>|    |<span class="hljs-string">                timers T1, T2     /     </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          </span>|    |<span class="hljs-string">                     </span>|<span class="hljs-string">        DHCPACK/   -----------           </span>|    |<span class="hljs-string">                     v     Record lease, set   ^               </span>|    +----------------&gt; -------      /timers T1,T2   |<span class="hljs-string">               </span>|               +-----&gt;|<span class="hljs-string">       </span>|<span class="hljs-string">&lt;---+                </span>|<span class="hljs-string">               </span>|               |<span class="hljs-string">      </span>|<span class="hljs-string"> BOUND </span>|<span class="hljs-string">&lt;---+                </span>|<span class="hljs-string">               </span>|  DHCPOFFER, DHCPACK, |<span class="hljs-string">       </span>|<span class="hljs-string">    </span>|<span class="hljs-string">            T2 expires/   DHCPNAK/</span><span class="hljs-string">   DHCPNAK/Discard     -------     </span>|<span class="hljs-string">             Broadcast  Halt network</span><span class="hljs-string">               </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> </span>|<span class="hljs-string">         </span>|<span class="hljs-string">            DHCPREQUEST         </span>|               +-------+ |<span class="hljs-string">        DHCPACK/          </span>|<span class="hljs-string">               </span>|                    T1 expires/   Record lease, set |<span class="hljs-string">               </span>|                 Send DHCPREQUEST timers T1, T2     |<span class="hljs-string">               </span>|                 to leasing server |<span class="hljs-string">                </span>|<span class="hljs-string">               </span>|                         |<span class="hljs-string">   ----------             </span>|<span class="hljs-string">               </span>|                         |<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">------------+               </span>|                         +-&gt;|<span class="hljs-string"> RENEWING </span>|<span class="hljs-string">                            </span>|                            |<span class="hljs-string">          </span>|<span class="hljs-string">----------------------------+</span><span class="hljs-string">                             ----------</span></code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>DHCP客户端维护有两个定时器T1、T2。进入BOUND状态后，客户端启动定时器。T1、T2超时时间可由服务器通过DHCP的Option配置，T1默认值为<code>0.5*lease</code>，T2默认为<code>0.875*lease</code>（T1 &lt; T2 &lt; Lease）。T1超时后，客户端进入RENEWING状态，T2超时后客户端进入REBINDING状态，租期到期后，客户端进入INIT状态。</p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h3><p>一个Window上的DHCP服务器：<a href="http://www.dhcpserver.de/cms/download/">http://www.dhcpserver.de/cms/download/</a></p><h3 id="A-附录"><a href="#A-附录" class="headerlink" title="A 附录"></a>A 附录</h3><h4 id="部分Option定义"><a href="#部分Option定义" class="headerlink" title="部分Option定义"></a>部分Option定义</h4><p>本节列举DHCP动态网络地址分配中涉及到的常见的Option，完整Option定义参考[2]。</p><h5 id="Pad"><a href="#Pad" class="headerlink" title="Pad"></a>Pad</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code</span><span class="hljs-code">+-----+</span>|  0  |<span class="hljs-code">+-----+</span></code></pre><p>填充Option。</p><h5 id="End"><a href="#End" class="headerlink" title="End"></a>End</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code</span><span class="hljs-code">+-----+</span>| 255 |<span class="hljs-code">+-----+</span></code></pre><p>标识Option字段结尾的End选项。</p><h5 id="DHCP-Message-Type"><a href="#DHCP-Message-Type" class="headerlink" title="DHCP Message Type"></a>DHCP Message Type</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code   Len  Type</span><span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>|  53 |  1  | 1-7 |<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span></code></pre><p>此Option用于标识DHCP消息的类型，合法的值及其含义如下：</p><pre><code class="hljs routeros">Value   Message Type-----   ------------1       DHCPDISCOVER2       DHCPOFFER3       DHCPREQUEST4       DHCPDECLINE5       DHCPACK6       DHCPNAK7       DHCPRELEASE</code></pre><h5 id="Server-Identifier"><a href="#Server-Identifier" class="headerlink" title="Server Identifier"></a>Server Identifier</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code   Len            Address</span><span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+|  54 |  4  |  a1 |  a2 |  a3 |  a4 |<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+</code></pre><p>此Option用在DHCPOFFER和DHCPREQUEST消息中，DHCPACK及DHCPNAK可选携带。DHCP服务端通过在DHCPOFFER中携带该Option表明自己的IP地址，DHCP客户端通过在DHCPREQUEST中携带该Option表明自己选择哪一个DHCP服务端（由于DISCOVER是广播，所有客户端可能收到多个OFFER）。</p><p>该Option的Address总是DHCP服务端的IP地址。</p><h5 id="Requested-IP-Address"><a href="#Requested-IP-Address" class="headerlink" title="Requested IP Address"></a>Requested IP Address</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code   Len          Address</span><span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+|  50 |  4  |  a1 |  a2 |  a3 |  a4 |<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+</code></pre><p>此Option用在DISCOVER及REQUEST中，表示客户端要申请的IP。</p><h5 id="IP-Address-Lease-Time"><a href="#IP-Address-Lease-Time" class="headerlink" title="IP Address Lease Time"></a>IP Address Lease Time</h5><pre><code class="hljs asciidoc"><span class="hljs-code"> Code   Len         Lease Time</span><span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+|  51 |  4  |  t1 |  t2 |  t3 |  t4 |<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----<span class="hljs-code">+-----+</span>-----+</code></pre><p>此选项用在DHCPDISCOVER或DHCPREQUEST中，表示客户端想申请的租期时长。在OFFER中表示服务端给出的租期时长。单位秒，0xFFFFFFFF表示永久租期。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>[1] <a href="https://tools.ietf.org/html/rfc2131">Dynamic Host Configuration Protocol, RFC2131</a></p></li><li><p>[2] <a href="https://tools.ietf.org/html/rfc1533">DHCP Options and BOOTP Vendor Extensions, RFC1533</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>DHCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FatFS移植</title>
    <link href="/2021/01/10/FatFS%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/10/FatFS%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="FatFS移植"><a href="#FatFS移植" class="headerlink" title="FatFS移植"></a>FatFS移植</h2><p>此项目代码见<a href="https://github.com/Doerthous/dts.embedded">stm32f10x-mdk-none_fatfs</a>。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F103ZE </li><li>W25Q128</li></ul><p>软件：</p><ul><li>MDK 5.26.2.0</li><li>FatFS R0.14</li><li>STM32F10x StdPeriph Lib 3.5.0</li></ul><p>目录结构：</p><p>以下是移植过程中的项目目录结构。此处的目录结构非必须，可根据个人代码管理喜好进行。</p><pre><code class="hljs 1c">embedded├─bsp├─hal├─fs<span class="hljs-string">|  └─fatfs</span><span class="hljs-string">|     ├─ ...</span><span class="hljs-string">|     └─source</span><span class="hljs-string">|        ...</span>└─project   └─stm32f10x-mdk-none_fatfs      ├─bsp      ├─os      ├─hal      ├─fs      <span class="hljs-string">|  ├─diskio.c</span>      <span class="hljs-string">|  └─ffconf.h</span>      └─mdk</code></pre><h3 id="FatFS源码导入"><a href="#FatFS源码导入" class="headerlink" title="FatFS源码导入"></a>FatFS源码导入</h3><p>需要的文件有：</p><ul><li>ff.c</li><li>ffsystem.c</li><li>diskio.c (待实现的存储驱动)</li></ul><h3 id="实现IO驱动（diskio-c）"><a href="#实现IO驱动（diskio-c）" class="headerlink" title="实现IO驱动（diskio.c）"></a>实现IO驱动（diskio.c）</h3><p>参考FatFS源码中提供的diskio.c实现下述几个接口：</p><pre><code class="hljs C"><span class="hljs-function">DSTATUS <span class="hljs-title">disk_initialize</span> <span class="hljs-params">(BYTE pdrv)</span></span>;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_status</span> <span class="hljs-params">(BYTE pdrv)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_read</span> <span class="hljs-params">(BYTE pdrv, BYTE* buff, LBA_t sector, UINT count)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_write</span> <span class="hljs-params">(BYTE pdrv, <span class="hljs-keyword">const</span> BYTE* buff, LBA_t sector, UINT count)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_ioctl</span> <span class="hljs-params">(BYTE pdrv, BYTE cmd, <span class="hljs-keyword">void</span>* buff)</span></span>;</code></pre><p>针对W25Q128芯片，上述接口的简单实现如下：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;w25qxx.h&quot;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">w25qxx_t</span> w25q128;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_status</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_initialize</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (w25qxx_init(&amp;w25q128)) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-function">DRESULT <span class="hljs-title">disk_read</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">BYTE *buff,<span class="hljs-comment">/* Data buffer to store read data */</span></span></span><span class="hljs-function"><span class="hljs-params">DWORD sector,<span class="hljs-comment">/* Start sector in LBA */</span></span></span><span class="hljs-function"><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to read */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> rc;rc = w25qxx_read(&amp;w25q128, w25q128.sector_size * sector,buff, count * w25q128.sector_size);<span class="hljs-keyword">if</span> (rc) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FF_FS_READONLY == 0</span><span class="hljs-function">DRESULT <span class="hljs-title">disk_write</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> BYTE *buff,<span class="hljs-comment">/* Data to be written */</span></span></span><span class="hljs-function"><span class="hljs-params">DWORD sector,<span class="hljs-comment">/* Start sector in LBA */</span></span></span><span class="hljs-function"><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to write */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> wc;<span class="hljs-keyword">for</span> (wc = <span class="hljs-number">0</span>; wc &lt; count; ++wc) &#123;w25qxx_erase_sector(&amp;w25q128, w25q128.sector_size * (sector + wc));&#125;wc = w25qxx_write(&amp;w25q128, w25q128.sector_size * sector,(<span class="hljs-keyword">uint8_t</span> *)buff, count * w25q128.sector_size);<span class="hljs-keyword">if</span> (wc) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function">DRESULT <span class="hljs-title">disk_ioctl</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber (0..) */</span></span></span><span class="hljs-function"><span class="hljs-params">BYTE cmd,<span class="hljs-comment">/* Control code */</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span> *buff<span class="hljs-comment">/* Buffer to send/receive control data */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">switch</span> (cmd) &#123; <span class="hljs-keyword">case</span> CTRL_SYNC: <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_SECTOR_COUNT: *(DWORD * )buff = w25q128.capacity / w25q128.sector_size; <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_SECTOR_SIZE: *(WORD * )buff = w25q128.sector_size; <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_BLOCK_SIZE:  *(DWORD * )buff = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_PARERR;&#125;</code></pre><p>完整文件见<a href="">diskio.c</a></p><h3 id="FatFS配置"><a href="#FatFS配置" class="headerlink" title="FatFS配置"></a>FatFS配置</h3><ul><li>设置扇区大小</li></ul><h1 id="define-FF-MIN-SS-4096"><a href="#define-FF-MIN-SS-4096" class="headerlink" title="define FF_MIN_SS        4096"></a>define FF_MIN_SS        4096</h1><h1 id="define-FF-MAX-SS-4096"><a href="#define-FF-MAX-SS-4096" class="headerlink" title="define FF_MAX_SS        4096"></a>define FF_MAX_SS        4096</h1><ul><li>启用MKFS接口</li></ul><h1 id="define-FF-USE-MKFS-1"><a href="#define-FF-USE-MKFS-1" class="headerlink" title="define FF_USE_MKFS        1"></a>define FF_USE_MKFS        1</h1><ul><li>不提供RTC</li></ul><h1 id="define-FF-FS-NORTC-1"><a href="#define-FF-FS-NORTC-1" class="headerlink" title="define FF_FS_NORTC        1"></a>define FF_FS_NORTC        1</h1><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fs_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">static</span> FATFS fs; <span class="hljs-comment">/* Filesystem object */</span>    <span class="hljs-keyword">static</span> FIL fil; <span class="hljs-comment">/* File object */</span>    <span class="hljs-keyword">static</span> BYTE work[FF_MAX_SS]; <span class="hljs-comment">/* Work area (larger is better for processing time) */</span>    FRESULT res; <span class="hljs-comment">/* API result code */</span>    UINT cnt;BYTE mm[<span class="hljs-number">50</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_ASSERT(cond, msg) \</span><span class="hljs-keyword">if</span> (!(cond)) &#123; \<span class="hljs-built_in">printf</span>(msg<span class="hljs-string">&quot; error\n&quot;</span>); \<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; \&#125; \<span class="hljs-keyword">else</span> &#123; \<span class="hljs-built_in">printf</span>(msg<span class="hljs-string">&quot; ok\n&quot;</span>); \&#125;    <span class="hljs-comment">// 挂载</span>res = f_mount(&amp;fs, <span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-number">0</span>);MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;mount&quot;</span>);    <span class="hljs-comment">// 新建FatFS</span>res = f_mkfs(<span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-literal">NULL</span>, work, <span class="hljs-keyword">sizeof</span>(work)); <span class="hljs-comment">//</span>MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;mkfs&quot;</span>);    <span class="hljs-comment">// 新建文件</span>res = f_open(&amp;fil, <span class="hljs-string">&quot;0:/a.txt&quot;</span>, FA_CREATE_NEW|FA_WRITE|FA_READ);MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;open&quot;</span>);<span class="hljs-comment">// 写文件</span>res = f_write(&amp;fil, <span class="hljs-string">&quot;Hello,World!&quot;</span>, <span class="hljs-number">12</span>, &amp;cnt);MSG_ASSERT(res == FR_OK &amp;&amp; cnt == <span class="hljs-number">12</span>, <span class="hljs-string">&quot;write&quot;</span>);    <span class="hljs-comment">// 获取文件大小</span>cnt = f_size(&amp;fil);MSG_ASSERT(cnt == <span class="hljs-number">12</span>, <span class="hljs-string">&quot;size&quot;</span>);    <span class="hljs-comment">// 读文件</span><span class="hljs-built_in">memset</span>(mm, <span class="hljs-number">0x0</span>, <span class="hljs-number">50</span>);f_lseek(&amp;fil, <span class="hljs-number">0</span>);res = f_read(&amp;fil, mm, <span class="hljs-number">12</span>, &amp;cnt);MSG_ASSERT(res == FR_OK &amp;&amp; cnt == <span class="hljs-number">12</span> &amp;&amp; <span class="hljs-built_in">memcmp</span>(mm, <span class="hljs-string">&quot;Hello,World!&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;read&quot;</span>);f_close(&amp;fil);f_mount(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS</a></li><li><a href="http://elm-chan.org/fsw/ff/archives.html">FatFS往期版本</a></li><li><a href="https://github.com/abbrev/fatfs.git">FatFS Github Mirror</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>文件系统</tag>
      
      <tag>FatFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F10x+RTThread+MDK移植</title>
    <link href="/2021/01/07/STM32F10x-RTThread-MDK%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/07/STM32F10x-RTThread-MDK%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="STM32F10x-RTThread-MDK移植"><a href="#STM32F10x-RTThread-MDK移植" class="headerlink" title="STM32F10x+RTThread+MDK移植"></a>STM32F10x+RTThread+MDK移植</h2><p>此项目代码见<a href="https://github.com/Doerthous/dts.embedded">stm32f10x-mdk-rtthread_empty</a>。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F103ZE </li></ul><p>软件：</p><ul><li>MDK 5.26.2.0</li><li>RTThread 4.0.0</li><li>STM32F10x StdPeriph Lib 3.5.0 </li></ul><p>目录结构：</p><p>以下是移植过程中的项目目录结构。此处的目录结构非必须，可根据个人代码管理喜好进行。</p><pre><code class="hljs lua">embedded├─bsp├─<span class="hljs-built_in">os</span>└─project   └─stm32f10x-mdk-rtthread_empty      ├─bsp      ├─<span class="hljs-built_in">os</span>      └─mdk</code></pre><h3 id="1-获取源码"><a href="#1-获取源码" class="headerlink" title="1. 获取源码"></a>1. 获取源码</h3><h4 id="获取BSP源码"><a href="#获取BSP源码" class="headerlink" title="获取BSP源码"></a>获取BSP源码</h4><p>下载STM32F10x对应的<a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">bsp源码</a>，拷贝到<code>embedded/bsp</code>目录中。</p><pre><code class="hljs erlang">embedded├─bsp│  ├─CMSIS│  └─STM32F10x_StdPeriph_Driver├─os|  ...└─project   ...</code></pre><h4 id="获取OS源码"><a href="#获取OS源码" class="headerlink" title="获取OS源码"></a>获取OS源码</h4><p>获取RTThread源码可通过下面两种方式进行，本教程使用第二种方式。</p><ul><li><p>直接下载某个版本的源码</p></li><li><p>使用<code>git submodule</code>将源码仓库拉到本地，并切换到指定版本</p></li></ul><p>进入<code>embedded/os</code>目录，执行<code>git submodule add https://github.com/RT-Thread/rt-thread.git</code>，待拉取结束后，<code>embedded/os</code>目录下将新增<code>rt-thread</code>目录，即为RTThread源码。</p><pre><code class="hljs 1c">embedded├─bsp<span class="hljs-string">|  ...</span>├─os<span class="hljs-string">|  └─rt-thread</span>└─project   ...</code></pre><p>进入<code>rt-thread</code>目录，执行<code>git checkout v4.0.0</code>切换到4.0.0版本的RTThread。</p><h3 id="2-拷贝项目相关源码"><a href="#2-拷贝项目相关源码" class="headerlink" title="2. 拷贝项目相关源码"></a>2. 拷贝项目相关源码</h3><ul><li>将和本项目直接相关的源码拷贝到<code>embedded/project/stm32f10x-mdk-rtthread_empty</code>（本节及其小节内简记为<code>stm32f10x-mdk-rtthread_empty</code>）及其子目录下。</li></ul><h4 id="拷贝BSP相关源码"><a href="#拷贝BSP相关源码" class="headerlink" title="拷贝BSP相关源码"></a>拷贝BSP相关源码</h4><ul><li>将<code>stm32f10x_conf.h</code>（可在STM32F10x StdPeriph Lib 3.5.0中找到）拷贝到<code>stm32f10x-mdk-rtthread_empty/bsp</code>目录下。</li></ul><h4 id="移植或从OS源码中拷贝相关源码"><a href="#移植或从OS源码中拷贝相关源码" class="headerlink" title="移植或从OS源码中拷贝相关源码"></a>移植或从OS源码中拷贝相关源码</h4><p>由于RTThread已经有了STM32F10X芯片的例程，所以本教程直接拷贝其源码。</p><ul><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/drivers</code>下的<code>board.c</code>及<code>board.h</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/bsp</code>目录下。</p></li><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/rtconfig.h</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/os</code>目录下。</p></li><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/applications/startup.c</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/app</code>目录下。</p></li></ul><h3 id="3-新建项目"><a href="#3-新建项目" class="headerlink" title="3. 新建项目"></a>3. 新建项目</h3><p>新建keil项目，并将项目文件(.uvprojx等文件)保存到<code>embedded/project/stm32f10x-mdk-rtthread_empty/mdk</code>中。</p><h3 id="4-将源码导入项目"><a href="#4-将源码导入项目" class="headerlink" title="4. 将源码导入项目"></a>4. 将源码导入项目</h3><h4 id="导入BSP源码"><a href="#导入BSP源码" class="headerlink" title="导入BSP源码"></a>导入BSP源码</h4><p>将下述文件导入到项目的bsp目录中</p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp/board.c</code></p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport/core_cm3.c</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/startup_stm32f10x_hd.s</code></p><p><code>embedded/bsp/STM32F10x_StdPeriph_Driver/src/misc.c</code></p><h4 id="导入OS源码"><a href="#导入OS源码" class="headerlink" title="导入OS源码"></a>导入OS源码</h4><p>将下述文件导入到项目的os目录中，</p><p><code>embedded/os/rt-thread/libcpu/arm/cortex-m3/cpuport.c</code><br><code>embedded/os/rt-thread/libcpu/arm/cortex-m3/context_rvds.S</code><br><code>embedded/os/rt-thread/src</code>下所有.c文件</p><h4 id="导入启动代码"><a href="#导入启动代码" class="headerlink" title="导入启动代码"></a>导入启动代码</h4><p>将下述文件导入到项目的app目录中，</p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp/startup.c</code></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>最终结果如下图，</p><p><img src="https://ftp.bmp.ovh/imgs/2021/01/93e69f86f18025a3.png" alt="p1"></p><h3 id="5-配置"><a href="#5-配置" class="headerlink" title="5. 配置"></a>5. 配置</h3><h4 id="配置项目include路径"><a href="#配置项目include路径" class="headerlink" title="配置项目include路径"></a>配置项目include路径</h4><p>将以下目录设置为include目录，</p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x</code></p><p><code>embedded/bsp/STM32F10x_StdPeriph_Driver/inc</code></p><p><code>embedded/os/rt-thread/include</code></p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp</code><br><code>embedded/project/stm32f10x-mdk-rtthread_empty/os</code></p><h4 id="配置BSP"><a href="#配置BSP" class="headerlink" title="配置BSP"></a>配置BSP</h4><h5 id="配置ST外设库"><a href="#配置ST外设库" class="headerlink" title="配置ST外设库"></a>配置ST外设库</h5><p>在keil中添加宏定义<code>USE_STDPERIPH_DRIVER</code>和<code>STM32F10X_HD</code>，修改<code>stm32f10x-mdk-rtthread_empty/bsp/stm32f10x_conf.h</code>配置，注释掉暂不使用的功能（非<code>misc.h</code>的头文件）。</p><pre><code class="hljs C"><span class="hljs-comment">//#include &quot;stm32f10x_adc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_bkp.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_can.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_cec.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_crc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dac.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dbgmcu.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dma.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_exti.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_flash.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_fsmc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_gpio.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_i2c.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_iwdg.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_pwr.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_rcc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_rtc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_sdio.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_spi.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_tim.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_usart.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_wwdg.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;misc.h&quot;</span> <span class="hljs-comment">/* High level functions for NVIC and SysTick (add-on to CMSIS functions) */</span></span></code></pre><h4 id="配置OS"><a href="#配置OS" class="headerlink" title="配置OS"></a>配置OS</h4><p>修改<code>stm32f10x-mdk-rtthread_empty/os/rtconfig.h</code>配置。</p><pre><code class="hljs C">...<span class="hljs-comment">// 注释掉暂不使用的功能</span><span class="hljs-comment">//#define RT_USING_POSIX</span><span class="hljs-comment">//#define RT_USING_DEVICE</span><span class="hljs-comment">//#define RT_USING_FINSH</span><span class="hljs-comment">//#define RT_USING_DFS</span><span class="hljs-comment">// 每秒1000次tick</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RT_TICK_PER_SECOND 1000</span>...</code></pre><p><code>startup.c</code>:</p><pre><code class="hljs C">...<span class="hljs-comment">// 添加测试程序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rt_init_thread_entry</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* parameter)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;rt_thread_delay(<span class="hljs-number">1000</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rt_application_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">rt_thread_t</span> init_thread;    init_thread = rt_thread_create(<span class="hljs-string">&quot;init&quot;</span>,                                   rt_init_thread_entry, RT_NULL,                                   <span class="hljs-number">2048</span>, <span class="hljs-number">8</span>, <span class="hljs-number">20</span>);    <span class="hljs-keyword">if</span> (init_thread != RT_NULL)        rt_thread_startup(init_thread);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;...</code></pre><p><code>board.c</code>:</p><pre><code class="hljs C">...<span class="hljs-comment">// 注释掉无效内容</span><span class="hljs-comment">//#include &quot;stm32f10x_fsmc.h&quot;</span><span class="hljs-comment">//#include &quot;usart.h&quot;</span><span class="hljs-comment">//rt_hw_usart_init();</span><span class="hljs-comment">//rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span>...</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">STM32F10x StdPeriph Lib 3.5.0</a></p></li><li><p><a href="https://www.rt-thread.org/">RTThread</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>RTOS移植</tag>
      
      <tag>MDK</tag>
      
      <tag>RTThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3 ARP协议</title>
    <link href="/2020/11/07/ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/07/ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1 目的"></a>1 目的</h3><p>解决已知目标网络地址但未知其硬件地址时，如何获取目标硬件地址的问题。</p><h3 id="2-交互过程"><a href="#2-交互过程" class="headerlink" title="2 交互过程"></a>2 交互过程</h3><p>一子网中有A（192.168.1.101）、B（192.168.1.1）、X（X知道B的MAC地址）。A要发送数据给B，但不知道B的MAC地址：</p><p>A广播：谁有192.168.1.1的MAC地址，请告诉我（192.168.1.101）</p><p>X单播到A：192.168.1.1的MAC地址是AA:BB:CC:DD:EE:FF。</p><h3 id="3-ARP包格式"><a href="#3-ARP包格式" class="headerlink" title="3 ARP包格式"></a>3 ARP包格式</h3><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            hrd (2)            |             pro (2)           |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|     hln (1)   |     pln (1)   |             op (2)            |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            sha (n)                            ||                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            spa (m)                            ||                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            tha (n)                            | |                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            tpa (m)                            | |                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段      字节数     说明<span class="hljs-bullet">----      </span>----      ----hrd       2         硬件地址类型（1=Ethernet（以太网））。pro       2         网络地址类型（0x0800=IP）。hln       1         硬件地址长度（以太网地址长度6字节）。pln       1         网络地址长度（IP地址长度4字节）。op        2         操作码（1=REEQUEST，2=REPLY）。sha       n         源硬件地址，长度由hln指定。spa       m         源网络地址，长度由pln指定。tha       n         目标硬件地址，长度由hln指定。tpa       m         目标网络地址，长度由pln指定。</code></pre><h3 id="4-实现考虑"><a href="#4-实现考虑" class="headerlink" title="4 实现考虑"></a>4 实现考虑</h3><ul><li><p>ARP表</p><p>  以网络地址为key，硬件地址为value的数据库</p></li><li><p>ARP模块</p><p>  ARP协议本身并未假定某个硬件（Ethernet）或网络（IP），针对任意的<strong>硬件-网络</strong>协议对，都可以使用ARP协议解决获取硬件地址的问题。故可将ARP实现为<strong>ARP协议拆包组包模块</strong>及<strong>Ethernet-IP ARP模块</strong>。前者只负责ARP包的拆组，后者负责处理ARP交互逻辑。</p></li></ul><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h3><ul><li><p>Linux下抓包</p><p>  sudo tcpdump -i eth0 -x</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://tools.ietf.org/html/rfc826">An Ethernet Address Resolution Protocol</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>网络协议</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 ENC28J60笔记</title>
    <link href="/2020/11/06/ENC28J60%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/06/ENC28J60%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ENC28J60笔记"><a href="#ENC28J60笔记" class="headerlink" title="ENC28J60笔记"></a>ENC28J60笔记</h1><p>本文记录了开发驱动过程中的大致实施思路以及踩过的一些坑，方便后续回顾。本文尚未完善，但已有基本思路，如后续有需要再进行细化。具体的细节还需参考芯片的数据手册。实现见<a href="https://github.com/Doerthous/dts_driver">dts_driver</a>中enc28j60*。</p><h2 id="供给协议栈的接口"><a href="#供给协议栈的接口" class="headerlink" title="供给协议栈的接口"></a>供给协议栈的接口</h2><p>和其他通讯硬件类似，ENC28J60提供给上层软件的接口基本上包括初始化接口和收发接口，其可能的形式如下（如无特殊说明，下文中提到的<strong>基本接口</strong>均指此处提到的软件接口）。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enc28j60_init</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60)</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_send</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_recv</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;</code></pre><p>此外，出于其他需要，可能还需实现一些管理、配置用的接口，不过我们暂时不关注这些。有了上述这些基本接口后，上层软件就可以将封装成以太网数据帧的数据发送到线缆上。关于以太网数据帧的说明在本文后续有简单地涉及，现在我们先把它当成黑盒子，划清驱动的范围，重点考虑如何实现这些接口。</p><h2 id="解剖ENC28J60"><a href="#解剖ENC28J60" class="headerlink" title="解剖ENC28J60"></a>解剖ENC28J60</h2><p>在考虑实现基本接口前，我们需要先熟悉一下ENC28J60。</p><p>通过查阅其手册可知，ENC28J60身提供了一个SPI接口和一个中断信号INT（其他暂不考虑）作为和外部设备通信的接口，其内部包含有用于各类特殊用途的<strong>寄存器</strong>和用于存放数据帧的硬件缓冲区（<strong>以太网缓冲</strong>），通过SPI接口，我们可以直接或间接地访问这些内存。</p><pre><code class="hljs gherkin">                                 ENC28J60                          +-----------------------------+                      |<span class="hljs-string">  +-------+  +------------+  </span>|                      |<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                      |<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   +--+--+  ETH  |<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Ethernet  </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  </span>|<span class="hljs-string">   Buffer   </span>|<span class="hljs-string">  </span>|                   +--+-------------+            |<span class="hljs-string">  </span>|+------------+     |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>||<span class="hljs-string"> Host       </span>|<span class="hljs-string"> SPI </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>||<span class="hljs-string"> Controller +-----+--+--+  MAC  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|+------------+     |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  +------------+  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  +------------+  </span>|                   +--+--+  MII  +--+    PHY     |<span class="hljs-string">  </span>|                      |<span class="hljs-string">  +-------+  +------------+  </span>|                      +-----------------------------+</code></pre><h3 id="SPI接口"><a href="#SPI接口" class="headerlink" title="SPI接口"></a>SPI接口</h3><p>ENC28J60的SPI接口仅支持mode(0,0)模式，即<strong>空闲时时钟处于低电平</strong>，<strong>在第一个边沿采样</strong>。</p><p>ENC28J60的指令集包括：</p><ol><li>读控制寄存器指令（Read Control Register Command, RCR）</li><li>写控制寄存器指令（Write Control Register Command, WCR）</li><li>读以太网缓冲指令（Read Buffer Memory Command, RBM）</li><li>写以太网缓冲指令（Write Buffer Memory Command, WBM）</li><li>置位指令（Bit Field Set Command, BFS）</li><li>清零指令（Bit Field Clear Command, BFC）</li><li>系统复位指令（System Reset Command, SRC）</li></ol><p>其通信格式为：指令码(3 bits)+寄存器地址或固定值(5 bits)+数据(N bytes)。</p><div class="table-container"><table><thead><tr><th>指令</th><th>指令码</th><th>十六进制</th><th>地址/参数</th></tr></thead><tbody><tr><td>RCR</td><td>000b</td><td>00h</td><td>address</td></tr><tr><td>WCR</td><td>010b</td><td>02h</td><td>address</td></tr><tr><td>RBM</td><td>001b</td><td>01h</td><td>11010b</td></tr><tr><td>WBM</td><td>011b</td><td>03h</td><td>11010b</td></tr><tr><td>BFS</td><td>100b</td><td>04h</td><td>address</td></tr><tr><td>BFC</td><td>101b</td><td>05h</td><td>address</td></tr><tr><td>SRC</td><td>111b</td><td>07h</td><td>11111b</td></tr></tbody></table></div><p>具体时序见ENC28J60的数据手册。需要注意的是BFS和BFC指令只能用于ETH寄存器。另外，除了RBM和WBM指令，其他指令貌似均不能连续操作寄存器。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_RCR(addr)   (0x1F &amp; (addr))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_RBM         ((0x01 &lt;&lt; 5)|(0x1A))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_WCR(addr)   ((0x02 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_WBM         ((0x03 &lt;&lt; 5)|(0x1A))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_BFS(addr)   ((0x04 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_BFC(addr)   ((0x05 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_SRC         (0xFF)</span></code></pre><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>ENC28J60的寄存器大致可分为四类，包括ETH寄存器、MAC寄存器、MII寄存器以及PHY寄存器，其中除了PHY寄存器需要通过MII寄存器进行间接访问外，其余的寄存器均可以通过SPI接口进行访问。</p><p>ENC28J60的寄存器集合又被分到了四个区域（Bank），每个Bank有32个寄存器，所以每个Bank中的寄存器都可以通过一个5bit长的地址进行寻址，结合前边的SPI命令可知，每个SPI都可以寻址到任意一个Bank中的所有寄存器。</p><p>另外，每个Bank最后的5个寄存器（<code>EIE</code>、<code>EIR</code>、<code>ESTAT</code>、<code>ECON2</code>、<code>ECON1</code>）都相同，即无论在哪个Bank中，<code>EIE</code>（或其他四个）都是同一个，这样一来，访问这些寄存器就无需频繁地切换Bank。</p><p>Bank由<code>ECON1</code>中的两个比特<code>ECON1.BSEL</code>指定。所以，要想访问寄存器，一般要先选择Bank，在选择Bank中的寄存器。</p><pre><code class="hljs gherkin">      Bank0        Bank1        Bank2        Bank3     +----------+ +----------+ +----------+ +----------+0x00 |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     +----------+ +----------+ +----------+ +----------+     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     +----------+ +----------+ +----------+ +----------+0x1B |<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|     +----------+ +----------+ +----------+ +----------+0x1C |<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|     +----------+ +----------+ +----------+ +----------+0x1D |<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|     +----------+ +----------+ +----------+ +----------+0x1E |<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|     +----------+ +----------+ +----------+ +----------+0x1F |<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|     +----------+ +----------+ +----------+ +----------+</code></pre><h3 id="以太网缓冲区"><a href="#以太网缓冲区" class="headerlink" title="以太网缓冲区"></a>以太网缓冲区</h3><p>ENC28J60有一个8K的以太网缓冲，主要用来存储以太网数据帧数据。</p><p>该缓冲可通过两个寄存器<code>ERDPT</code>与<code>EWRPT</code>进行访问。<code>EWRPT</code>指向的位置是将要写入的位置，<code>ERDPT</code>则是将要读取的位置，结合这两个寄存器，主控可以通过<code>Read Buffer Memory</code>和<code>Read Buffer Memory</code>SPI指令来读写整个缓冲区。</p><p>通过将<code>ECON2</code>寄存器的<code>AUTOINC</code>位设置为1（<code>ECON2.AUTOINC</code>的复位值为1），还可以使这两个指针自动递增。</p><pre><code class="hljs c">            +-----------+            |           |  <span class="hljs-number">0x0000</span>            +-----------+ERDPT +---&gt; |           |  <span class="hljs-number">0x0001</span>            +-----------+            |           |            |    ...    |            |           |            +-----------+EWRPT +---&gt; |           |  <span class="hljs-number">0x1FFE</span>            +-----------+            |           |  <span class="hljs-number">0x1FFF</span>            +-----------+</code></pre><p>整个8K缓冲又被分为RX与TX两部分，通过设置寄存器<code>ERXSTPT</code>与<code>ERXNDPT</code>来划分RX缓冲，其余皆为TX缓冲。根据[1]中的Issue#5的描述，<code>ERXSTPT</code>必须设置为0x0000，所以整个缓冲的结构和下图类似。</p><p>在ENC28J60内部存在一个主控无法访问的指向RX区域的寄存器<code>ERXWRPT</code>。该寄存器的作用和<code>EWRPT</code>类似，作为ENC28J60接收数据时的写指针，即当收到以太网数据时，ENC28J60会将数据拷贝到<code>ERXWRPT</code>指向的以太网缓冲内存，并自动移动该指针。另外，还有个<code>ERXRDPT</code>寄存器，该寄存器用来作为RX队列的哨兵节点，标识RX队列的头部。</p><pre><code class="hljs c">              +-----------+  --+-----ERXSTPT +---&gt; |           |    ^              +-----------+    |              |           |    |              |    ...    |    |RX区域              |           |    |              +-----------+    |ERXNDPT +---&gt; |           |    v              +-----------+  --------              |           |    ^              |    ...    |    |              |           |    |TX区域              +-----------+    |              |           |    v              +-----------+  --+-----</code></pre><blockquote><p>注：ST（Start），ND（End）</p></blockquote><h4 id="TX缓冲指针"><a href="#TX缓冲指针" class="headerlink" title="TX缓冲指针"></a>TX缓冲指针</h4><p>前边说过<code>ERXSTPT</code>和<code>ERXNDPT</code>确定了RX缓冲的范围，而在ENC28J60提供的寄存器中，还存在<code>ETXSTPT</code>和<code>ETXNDPT</code>两个寄存器。但是这两个寄存器的作用并非用于确定TX缓冲的范围（RX缓冲范围确定后，剩余的都是TX缓冲），而是用来确定当前要发送的数据的范围。当把<code>ECON1.TXRTS</code>置1以启动发送后，ENC28J60会把从<code>ETXSTPT</code>到<code>ETXNDPT</code>的地方判定为当前需要发送的数据，接着把数据发送到线缆上。</p><pre><code class="hljs gherkin">    TX FIFO+--------------+|<span class="hljs-string"> +----------+ &lt;---ETXSTPT</span>|<span class="hljs-string"> </span>|<span class="hljs-string">ctrl byte </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> packet1  </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ &lt;---ETSNDPT</span>|<span class="hljs-string">      ...     </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">ctrl byte </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> packet2  </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string">      ...     </span>|+--------------+</code></pre><h4 id="RX队列"><a href="#RX队列" class="headerlink" title="RX队列"></a>RX队列</h4><p>ENC28J60的数据接收采用队列的形式，它在接收到的数据包前边添加了下一个数据包的指针（Next Packet Pointer），在RX缓冲中，其呈现了下述的形式。</p><p>我们通过<code>Read Buffer Memory</code>命令读取RX缓冲中的数据时，需要先设置<code>ERXRDPT</code>来确定读取的起始位置。在读取RX数据后，需要把Next Packet Pointer保存下来，以便读取下一个数据包时用于设置<code>ERXRDPT</code>。需要注意，<code>ERXRDPT</code>必须设置成奇数地址，而Next Packet Pointer总是偶数地址。</p><pre><code class="hljs gherkin">    RX FIFO+--------------+|<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">              </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------&lt;-+---+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">              </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------&lt;-+---+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">      ...   &lt;-+---+</span><span class="hljs-string">+--------------+</span></code></pre><h4 id="RX缓冲写入细节"><a href="#RX缓冲写入细节" class="headerlink" title="RX缓冲写入细节"></a>RX缓冲写入细节</h4><p>ENC28J60接收线缆上的数据的伪代码大致如下，需要注意的是<code>erxwrpt == erxrdpt</code>的情况，该情况下，ENC28J60将判定缓冲区无多余空间存储新数据，之后将不再接收新数据，直到有空余的空间出现。</p><pre><code class="hljs properties"><span class="hljs-attr">struct</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxstpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxndpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxrdpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxwrpt;</span><span class="hljs-meta">&#125;</span> <span class="hljs-string">rx_fifo;</span><span class="hljs-meta">enc28j60_write_data_to_rx_fifo(data,</span> <span class="hljs-string">size)</span>    <span class="hljs-attr">for</span> <span class="hljs-string">i=0~(size-1)</span>        <span class="hljs-attr">if</span> <span class="hljs-string">erxwrpt == erxrdpt:</span>            <span class="hljs-attr">rx</span> <span class="hljs-string">abort</span>        <span class="hljs-meta">*erxwrpt</span> = <span class="hljs-string">data[i]</span>        <span class="hljs-attr">increase</span> <span class="hljs-string">erxwrpt (make sure erxwrpt between erxstpt and erxndpt)</span></code></pre><p>ENC28J60把帧数据写到缓冲后会将<code>PKTCNT</code>加一，主控可通过查询<code>PKTCNT</code>判断当前缓冲中是否有数据帧，当主控从缓冲中读取一帧数据后，还需通过将<code>ECON2.PKTDEC</code>置1来递减<code>PKTCNT</code>，否则，一旦<code>PKTCNT</code>递增到255后，ENC28J60将不再接收线缆上的新数据帧。</p><h4 id="通过以太网缓冲与ENC28J60交互"><a href="#通过以太网缓冲与ENC28J60交互" class="headerlink" title="通过以太网缓冲与ENC28J60交互"></a>通过以太网缓冲与ENC28J60交互</h4><p>以太网缓冲区除了用来存放以太网数据帧外，还会放一些状态和控制数据。包括接收状态向量、发送状态向量以及发送控制字节。</p><p>主控在发送数据前，要先往发送缓冲区中写入一个控制字节，然后才将以太网帧数据写入到发送缓冲区。发送完一包数据后，ENC28J60会在包的尾部写入七个字节的发送状态向量，用于指示该包的发送状态。同样，收数据时，ENC28J60在往接收缓冲区中写入以太网帧数据前会先写入六个字节的接收状态向量。</p><h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>发送数据的过程如下所示，首先1)主控向缓冲区写入一个<strong>控制字节</strong>，然后2)写入以太网数据帧，启动发送并且发送完毕后，ENC28J60会3)在包尾部添加七个字节的<strong>发送状态向量</strong>，用于指示发送的状态及结果。</p><pre><code class="hljs gherkin">HostController      TX Buffer        ENC28J60            +---------------+            |<span class="hljs-string">      ...      </span>|            |<span class="hljs-string"> +-----------+ </span>|    1)--------+ ctrl byte |<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|    2)--------+  packet   |<span class="hljs-string"> </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|<span class="hljs-string">    </span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> transmit  +------3)</span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   status  </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string">      ...      </span>|            +---------------+</code></pre><h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>接收数据的过程如下所示，当有数据收到后，ENC28J60会1)先往缓冲区中写入一个<strong>接收状态向量</strong>，2)然后才写入真正的以太网数据帧。在收到信号或查询到有数据时，主控依次3)、4)读取<strong>接收状态向量</strong>和以太网数据帧。</p><pre><code class="hljs gherkin">HostController      RX Buffer        ENC28J60            +---------------+            |<span class="hljs-string">      ...      </span>|            |<span class="hljs-string"> +-----------+ </span>|<span class="hljs-string">    </span><span class="hljs-string">    3)--------+ receive   +------1)</span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   status  </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|    4)--------+  packet   +------2)            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string">      ...      </span>|            +---------------+</code></pre><h2 id="基本接口实现思路"><a href="#基本接口实现思路" class="headerlink" title="基本接口实现思路"></a>基本接口实现思路</h2><p>在参考了ENC20J68数据手册，并对ENC20J68的行为进行大致分析后，三个接口的实现思路如下。</p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><ol><li>初始化以太网缓冲（RX初始化ST、ND、RDPT）</li><li>设置接收过滤器（RX filter）</li><li>等待晶振稳定（修改MAC和PHY寄存器需等待时钟稳定）</li><li>MAC初始化</li><li>PHY初始化</li></ol><blockquote><p>Reset后初始化，一般初始化后，后续无需再初始化。</p></blockquote><h3 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h3><ol><li>设置EWRPT指针</li><li>将以太网数据帧拷贝到以太网缓冲中</li><li>设置ETXSTPT和ETXNDPT指针</li><li>启动传输</li><li>等待传输完毕</li><li>读取传输状态向量，判断传输状态</li></ol><h3 id="接收流程"><a href="#接收流程" class="headerlink" title="接收流程"></a>接收流程</h3><ol><li>检查PKTCNT寄存器，判断是否有收到数据包</li><li>设置Next Packet Pointer</li><li>读取接收状态向量</li><li>读取以太网数据帧</li><li>保存Next Packet Pointer</li><li>递减PKTCNT寄存器</li></ol><h2 id="ENC28J60的功能点"><a href="#ENC28J60的功能点" class="headerlink" title="ENC28J60的功能点"></a>ENC28J60的功能点</h2><h3 id="以太网数据帧"><a href="#以太网数据帧" class="headerlink" title="以太网数据帧"></a>以太网数据帧</h3><ul><li>发送时可通过控制<code>MACON3.PADCFG</code>使其自动添加CRC以及Padding。</li><li>接收时通过设置<code>ERXFCON.CRCEN</code>对收到的帧进行CRC校验。</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>ENC28J60有多个中断源和一个总中断开关，中断配置主要涉及了<code>EIE</code>，<code>EIR</code>以及<code>ESTAT</code>寄存器。本文只关注TXIE、PKTIE、TXERIE、RXERIE这四个中断，以及INTE总中断开关。</p><p>ENC28J60数据手册中有一张清晰表示了其中断逻辑的逻辑门图，此处简要用代码表述了其原理，更多信息请参考ENC28J60的数据手册。</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (TXIE and TXIF) <span class="hljs-comment">// 发送结束中断开关 及 发送结束中断标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (PKTIE and PKTIF) <span class="hljs-comment">// 收到PKT中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (TXERTIE and TXERIF) <span class="hljs-comment">// 发送异常中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (RXERTIE and RXERIF) <span class="hljs-comment">// 接收异常中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span>... <span class="hljs-comment">// 其他中断信号</span><span class="hljs-keyword">if</span> (INTIE &amp;&amp; <span class="hljs-keyword">INT</span>) <span class="hljs-comment">// 总中断开关 及 其标志</span>    拉低<span class="hljs-keyword">INT</span>信号线</code></pre><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><ul><li>半双工模式下，可以通过控制<code>EFLOCON.FCEN0</code>来一直发送前导码，以占用信道，类似在说，我在用。设置<code>ECON1.TXRTS</code>后（启动发送），有一个间隔，间隔结束后开始发送packet。</li></ul><h2 id="容易掉坑的地方"><a href="#容易掉坑的地方" class="headerlink" title="容易掉坑的地方"></a>容易掉坑的地方</h2><ul><li><p>RX缓冲必须从0x0000地址起始，即<code>ERXSTPT</code>必须设置为0x0000。</p></li><li><p><code>ERXRDPT</code>必须设置成奇数地址。</p></li><li><p>SPI时序不匹配或时钟频率过低、dummy byte没有处理、bank不正确、晶振不稳定可能导致寄存器读写不正常。</p></li><li><p>复位后要等待晶振稳定（通过<code>ESTAT.CLKRDY</code>判断）才能收发数据或访问MAC、MII、PHY寄存器。</p></li><li><p><code>Bit Field Set</code>、<code>Bit Field Clear</code>指令中，别多传Data，有些Data会跑到下一个地址，导致程序逻辑错误。比如，往<code>ECON2.PKTDEC</code>写1时，多写一次会写到下一个地址相同位的地方，即ECON1.RXRST，导致接收异常。</p></li><li><p><code>Bit Field Set</code>、<code>Bit Field Clear</code>指令只能用于ETH寄存器。</p></li><li><p>当<code>MACON3.FULDPX</code>和<code>PHCON1.PDPXMD</code>所指示的全/半双工状态不相同时，芯片处于未定义状态。</p></li><li><p>接收逻辑使能（<code>ECON1.RXEN</code>为1）时，不可以改变<code>ERXST</code>和<code>ERXND</code>指针。</p></li><li><p>更改<code>ERXRDPT</code>时，必须先写<code>ERXRDPTL</code>，后写<code>ERXRDPTH</code>。</p></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h3><p>以太网帧结构按序包括下述字段：</p><p>目标MAC地址、源MAC地址、类型/长度、有些载荷、填充数据、CRC校验。</p><p>CRC校验的内容包括目标MAC地址、源MAC地址、类型/长度、有些载荷、填充数据。一般和IEEE 802.3标准相兼容的帧的长度在64和1518个字节之间，所以当有效载荷小于46（46+6+6+2+4）个字节时需要填充数据。</p><p>另外，除了在发送以太网帧之前，PHY还会发送前导码和帧分隔。</p><h3 id="Linux下收发以太网帧"><a href="#Linux下收发以太网帧" class="headerlink" title="Linux下收发以太网帧"></a>Linux下收发以太网帧</h3><p><a href="https://stackoverflow.com/questions/24355597/linux-when-sending-ethernet-frames-the-ethertype-is-being-re-written">源码见本问题回答</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>全双工模式中的暂停控制帧（IEEE 802.3）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>[1] <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/80349c.pdf">ENC28J60 Silicon Errata and Data Sheet Clarification</a></p></li><li><p>[2] <a href="https://pdf1.alldatasheet.com/datasheet-pdf/view/515823/MICROCHIP/ENC28J60.html">ENC28J60 Data Sheet</a></p></li><li><p>[3] <a href="https://stackoverflow.com/questions/24355597/linux-when-sending-ethernet-frames-the-ethertype-is-being-re-written">Linux: When sending Ethernet frames the ethertype is being re-written</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>从零开始造网络协议栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>驱动</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python ArgParse笔记</title>
    <link href="/2020/11/02/Python-ArgParse%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/02/Python-ArgParse%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="可选参数和位置参数"><a href="#可选参数和位置参数" class="headerlink" title="可选参数和位置参数"></a>可选参数和位置参数</h2><p>可选参数由类似<code>add_argument(&#39;-f&#39;,&#39;--foo&#39;)</code>的语句创建，<code>add_argument(&#39;foo&#39;)</code>创建位置参数。当调用<code>parse_args()</code>时，带<code>-</code>前缀的将被识别为可选参数，剩余的被识别为位置参数。</p><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>通过调用<a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method">add_argument</a>可设置参数的一些属性，如默认值、参数类型等。</p><h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>子命令通过<a href="https://docs.python.org/3/library/argparse.html#sub-commands">add_subparsers</a>创建，</p><pre><code class="hljs python">parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_a = subparsers.add_parser(<span class="hljs-string">&#x27;cmd1&#x27;</span>)<span class="hljs-comment"># parser_a.add_argument ...</span>parser_b = subparsers.add_parser(<span class="hljs-string">&#x27;cmd2&#x27;</span>)<span class="hljs-comment"># parser_b.add_argument ...</span></code></pre><p>用法上，除了在调用时需指定子命令外（如<code>python p.py cmd1 ...</code>），其余基本相同。</p><h2 id="一些需求"><a href="#一些需求" class="headerlink" title="一些需求"></a>一些需求</h2><h3 id="两种执行模式"><a href="#两种执行模式" class="headerlink" title="两种执行模式"></a>两种执行模式</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py -s</code>执行另一种操作</li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&#x27;-s&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>)args = parser.parse_args()<span class="hljs-keyword">if</span> args.s:    print(<span class="hljs-string">&#x27;python p.py -s&#x27;</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)</code></pre><h3 id="互斥的多模式"><a href="#互斥的多模式" class="headerlink" title="互斥的多模式"></a>互斥的多模式</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py s</code>执行另一种操作</li><li><code>python p.py r</code>执行另一种操作</li><li>1,2,3互斥</li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_r</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py r&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_s</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py s&#x27;</span>)parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_s = subparsers.add_parser(<span class="hljs-string">&#x27;s&#x27;</span>)parser_s.set_defaults(func=func_s)parser_r = subparsers.add_parser(<span class="hljs-string">&#x27;r&#x27;</span>)parser_r.set_defaults(func=func_r)args = parser.parse_args()<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(args, <span class="hljs-string">&#x27;func&#x27;</span>):    args.func = funcargs.func(args)</code></pre><h3 id="带参命令"><a href="#带参命令" class="headerlink" title="带参命令"></a>带参命令</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py s</code>执行另一种操作</li><li><code>python p.py r</code>执行另一种操作</li><li>1,2,3互斥</li><li><code>python p.py r [-t title]</code>提供可选参数<code>title</code>, 默认为<code>&#39;&#39;</code></li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_r</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py r title:%s&#x27;</span> % args.title)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_s</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py s&#x27;</span>)parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_s = subparsers.add_parser(<span class="hljs-string">&#x27;s&#x27;</span>)parser_s.set_defaults(func=func_s)parser_r = subparsers.add_parser(<span class="hljs-string">&#x27;r&#x27;</span>)parser_r.set_defaults(func=func_r)parser_r.add_argument(<span class="hljs-string">&#x27;-t&#x27;</span>, <span class="hljs-string">&#x27;--title&#x27;</span>, type=str, default=<span class="hljs-string">&#x27;&#x27;</span>, required=<span class="hljs-literal">False</span>)args = parser.parse_args()<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(args, <span class="hljs-string">&#x27;func&#x27;</span>):    args.func = funcargs.func(args)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>使用记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>已知前（后）序及中序遍历，求后（前）序</title>
    <link href="/2020/10/14/%E5%B7%B2%E7%9F%A5%E5%89%8D%EF%BC%88%E5%90%8E%EF%BC%89%E5%BA%8F%E5%8F%8A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E5%90%8E%EF%BC%88%E5%89%8D%EF%BC%89%E5%BA%8F/"/>
    <url>/2020/10/14/%E5%B7%B2%E7%9F%A5%E5%89%8D%EF%BC%88%E5%90%8E%EF%BC%89%E5%BA%8F%E5%8F%8A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E5%90%8E%EF%BC%88%E5%89%8D%EF%BC%89%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>已知二叉树的前/后序及中序遍历，求后/前序遍历。</p><p>典型题目：已知二叉树中序遍历为ADEFGHMZ，后序遍历为AEFDHZMG，求前序遍历。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前中后序列遍历的基本概念 =&gt; 前中后序遍历的规律 =&gt; 算法思路</p><h3 id="前中后序遍历的基本概念"><a href="#前中后序遍历的基本概念" class="headerlink" title="前中后序遍历的基本概念"></a>前中后序遍历的基本概念</h3><pre><code class="hljs C">  P / \L   R</code></pre><p>前序（pre-order）: PLR<br>中序（in-order）: LPR<br>后序（post-order）: LRP</p><p>序指的是根节点在左右子树中的位置：根左右、左根右、左右根。</p><h3 id="前中后序列遍历的规律"><a href="#前中后序列遍历的规律" class="headerlink" title="前中后序列遍历的规律"></a>前中后序列遍历的规律</h3><ul><li>前序遍历：如果在同一颗树内，最前边的节点是根节点。</li><li>中序遍历：如果在同一颗树内，根左边的是左子树，根右边的是右子树。</li><li>后序遍历：如果在同一颗树内，最后边的节点是根节点。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>通过前序（后序）遍历，找到树的根节点。</li><li>通过根节点及中序遍历，划分左右子树。</li><li>对左右子树递归进行步骤1、2，直到子树划分完毕。</li></ol><p>总结：找根节点、划分左右子树。</p><h4 id="人型电脑实验"><a href="#人型电脑实验" class="headerlink" title="人型电脑实验"></a>人型电脑实验</h4><p>已知二叉树中序遍历为ADEFGHMZ，后序遍历为AEFDHZMG，求前序遍历。</p><h5 id="解"><a href="#解" class="headerlink" title="解"></a>解</h5><p>1th，看后序得知根节点为G，看中序划分左子树ADEF和右子树HMZ<br><pre><code class="hljs latex">    G  /   <span class="hljs-tag">\</span>ADEF  HMZ</code></pre></p><p>2th<br><pre><code class="hljs dns">  D / \<span class="hljs-keyword">A</span>  EF</code></pre></p><p>3th<br><pre><code class="hljs mathematica">  F /<span class="hljs-keyword">E</span></code></pre></p><p>4th<br><pre><code class="hljs latex">  M / <span class="hljs-tag">\</span>H   Z</code></pre></p><p>tree</p><pre><code class="hljs latex">     G   /   <span class="hljs-tag">\</span>  D     M / <span class="hljs-tag">\<span class="hljs-name"> </span></span>  / <span class="hljs-tag">\</span>A   F H   Z   /  E</code></pre><p>故前序遍历为：GDAFEMHZ</p><h2 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs matlab">v bt_preorder(t, op)v bt_inorder(t, op)v bt_postorder(t, op)t bt_solve_from_inpostorder(in, in_len post, post_len)&#123;    r = post[post_len<span class="hljs-number">-1</span>]    <span class="hljs-built_in">find</span> in[<span class="hljs-built_in">i</span>] == r    r-&gt;left = bt_solve_from_inpostorder(in, <span class="hljs-built_in">i</span>, post, <span class="hljs-built_in">i</span>)    r-&gt;right = bt_solve_from_inpostorder(in+<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>, in_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,         post+<span class="hljs-built_in">i</span>, post_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> r;&#125;t bt_solve_from_inpreorder(in, in_len pre, pre_len)&#123;    r = pre[<span class="hljs-number">0</span>]    <span class="hljs-built_in">find</span> in[<span class="hljs-built_in">i</span>] == r    r-&gt;left = bt_solve_from_inpreorder(in, <span class="hljs-built_in">i</span>, pre+<span class="hljs-number">1</span>, <span class="hljs-built_in">i</span>)    r-&gt;right = bt_solve_from_inpreorder(in+<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>, in_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,         pre+<span class="hljs-number">1</span>+<span class="hljs-built_in">i</span>, pre_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> r;&#125;</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> key;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span> *<span class="hljs-title">left</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span> *<span class="hljs-title">right</span>;</span>&#125; <span class="hljs-keyword">bt_t</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_preorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        op(bt);        bt_preorder(bt-&gt;left, op);        bt_preorder(bt-&gt;right, op);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_inorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        bt_inorder(bt-&gt;left, op);        op(bt);        bt_inorder(bt-&gt;right, op);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_postorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        bt_postorder(bt-&gt;left, op);        bt_postorder(bt-&gt;right, op);        op(bt);    &#125;&#125;<span class="hljs-keyword">bt_t</span> *bt_solve_from_inpostorder(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int</span> in_len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *post, <span class="hljs-keyword">int</span> post_len)&#123;    <span class="hljs-keyword">if</span> (post_len &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">bt_t</span> *r = (<span class="hljs-keyword">bt_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(bt));        assert(r);        r-&gt;key = post[post_len<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; in_len &amp;&amp; in[i] != r-&gt;key; ++i);        r-&gt;left = bt_solve_from_inpostorder(in, i, post, i);        r-&gt;right = bt_solve_from_inpostorder(in+i+<span class="hljs-number">1</span>, in_len-i<span class="hljs-number">-1</span>,             post+i, post_len-i<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">bt_t</span> *bt_solve_from_inpreorder(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int</span> in_len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pre, <span class="hljs-keyword">int</span> pre_len)&#123;    <span class="hljs-keyword">if</span> (pre_len &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">bt_t</span> *r = (<span class="hljs-keyword">bt_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(bt));        assert(r);        r-&gt;key = pre[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; in_len &amp;&amp; in[i] != r-&gt;key; ++i);        r-&gt;left = bt_solve_from_inpreorder(in, i, pre+<span class="hljs-number">1</span>, i);        r-&gt;right = bt_solve_from_inpreorder(in+i+<span class="hljs-number">1</span>, in_len-i<span class="hljs-number">-1</span>,             pre+<span class="hljs-number">1</span>+i, pre_len-i<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_node_print</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, bt-&gt;key);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in = <span class="hljs-string">&quot;ADEFGHMZ&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *post = <span class="hljs-string">&quot;AEFDHZMG&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pre = <span class="hljs-string">&quot;GDAFEMHZ&quot;</span>;    <span class="hljs-keyword">bt_t</span> *bt = bt_solve_from_inpostorder(in, <span class="hljs-number">8</span>, post, <span class="hljs-number">8</span>);    bt_preorder(bt, bt_node_print);    bt_postorder(bt, (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">bt_t</span> *))<span class="hljs-built_in">free</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        bt = bt_solve_from_inpreorder(in, <span class="hljs-number">8</span>, pre, <span class="hljs-number">8</span>);    bt_postorder(bt, bt_node_print);    bt_postorder(bt, (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">bt_t</span> *))<span class="hljs-built_in">free</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake笔记</title>
    <link href="/2020/10/12/CMake%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/12/CMake%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake笔记"><a href="#CMake笔记" class="headerlink" title="CMake笔记"></a>CMake笔记</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量设置与打印"><a href="#变量设置与打印" class="headerlink" title="变量设置与打印"></a>变量设置与打印</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/set.html">set</a>命令设置变量名及其对应值，通过<code>$&#123;变量名&#125;</code>的方式引用变量。<a href="https://cmake.org/cmake/help/v3.18/command/message.html">message</a>可打印信息。</p><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(VAR_A <span class="hljs-number">100</span>)<span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;VAR_A&#125;</span>)</code></pre><p>输出：</p><pre><code class="hljs Bash">...-- 100...</code></pre><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>同大多数编程语言一样，<a href="https://cmake.org/cmake/help/v3.18/command/if.html">if</a>用于条件控制。需要注意的是，cmake中<code>&lt;condition&gt;</code>的写法会使用<code>EQUAL</code>, <code>LESS</code>, <code>LESS_EQUAL</code>等关键字，判定为TRUE的条件可能有所复杂。</p><pre><code class="hljs CMake"><span class="hljs-keyword">if</span>(&lt;condition&gt;)    &lt;commands&gt;<span class="hljs-keyword">elseif</span>(&lt;condition&gt;)    &lt;commands&gt;<span class="hljs-keyword">else</span>()    &lt;commands&gt;<span class="hljs-keyword">endif</span>()</code></pre><h3 id="foreach与list"><a href="#foreach与list" class="headerlink" title="foreach与list"></a>foreach与list</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/list.html">list</a>是cmake中一种类似数组的结构（元素可以不同），<a href="https://cmake.org/cmake/help/v3.18/command/foreach.html">foreach</a>命令则用于遍历操作。</p><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">1</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">2</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">3</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">4</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">5</span>)<span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;LIST_A&#125;</span>)<span class="hljs-keyword">foreach</span>(X IN LISTS LIST_A)    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;X=$&#123;X&#125;&quot;</span>)<span class="hljs-keyword">endforeach</span>()</code></pre><p>输出：<br><pre><code class="hljs Bash">...-- 12345-- X=1-- X=2-- X=3-- X=4-- X=5...</code></pre></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/function.html">function</a>指令可定义函数。</p><pre><code class="hljs CMake"><span class="hljs-keyword">function</span>(F1 <span class="hljs-keyword">list</span>)    <span class="hljs-keyword">foreach</span>(X IN LISTS <span class="hljs-variable">$&#123;list&#125;</span>)        <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;X=$&#123;X&#125;&quot;</span>)    <span class="hljs-keyword">endforeach</span>()<span class="hljs-keyword">endfunction</span>()<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">1</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">2</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">3</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">4</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">5</span>)F1(LIST_A)</code></pre><p>输出：</p><pre><code class="hljs Bash">-- X=1-- X=2-- X=3-- X=4-- X=5</code></pre><h2 id="E1-1-Hello-World"><a href="#E1-1-Hello-World" class="headerlink" title="E1.1 Hello World"></a>E1.1 Hello World</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>通过CMake编译、构建一个Hello World程序</li></ul><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>最简单的CMake工程目录如下所示</p><pre><code class="hljs shell">.├─ CMakeLists.txt└─ main.cpp</code></pre><p>CMakeLists.txt内容如下</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">add_executable</span>(main main.cpp)</code></pre><p>main.cpp内容如下</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在工程目录中新建build目录，然后进入build目录下执行<code>cmake ..</code>，再执行<code>cmake --build .</code></p><blockquote><p>Linux下用<code>cmake ..</code>和<code>make</code>指令进行构建</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>project(CMake_Note)</code>指定项目名称，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/project.html">project</a></p></li><li><p><code>add_executable(main main.cpp)</code>添加一个可执行程序Target，将main.cpp编译为可执行程序，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/add_executable.html">add_executable</a></p></li></ul><h2 id="E1-2-生成动态库与静态库"><a href="#E1-2-生成动态库与静态库" class="headerlink" title="E1.2 生成动态库与静态库"></a>E1.2 生成动态库与静态库</h2><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><ul><li>通过CMake生成构建静态库与动态库</li></ul><h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><p>在E1.1基础上新增hello.h及hello.cpp文件，其内容分别如下</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HELLO_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_H_</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// HELLO_H_</span></span></code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello %s!\n&quot;</span>, what);&#125;</code></pre><p>将CMakeLists.txt与main.cpp分别修改为以下内容</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    hello(<span class="hljs-string">&quot;Function&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>add_library(hello hello.cpp)</code>添加一个库文件Target，将hello.cpp编译为库文件，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/add_library.html">add_executable</a></p></li><li><p>使用<code>add_library(hello STATIC hello.cpp)</code>可以强制生成静态库，<code>add_library(hello SHARED hello.cpp)</code>同理。具体见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html#binary-library-types">Binary Library Types</a></p></li><li><p><code>target_link_libraries(main hello)</code>表示将hello链接到main中，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/target_link_libraries.html">target_link_libraries</a>。需要注意的是，<code>target_link_libraries</code>在添加Target之后，在本例子中的体现是该语句在<code>add_executable(main main.cpp)</code>之后。</p></li></ul><h2 id="E1-3-改变输出文件路径"><a href="#E1-3-改变输出文件路径" class="headerlink" title="E1.3 改变输出文件路径"></a>E1.3 改变输出文件路径</h2><h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><ul><li>将可执行程序与库文件分别输出到bin与lib文件夹</li></ul><h3 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h3><p>在E1.2基础上将CMakeLists.txt修改为以下内容</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ul><li><p>基本上，<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>指定可执行文件的输出路径，<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>指定库文件的输出路径。</p></li><li><p><code>CMAKE_BINARY_DIR</code>表示执行<code>cmake</code>命令时所在的路径，在本例子中为<code>build</code>目录。还有一个<code>CMAKE_SOURCE_DIR</code>表示工程源码路径，在本例子中为<code>CMakeLists.txt</code>所在路径。另外还有两个类似的目录，<code>CMAKE_CURRENT_BINARY_DIR</code>与<code>CMAKE_CURRENT_SOURCE_DIR</code>，当cmake工程发生嵌套时，不带CURRENT的变量指顶层CMake工程，带CURRENT的则指当前CMake工程。具体定义见<a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_SOURCE_DIR.html#variable:CMAKE_SOURCE_DIR">CMAKE_SOURCE_DIR</a>。</p></li><li><p>不同平台下，输出文件的路径由不同的变量控制可能不同。例如window下与linux下的动态库文件，在window下，动态库输出路径由<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>指定，linux下则由<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>指定，具体解释见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html#output-artifacts">Output Artifacts</a></p></li><li><p>window平台下，cmake可能会根据不同的构建类型（Debug或Release）将输出文件归类到对应类型的文件夹下，为避免该情况，可将上述CMakeLists.txt新增的内容改为</p>  <pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)</code></pre><p>  参考<a href="https://stackoverflow.com/questions/543203/cmake-runtime-output-directory-on-windows">CMake Runtime Output Directory On Windows</a></p></li></ul><h2 id="E1-4-分离可执行程序与库文件"><a href="#E1-4-分离可执行程序与库文件" class="headerlink" title="E1.4 分离可执行程序与库文件"></a>E1.4 分离可执行程序与库文件</h2><h3 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h3><ul><li>了解如何使用add_subdirectory直接将库的源码工程导入到应用（APP）工程，了解CMake的Target概念</li></ul><h3 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h3><p>在E1.3基础上分离可执行程序工程与库工程，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello│   ├─ CMakeLists.txt│   ├─ hello.h│   └─ hello.cpp└─ main.cpp</code></pre><p>CMakeLists.txt内容为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(MAIN)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">add_subdirectory</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><p>hello/CMakeLists.txt内容为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;)</code></pre><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><ul><li><p>hello文件夹中本身是一个独立的CMake工程（HELLO工程）</p></li><li><p><code>add_subdirectory(lib)</code>将hello库的CMake源码工程直接导入到当前工程（MAIN工程）中，所以当前工程可以直接引用到<code>hello</code>Target，<code>add_executable</code>，<code>add_library</code>都能产生Target，如HELLO工程中产生了<code>hello</code>Target，MAIN工程中产生了<code>main</code>Target，且<code>main</code>依赖<code>hello</code>。<a href="https://cmake.org/cmake/help/v3.18/command/add_subdirectory.html">add_subdirectory</a>是引用外部库的方式之一（通过直接引入库源码的方式）。</p></li><li><p><code>target_include_directories(hello $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)</code>将指定目录绑定到指定Target中。在HELLO工程中，<code>target_include_directories</code>将hello库的源码目录（即<code>CMAKE_CURRENT_SOURCE_DIR</code>-&gt;hello）绑定到<code>hello</code>Target上，所以当链接<code>hello</code>Target时，<code>main</code>Target也以该目录作为include目录，所以main.cpp中能直接<code>#include &quot;hello.h&quot;</code>。具体见<a href="https://cmake.org/cmake/help/v3.18/command/target_include_directories.html">target_include_directories</a>。在HELLO工程中，<code>target_include_directories</code>使用了PUBLIC进行修饰，PUBLIC后的目录可以对外传递。当指定为PRIVATE时，目录不会对外传递，所以这种情况下，main.cpp中的<code>#include &quot;hello.h&quot;</code>将报出找不到头文件的错误。除了PUBLIC外，例子中还用了<code>$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;</code>进行修饰，表示只有在构建（Build）时才会传递指定的目录。所以，当MAIN工程不是直接包含HELLO工程源码来引用<code>hello</code>Target时（如hello库已经以二进制的形式安装在本地环境中，此时需要使用<code>$&lt;INSTALL_INTERFACE:...&gt;</code>），该指定目录不会被传递给<code>main</code>Target。具体见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-generator-expressions.7.html#output-related-expressions">Output-Related Expressions</a></p><blockquote><p><strong>Target自身带有某些属性，如该Target包含了哪些include目录，链接了哪些Target。某些Target属性会传递到引用该Target的Target上</strong>。</p></blockquote></li></ul><h2 id="E1-5-configure-file用法"><a href="#E1-5-configure-file用法" class="headerlink" title="E1.5 configure_file用法"></a>E1.5 configure_file用法</h2><h3 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h3><ul><li>熟悉模板配置，实现通过CMake变量控制生成不同的源文件</li></ul><h3 id="例程-4"><a href="#例程-4" class="headerlink" title="例程"></a>例程</h3><p>在E1.4中的hello目录下添加config.h.in文件，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello│   ├─ CMakeLists.txt│   ├─ config.h.in│   ├─ hello.h│   └─ hello.cpp└─ main.cpp</code></pre><p>hello/config.h.in</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _HELLO_CONFIG_H_</span><span class="hljs-meta">#cmakedefine HELLO_VERSION <span class="hljs-meta-string">&quot;@HELLO_VERSION@&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _HELLO_CONFIG_H_</span></span></code></pre><p>修改hello/CMakeLists.txt文件为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">set</span>(HELLO_VERSION_MAJOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_MINOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_PATCH <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION_MAJOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_MINOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_PATCH&#125;</span>)<span class="hljs-keyword">configure_file</span>(config.h.in <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h&quot;</span> @ONLY)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;    PRIVATE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>&gt;)</code></pre><p>修改hello/hello.cpp文件为</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;config.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello %s!, version: %s\n&quot;</span>, what, HELLO_VERSION);&#125;</code></pre><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><ul><li><p><a href="https://cmake.org/cmake/help/v3.18/command/configure_file.html">configure_file</a>将config.h.in模板文件生成为config.h文件，其内容最终如下所示</p>  <pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _HELLO_CONFIG_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_VERSION <span class="hljs-meta-string">&quot;1.1.1&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _HELLO_CONFIG_H_</span></span></code></pre></li><li><p>由于config.h生成在<code>CMAKE_CURRENT_BINARY_DIR</code>目录中，故<code>target_include_directories</code>中需新增了一个include目录，并且设置为PRIVATE，防止该include目录传递到其他Target上。</p></li></ul><h2 id="E1-6-直接引用二进制库"><a href="#E1-6-直接引用二进制库" class="headerlink" title="E1.6 直接引用二进制库"></a>E1.6 直接引用二进制库</h2><h3 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h3><ul><li>了解CMake直接引用二进制库的方法</li></ul><h3 id="例程-5"><a href="#例程-5" class="headerlink" title="例程"></a>例程</h3><p>在E1.5的基础上，新建cmake文件，并将之前生成的二进制库和hello.h拷贝到其中。工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello # 此目录在本工程中无作用├─ cmake│   ├─ hello.h│   └─ hello.lib # linux下可能会其他类型的文件，如*.so└─ main.cpp</code></pre><p>修改CMakeLists.txt为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(MAIN)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">include_directories</span>(cmake)<span class="hljs-keyword">link_directories</span>(cmake)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><h3 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>include_directories(cmake)</code>指定了MAIN工程的include文件夹，使得CMake在构建、编译时，去这些目录下查找相应的头文件。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/include_directories.html">include_directories</a></p></li><li><p><code>link_directories(cmake)</code>指定MAIN工程所依赖的库的路径，使得CMake在构建、编译时，去这些目录下查找需要的库。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/include_directories.html">link_directories</a></p></li></ul><h2 id="E1-7-通过Module模式的find-package引用二进制库"><a href="#E1-7-通过Module模式的find-package引用二进制库" class="headerlink" title="E1.7 通过Module模式的find_package引用二进制库"></a>E1.7 通过Module模式的find_package引用二进制库</h2><h3 id="目的-6"><a href="#目的-6" class="headerlink" title="目的"></a>目的</h3><ul><li><p>了解通过Module模式的find_package引用二进制库</p></li><li><p>了解find_package的用法</p></li><li><p>了解find_package的module模式</p></li></ul><h3 id="例程-6"><a href="#例程-6" class="headerlink" title="例程"></a>例程</h3><p>在E1.6的基础上，在cmake文件夹中新增Findhello.cmake文件，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello # 此目录在本工程中无作用├─ cmake│   ├─ Findhello.cmake│   ├─ hello.h│   └─ hello.lib # linux下可能会其他类型的文件，如*.so└─ main.cpp</code></pre><p>cmake/Findhello.cmake</p><pre><code class="hljs CMake"><span class="hljs-keyword">find_path</span>(HELLO_INCLUDES hello.h <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">find_library</span>(HELLO_LIBRARIES hello.lib <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">if</span>(HELLO_INCLUDES)    <span class="hljs-keyword">set</span>(hello_FOUND <span class="hljs-number">1</span>)<span class="hljs-keyword">endif</span>()</code></pre><p>修改CMakeLists.txt为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(main)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)<span class="hljs-keyword">find_package</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;HELLO_LIBRARIES&#125;</span>)<span class="hljs-keyword">target_include_directories</span>(main PRIVATE <span class="hljs-variable">$&#123;HELLO_INCLUDES&#125;</span>)</code></pre><h3 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>find_package(hello)</code>根据<a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_MODULE_PATH.html">CMAKE_MODULE_PATH</a>中指定的路径找到<code>Findhello.cmake</code>文件，并从该文件中获取hello库相关的构建信息。具体用法见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#find-module-packages">find-module-packages</a>。</p></li><li><p><a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_CURRENT_LIST_DIR.html">CMAKE_CURRENT_LIST_DIR</a>指当前被处理的cmake文件所在目录。</p></li><li><p><code>find_path(HELLO_INCLUDES hello.h $&#123;CMAKE_CURRENT_LIST_DIR&#125;)</code>在给定目录下查找某个文件，如果找到便将该目录赋值给指定变量，在本例子中指在<code>$&#123;CMAKE_CURRENT_LIST_DIR&#125;</code>指定的目录下查找<code>hello.h</code>文件，如果找到则赋值给<code>HELLO_INCLUDES</code>变量。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/find_path.html">find_path</a></p></li><li><p><code>find_library(HELLO_LIBRARIES hello.lib $&#123;CMAKE_CURRENT_LIST_DIR&#125;)</code>的用法和<code>find_path</code>的类似，只是被赋值的变量中包含的是库文件本身，而非库文件所在的目录。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/find_library.html">find_library</a></p></li><li><p>CMake Module本身是一系列FindXXX.cmake文件，这些文件包含了库的信息（如include目录，library所在目录等），通过这些FindXXX.cmake文件和find_package命令，可以解耦引用了库的cmake工程（即应用工程中不显式存在库的目录信息）。当库稳定后，库的维护者甚至可以向cmake添加自己制作的库的FindXXX.cmake文件，如此随cmake部署时自动部署。一些随cmake安装时附带的见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-modules.7.html">Moudles</a>。</p></li></ul><h2 id="E1-8-创建Config-file-Package"><a href="#E1-8-创建Config-file-Package" class="headerlink" title="E1.8 创建Config-file Package"></a>E1.8 创建Config-file Package</h2><h3 id="目的-7"><a href="#目的-7" class="headerlink" title="目的"></a>目的</h3><ul><li><p>了解CMake的<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#config-file-packages">Config-file Package</a></p></li><li><p>了解通过Config模式的find_package引用二进制库</p></li></ul><h3 id="例程-7"><a href="#例程-7" class="headerlink" title="例程"></a>例程</h3><p>工程目录</p><pre><code class="hljs shell">. # main 工程├─ CMakeLists.txt├─ hello # hello 工程│   ├─ CMakeLists.txt│   ├─ cmake│   │   ├─ config.h.in│   │   ├─ hello-config-version.cmake.in│   │   └─ hello-config.cmake.in│   ├─ hello.h│   └─ hello.cpp├─ install└─ main.cpp</code></pre><p>hello/CMakeLists.txt</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">set</span>(HELLO_VERSION_MAJOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_MINOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_PATCH <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION_MAJOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_MINOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_PATCH&#125;</span>)<span class="hljs-keyword">configure_file</span>(cmake/config.h.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span> @ONLY)<span class="hljs-keyword">configure_file</span>(cmake/hello-config-version.cmake.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config-version.cmake&quot;</span> @ONLY)<span class="hljs-keyword">configure_file</span>(cmake/hello-config.cmake.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config.cmake&quot;</span> @ONLY)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;        $&lt;INSTALL_INTERFACE:<span class="hljs-keyword">include</span>/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>&gt;    PRIVATE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>&gt;)<span class="hljs-keyword">install</span>(TARGETS hello     <span class="hljs-keyword">EXPORT</span> hello    DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(FILES hello.h DESTINATION <span class="hljs-keyword">include</span>/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>/<span class="hljs-variable">$&#123;HELLO_INCLUDE_PREFIX&#125;</span>)<span class="hljs-keyword">install</span>(FILES <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config.cmake&quot;</span> DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(FILES <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config-version.cmake&quot;</span> DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(<span class="hljs-keyword">EXPORT</span> hello DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-comment"># 需要安装NSIS</span><span class="hljs-comment"># cpack -C Debug</span><span class="hljs-keyword">set</span>(CPACK_GENERATOR NSIS)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_NAME <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="hljs-string">&quot;No vendor&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_DESCRIPTION_SUMMARY <span class="hljs-string">&quot;No description&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_INSTALL_DIRECTORY <span class="hljs-string">&quot;/usr/local&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_NSIS_MODIFY_PATH <span class="hljs-keyword">ON</span>)<span class="hljs-keyword">include</span>(CPack)</code></pre><p>hello/cmake/hello-config.cmake.in</p><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">include</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/hello.cmake)<span class="hljs-keyword">set</span>(hello_FOUND <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_LIBRARIES hello)</code></pre><p>hello/cmake/hello-config-version.cmake.in，其中被@@包围的部分为模板变量，最后会被configure_file替换为实际值。</p><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(PACKAGE_VERSION @HELLO_VERSION@)<span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MAJOR&#125;&quot;</span> <span class="hljs-keyword">EQUAL</span> <span class="hljs-string">&quot;@HELLO_VERSION_MAJOR@&quot;</span>)    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MINOR&#125;&quot;</span> <span class="hljs-keyword">EQUAL</span> <span class="hljs-string">&quot;@HELLO_VERSION_MINOR@&quot;</span>)        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_EXACT <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">elseif</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MINOR&#125;&quot;</span> <span class="hljs-keyword">LESS</span> <span class="hljs-string">&quot;@HELLO_VERSION_MINOR@&quot;</span>)        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_COMPATIBLE <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">else</span>()        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_UNSUITABLE <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">endif</span>()<span class="hljs-keyword">elseif</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION&#125;&quot;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Using hello @HELLO_VERSION@&quot;</span>)    <span class="hljs-keyword">set</span>(PACKAGE_VERSION_COMPATIBLE <span class="hljs-keyword">TRUE</span>)<span class="hljs-keyword">else</span>()    <span class="hljs-keyword">set</span>(PACKAGE_VERSION_UNSUITABLE <span class="hljs-keyword">TRUE</span>)<span class="hljs-keyword">endif</span>()</code></pre><p>进入hello目录下，新建build目录并进入，依次执行<code>cmake ..</code>，<code>cmake --build .</code>,<code>cpack -C Debug</code>，双击生成的<code>hello-1.1.1-win32.exe</code>安装包，将其安装到install目录下。安装完毕后会有如下目录</p><pre><code class="hljs shell">....  ├─ install│   ├─ include│   │   └─ hello-1.1.1│   │       └─ hello.h│   └─ lib│       └─ hello-1.1.1│           ├─ hello.lib│           ├─ hello.cmake # 自动生成的Target导出数据│           ├─ hello-config.cmake│           └─ hello-config-version.cmake...</code></pre><p>CMakeLists.txt</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">install</span>)<span class="hljs-keyword">find_package</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;HELLO_LIBRARIES&#125;</span>)</code></pre><p>返回main工程，用CMake构建</p><h3 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h3><ul><li><p><a href="https://cmake.org/cmake/help/v3.18/command/install.html">install</a>用于安装、导出cmake Target。<code>install(TARGETS hello EXPORT hello DESTINATION lib/hello-$&#123;HELLO_VERSION&#125;)</code>创建了hello工程中需要导出的cmake Target，这些Target记录在自动生成的hello.cmake文件中（hello.cmake的hello来源于EXPORT后头的hello，TARGETS后的hello指向的是add_library时产生的hello）。<code>install(EXPORT hello DESTINATION lib/hello-$&#123;HELLO_VERSION&#125;)</code>则实际和<code>install(FILES ...)</code>一样，将指定的文件拷贝到对应的目录中。</p></li><li><p>cpack为cmake提供的跨平台打包工具，其间接调用各个平台下的工具对软件库进行打包（如本例子中使用window下的NSIS）。具体用法见<a href="https://cmake.org/cmake/help/v3.18/manual/cpack.1.html">cpack</a>。</p><blockquote><p>可使用下面的片段生成deb包</p>  <pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CPACK_GENERATOR <span class="hljs-string">&quot;DEB&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_NAME <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="hljs-string">&quot;No vendor&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_DESCRIPTION_SUMMARY <span class="hljs-string">&quot;No description&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_INSTALL_DIRECTORY <span class="hljs-string">&quot;/usr/local&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_RPM_PACKAGE_GROUP <span class="hljs-string">&quot;group name&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_RPM_PACKAGE_LICENSE <span class="hljs-string">&quot;license&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_CONTACT <span class="hljs-string">&quot;email or phone number&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class="hljs-string">&quot;maintainer name&quot;</span>)<span class="hljs-keyword">include</span>(CPack)</code></pre></blockquote></li><li><p>build interface 与 install interface。Target的两种接口，Target具有某些属性，如include目录。在本例程中main Target依赖于hello Target。hello Target的公开的include属性中分别指定了build时的include目录和install后的include目录，两个include目录是不同的。当main工程通过<strong>直接包含hello工程源码来引用hello Target</strong>时，hello Target的include属性中具有<code>$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;</code>指定的include目录。当main工程通过<strong>find_package的方式引用已经安装好的hello Target</strong>时，hello Target的include属性中具有<code>$&lt;INSTALL_INTERFACE:include/hello-$&#123;HELLO_VERSION&#125;&gt;</code>指定的include目录。</p><blockquote><p>重点区别这两种interface，体会不同interface的作用</p></blockquote></li><li><p>Target的通过install命令导出，将cmake编译过程记录在某个文件中，跟随库一起发布。其他某个A工程使用find_package引用该库时，库的编译过程数据将作为输入，传递到A工程的构建过程。</p></li><li><p>hello-config-version.cmake.in文件是cmake的包版本文件（<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#package-version-file">Package Version File</a>），其命名形式一般为foo-config-version.cmake或FooConfigVersion.cmake（其中Foo为包名）。该文件一般随着包一起部署（安装），在该文件中可以通过<code>PACKAGE_FIND_VERSION</code>、<code>PACKAGE_FIND_VERSION_MAJOR</code>、<code>PACKAGE_FIND_VERSION_MINOR</code>、<code>PACKAGE_VERSION_COMPATIBLE</code>等变量来对包进行版本管理。一般在某个工程中find_package(Foo 1.1.1)后，<code>PACKAGE_FIND_VERSION</code>、<code>PACKAGE_FIND_VERSION_MAJOR</code>、<code>PACKAGE_FIND_VERSION_MINOR</code>等变量会被赋值为对应值，在判定兼容性后，设置<code>PACKAGE_VERSION_COMPATIBLE</code>为TRUE或FALSE来控制包是否可用。</p></li><li><p>hello-config.cmake.in文件是cmake的包配置文件，一般通过<code>install(EXPORT)</code>命令导出Target后会自动生成一个包配置文件，然后用hello-config.cmake.in直接包含该文件即可。本例中自动生成的文件为hello.cmake。更具体的描述见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#creating-a-package-configuration-file">Creating a Package Configuration File</a></p></li></ul><h2 id="一些需求"><a href="#一些需求" class="headerlink" title="一些需求"></a>一些需求</h2><h3 id="仅头文件库"><a href="#仅头文件库" class="headerlink" title="仅头文件库"></a>仅头文件库</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>创建一个仅包含头文件的库</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(library_a INTERFACE)<span class="hljs-keyword">target_include_directories</span>(library_a     INTERFACE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;        $&lt;INSTALL_INTERFACE:<span class="hljs-keyword">include</span>/library_a-<span class="hljs-variable">$&#123;LIBRARY_A_VERSION&#125;</span>&gt;)</code></pre><h3 id="拷贝库的DLL到可执行目标目录"><a href="#拷贝库的DLL到可执行目标目录" class="headerlink" title="拷贝库的DLL到可执行目标目录"></a>拷贝库的DLL到可执行目标目录</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>window平台下，应用工程引用某个动态库后，希望能够通过某种方式自动将DLL拷贝到可执行文件所在的目录下</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>在库的xxx-config.cmake.in中定义以下函数，供外部工程调用</p><pre><code class="hljs CMake"><span class="hljs-keyword">function</span>(XXX_COPY_DLL <span class="hljs-keyword">target</span>)    <span class="hljs-keyword">set</span>(XXX_DLL_FILE  <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/xxx.dll CACHE INTERNAL <span class="hljs-string">&quot;XXX_DLL_FILE&quot;</span>)    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;target&#125;</span> POST_BUILD        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo copy <span class="hljs-variable">$&#123;XXX_DLL_FILE&#125;</span> to $&lt;TARGET_FILE_DIR:<span class="hljs-variable">$&#123;target&#125;</span>&gt;        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="hljs-variable">$&#123;XXX_DLL_FILE&#125;</span> $&lt;TARGET_FILE_DIR:<span class="hljs-variable">$&#123;target&#125;</span>&gt;    )<span class="hljs-keyword">endfunction</span>()</code></pre><p>在应用工程CMakeLists.txt调用XXX_COPY_DLL</p><pre><code class="hljs CMake"><span class="hljs-keyword">add_executable</span>(app ...)<span class="hljs-keyword">target_link_libraries</span>(app xxx)XXX_COPY_DLL(app)</code></pre><h3 id="为已发布的库文件创建Target"><a href="#为已发布的库文件创建Target" class="headerlink" title="为已发布的库文件创建Target"></a>为已发布的库文件创建Target</h3><h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><p>在没有库源码的情况下针对库创建一个cmake Target</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建一个fake.cpp文件，实现空接口。构建完成之后用实际的库文件替换生成的库文件。</p><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(real SHARED fake.cpp)<span class="hljs-keyword">if</span>(UNIX)    <span class="hljs-keyword">add_custom_target</span>(cheat ALL        <span class="hljs-keyword">COMMAND</span> cp <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/real.so        <span class="hljs-comment">#</span>        <span class="hljs-comment"># 这里不能简单的用c. copy之后, ldd查看测试程序的依赖时显示real路径有问题</span>        <span class="hljs-comment"># 不知道为什么copy之后, rpath就变了</span>        <span class="hljs-comment">#</span>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-keyword">install</span> <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        <span class="hljs-keyword">COMMAND</span> rm <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        <span class="hljs-keyword">COMMAND</span> ln <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        DEPENDS real <span class="hljs-comment"># POST BUILD作用</span>    )         <span class="hljs-keyword">elseif</span>(WIN32)    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> controlcan POST_BUILD        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E             copy_if_different <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.dll <span class="hljs-variable">$&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY&#125;</span>/real.dll        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E             copy_if_different <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.lib <span class="hljs-variable">$&#123;CMAKE_ARCHIVE_OUTPUT_DIRECTORY&#125;</span>/real.lib    )<span class="hljs-keyword">endif</span>()</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cmake.org/cmake/help/v3.18/index.html#reference-manuals">CMake Reference Manual</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html">CMake Package</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-variables.7.html">CMake Variables</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html">CMake Build System</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-modules.7.html">CMake Modules</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-commands.7.html">CMake Command</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cpack.1.html">CPack</a><br><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">It’s Time To Do CMake Right</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>编译构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO入门</title>
    <link href="/2020/10/11/HEXO%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/11/HEXO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO笔记"><a href="#HEXO笔记" class="headerlink" title="HEXO笔记"></a>HEXO笔记</h1><p><a href="https://hexo.io/zh-cn/">HEXO</a><br><a href="https://hexo.io/zh-cn/docs/">HEXO docs</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署文件会生成到public目录下，注释掉.gitignore中public/，使其一同被push到仓库中。</p><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>创建文章时，文章最上方最上方以<code>---</code>分隔的区域被称为Front-matter，Front-matter用来指定个别文件的变量。举例来说：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><span class="hljs-meta">---</span></code></pre><h2 id="为文章添加标签"><a href="#为文章添加标签" class="headerlink" title="为文章添加标签"></a>为文章添加标签</h2><p>在Front-matter的tags下添加，样例：</p><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>- PS3- Games</code></pre><h2 id="主题：hexo-theme-fluid"><a href="#主题：hexo-theme-fluid" class="headerlink" title="主题：hexo-theme-fluid"></a>主题：hexo-theme-fluid</h2><p><a href="https://hexo.fluid-dev.com/">HEXO Theme Fluid</a><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">HEXO Theme Fluid Github</a></p><h3 id="创建简历页"><a href="#创建简历页" class="headerlink" title="创建简历页"></a>创建简历页</h3><ol><li><p>在<code>themes/hexo-theme-fluid/_config.yml</code>中</p><ol><li><p>搜索<code>nav</code>，在about上头添加一行</p> <pre><code class="hljs yaml"><span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;resume&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/resume/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span> &#125;</code></pre></li><li><p>添加如下内容</p><pre><code class="hljs yaml"><span class="hljs-comment">#---------------------------</span><span class="hljs-comment"># 简历页</span><span class="hljs-comment"># Resume Page</span><span class="hljs-comment">#---------------------------</span><span class="hljs-attr">resume:</span>    <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span>    <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># available: 0 - 100</span>    <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span>  <span class="hljs-comment"># available: 0 - 1.0</span>    <span class="hljs-attr">subtitle:</span>  <span class="hljs-comment"># 打字机内容</span></code></pre></li></ol></li><li><p>在<code>themes/hexo-theme-fluid/languages/zh-CN.yml</code>中搜索添加</p> <pre><code class="hljs yaml"><span class="hljs-attr">resume:</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">简历</span>  <span class="hljs-attr">subtitle:</span> <span class="hljs-string">简历</span></code></pre></li><li><p>在<a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">内置社交图标</a>中<br> 查找合适的图标，此处选<code>icon-addrcard</code></p></li><li><p>添加resume页</p><ol><li><p>执行<code>hexo new page resume</code>创建页</p></li><li><p>复制<code>themes/hexo-theme-fluid/layout/about.ejs</code>并改名为<code>resume.ejs</code>创建resume页的layout</p></li><li><p>修改<code>resume.ejs</code>为以下内容</p> <pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;resume&quot;page.title &#x3D; theme.resume.title || __(&#39;resume.title&#39;)page.subtitle &#x3D; theme.resume.subtitle || __(&#39;resume.subtitle&#39;)page.banner_img &#x3D; theme.resume.banner_imgpage.banner_img_height &#x3D; theme.resume.banner_img_heightpage.banner_mask_alpha &#x3D; theme.resume.banner_mask_alpha%&gt;&lt;div class&#x3D;&quot;mt-5 markdown-body&quot;&gt;    &lt;%- page.content %&gt;&lt;&#x2F;div&gt;</code></pre></li><li><p>在<code>source/resume/index.md</code>中引用新添加的 <strong>resume</strong> layout</p> <pre><code class="hljs html">---title: resumedate: 2020-10-12 10:06:24layout: resume---</code></pre></li><li><p>在<code>source/resume/index.md</code>编辑简历，实验如下</p> <pre><code class="hljs vala"><span class="hljs-meta"># 简历</span></code></pre></li></ol></li></ol><h3 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h3><p>以站长身份注册一个<a href="https://tongji.baidu.com/">百度统计</a>账户，登陆后进入管理页面，新增站点。新增完毕后，在百度生成的安装代码中找到对应的key（hs?之后的字符串），将该key放到主题_config.yml中的<a href="https://hexo.fluid-dev.com/docs/guide/#%E7%BD%91%E9%A1%B5%E7%BB%9F%E8%AE%A1">web_analytics</a>部分，在<a href="https://hexo.fluid-dev.com/docs/guide/#%E5%B1%95%E7%A4%BA-pv-%E4%B8%8E-uv-%E7%BB%9F%E8%AE%A1">footer</a>中启用显示访问量的工具，在<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%97%A5%E6%9C%9F-%E5%AD%97%E6%95%B0-%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF-%E9%98%85%E8%AF%BB%E6%95%B0">post</a>启用每篇文章的阅读量显示。</p><h3 id="添加Valine评论"><a href="#添加Valine评论" class="headerlink" title="添加Valine评论"></a>添加Valine评论</h3><ol><li><p><a href="https://valine.js.org/quickstart.html">注册LeanCloud</a>。</p><blockquote><p>需实名认证</p></blockquote></li><li><p>创建应用并获取<code>App ID</code>和<code>App Key</code></p></li><li><p>在主题_config.yml的<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">post comment</a>中启用评论，并设置<code>type</code>为<code>valine</code>，在<code>valine</code>项目中配置步骤3中获取的<code>App ID</code>和<code>App Key</code>。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南</a></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/example/">操作示例</a></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/icon/">图标用法</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
