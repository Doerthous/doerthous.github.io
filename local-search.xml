<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2021/01/15/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/15/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><strong>术语</strong></p><p>Otect：八位字节（可直接理解成字节）。</p><p>TCP Segment：TCP段。</p><p>Max Segment Lifetime：MSL，TCP段最长寿命。</p><p>Connection Termination Request：CRT，连接终止请求。</p><h3 id="1-TCP的序列思想"><a href="#1-TCP的序列思想" class="headerlink" title="1 TCP的序列思想"></a>1 TCP的序列思想</h3><p>TCP为<strong>某些控制标志</strong>和<strong>用户数据中的每个octet</strong>进行编号（序列号，递增，详细编号规则说明见<strong>第3章</strong>），逻辑上类似于把用户数据拷贝进一个2^32大的环型缓冲区中。TCP通过序列化的设计，将其操作的对象（原本碎片化的用户数据）直接抽象成一个环型缓冲区。</p><p>TCP发送时，会从<strong>某个序列号</strong>开始往另一端发送数据，每次发送<strong>一段序列</strong>（本质上是一段数据）。可以对任意一个序列号进行ACK，收到一个值为X的ACK表示之前所有直到X-1的otects都已经被收到。所以接收方的ACK值也表明了发送方下次发送数据时要从哪个otect（或者说哪个序列号）开始。由于ACK的设计，随着一次次或成功或失败的发送，可以想象序列号一直向前移动，直到用户的数据被发送完毕为止，接收过程同理。</p><p>按照上述描述，每个TCP都管理了两个环型缓存区，一个用于发送数据到另一端，一个用于接收另一端的数据。如果把序列号想象为内存地址，那么一个TCP发送操作类似于把从某个内存地址开始的某段数据传给另一端。</p><pre><code class="hljs fortran">struct &#123; u8 *tx_mem; u32 seq; <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span> &#125; <span class="hljs-keyword">local</span>;struct &#123; u8 *rx_mem; u32 ack; <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span> &#125; remote;<span class="hljs-keyword">local</span>                                                            remote                       <span class="hljs-keyword">data</span>(<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq, <span class="hljs-built_in">size</span>)-&gt;                                                 remote<span class="hljs-number">.</span>ack=<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq+x                                                              (x&lt;=<span class="hljs-built_in">size</span>)                          &lt;-ack(remote<span class="hljs-number">.</span>ack)<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq=remote<span class="hljs-number">.</span>ack                       <span class="hljs-keyword">data</span>(<span class="hljs-keyword">local</span><span class="hljs-number">.</span>seq, <span class="hljs-built_in">size</span>)-&gt;                                <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span></code></pre><blockquote><p>注：<br>data(local.seq,size)-&gt;表示把<br>[local.tx_mem+local.seq, local.tx_mem+local.seq+local.size)<br>这段内存数据发送给远端。</p></blockquote><p>一个满足上述需求是段格式如下：</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|          Source Port          |       Destination Port        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                        Sequence Number                        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Acknowledgment Number                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|           Checksum            |            Reserved           |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                             Data                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+</code></pre><h3 id="2-序列重叠问题"><a href="#2-序列重叠问题" class="headerlink" title="2 序列重叠问题"></a>2 序列重叠问题</h3><p>按照正常思路，每次启动传输时，序列号应该总是从0开始，一直到size-1结束（假设要传输的数据大小为size）。然而，如果一端的TCP频繁打开、发送、关闭，又打开、发送、关闭。那么可以想象，<strong>网络中</strong>可能会存在序列号重叠但数据不同的TCP段：</p><pre><code class="hljs gherkin">0            size1|<span class="hljs-string">------------</span>||<span class="hljs-string">------</span>|0      size2</code></pre><p>为了避免这个问题，TCP每次传输时不再从序列号0开始，而是将选择和一个32bit的时钟绑定，TCP假设该时钟每4us自增1，所以序列号大约需要4.55个小时才会回到原点（重复）。由于TCP假定所有TCP段在网络中存在的时长最多不过MSL（Max Segment Lifetime），而MSL小于4.55小时，所以上述措施保证了序列号在网络中不会重复。换言之就是，TCP并非从0开始传输，而是从某个序列号开始，而这个序列号的选择和一个32bit的时钟相关，这个序列号又被称为初始序列号（ISN, Initial Sequence Number）。</p><p>然而这样一来，每次TCP传输数据前，就需要事先交换彼此当前的序列号（同步信息）：</p><pre><code class="hljs ada"><span class="hljs-number">1</span>) A <span class="hljs-comment">--&gt; B  我的序列号是 X</span><span class="hljs-number">2</span>) A &lt;<span class="hljs-comment">-- B  你的序列号是 X</span><span class="hljs-number">3</span>) A &lt;<span class="hljs-comment">-- B  我的序列号是 Y</span><span class="hljs-number">4</span>) A <span class="hljs-comment">--&gt; B  你的序列号是 Y</span></code></pre><p>其中2)和3)可以合并进行，合并后便成了TCP中著名的“三次握手”。</p><p>此时，TCP段格式中的Sequence Number有了两层含义，一是最开始提到的指示<strong>数据的传输状态</strong>的序列号，另一个是此处提到的，在传输数据之前，作为彼此交换信息的初始序列号。TCP在其段中设计了一个SYN标志，以便区分Sequence Number的两种状态。当SYN为1时，Sequence Number字段表示ISN，否则则表示传输过程中使用的序列号。同理，由于Acknowledgment Number和Sequence Number是一对对应的参数，第一个发送ISN的TCP，其报文中的Acknowledgment Number是一个无效值，为此，TCP引入ACK标志表明Acknowledgment Number的有效无效状态。</p><pre><code class="hljs tp"><span class="hljs-number">1</span>) A --&gt; B  SYN      我的序列号是 <span class="hljs-keyword">X</span><span class="hljs-number">2</span>) A &lt;-- B  SYN,ACK  你的序列号是 <span class="hljs-keyword">X</span>，我的序列号是 <span class="hljs-keyword">Y</span><span class="hljs-number">4</span>) A --&gt; B  ACK      你的序列号是 <span class="hljs-keyword">Y</span></code></pre><p>通过上述描述可知，每个TCP都有两个序列号需要维护，一个是初始发送序列号（ISS, Initial Send Sequence），此序列号由本地TCP从上述提到的32bit时钟中产生，另一个是初始接收序列号（IRS, Initial Receive Sequence），此序列号在三次握手后从远端TCP得到，是远端的ISS。</p><pre><code class="hljs applescript"><span class="hljs-keyword">local</span>   remoteISS  <span class="hljs-comment">---  IRS</span>IRS  <span class="hljs-comment">---  ISS</span></code></pre><p>TCP传输数据的过程，逻辑上就是交换彼此序列空间的过程。</p><h4 id="连接的概念"><a href="#连接的概念" class="headerlink" title="连接的概念"></a>连接的概念</h4><p>至此，在开始实际的数据传输之前，一对TCP必须交换（同步）彼此的状态，除了需要同步的状态外，TCP内部本身也有一些状态需要在数据传输前初始化，然后才能进行传输。在数据传输过程中，这些状态也需要维护。数据传输结束后还需释放这些状态占用的资源。TCP将这些状态（信息）定义为连接，在实际数据传输之前需要先建立连接，在传输结束后需要关闭连接。建立连接前与关闭连接后，TCP处于一个虚拟的CLOSED状态，因为此时TCP并不存在。</p><p>TCP的状态信息被存放在一个传输控制块（TCB, Transmission Control Block）中。TCB中可能包含：本地和远程socket信息，当前连接的安全及优先权，指向用户发送及接收缓冲区的指针，指向重传队列以及当前TCP段的指针。此外一些涉及发送和接收序列的变量也在TCB中。</p><p><strong>发送序列变量</strong></p><ul><li>SND.UNA：已发送但未被ACK的最大序列号</li><li>SND.NXT：下一次要发送的序列号</li><li>SND.WND：发送窗口</li><li>SND.UP：发送紧急指针</li><li>SND.WL1：segment sequence number used for last window update【TODO】</li><li>SND.WL2：segment acknowledgment number used for last window update【TODO】</li><li>ISS：初始发送序列号</li></ul><p>发送序列空间：</p><pre><code class="hljs angelscript">    <span class="hljs-number">1</span>         <span class="hljs-number">2</span>          <span class="hljs-number">3</span>          <span class="hljs-number">4</span>----------|----------|----------|----------        SND.UNA    SND.NXT    SND.UNA+SND.WND<span class="hljs-number">1</span> - 已经被ACK的序列号<span class="hljs-number">2</span> - 没有被ACK的序列号<span class="hljs-number">3</span> - 允许传输的序列号<span class="hljs-number">4</span> - 禁止传输的序列号</code></pre><p><strong>接收序列变量</strong></p><ul><li>RCV.NXT：下一个要接受的序列号</li><li>RCV.WND：接收窗口</li><li>RCV.UP：接收紧急指针</li><li>IRS：初始接收序列号</li></ul><p>接收序列空间：</p><pre><code class="hljs angelscript">    <span class="hljs-number">1</span>          <span class="hljs-number">2</span>          <span class="hljs-number">3</span>----------|----------|----------        RCV.NXT    RCV.NXT+RCV.WND<span class="hljs-number">1</span> - 已经被ACK的序列号<span class="hljs-number">2</span> - 允许接收的序列号<span class="hljs-number">3</span> - 尚未允许接收的序列号</code></pre><p><strong>TCP段变量</strong></p><ul><li>SEG.SEQ：段的序列号</li><li>SEG.ACK：段的Ack值</li><li>SEG.LEN：段长度</li></ul><h4 id="TCB变量创建与维护"><a href="#TCB变量创建与维护" class="headerlink" title="TCB变量创建与维护"></a>TCB变量创建与维护</h4><p>在OPEN时，初始化以下变量：</p><pre><code class="hljs ini"><span class="hljs-attr">ISS</span> = ? // 根据<span class="hljs-number">32</span>bit时钟<span class="hljs-attr">SND.UNA</span> = ISS<span class="hljs-attr">SND.NXT</span> = ISS+<span class="hljs-number">1</span><span class="hljs-attr">RCV.WND</span> = ? // 根据本地tcp配置设置</code></pre><p>在同步过程中，初始化以下变量（从对方状态信息中提取初始化数据）：</p><pre><code class="hljs ini"><span class="hljs-attr">SND.WND</span> = SYN.RCV.WND<span class="hljs-attr">IRS</span> = SYN.SEQ<span class="hljs-attr">RCV.NXT</span> = SYN.SEQ+<span class="hljs-number">1</span></code></pre><p>传输数据的过程中（基本上只要维护好SND.UNA和RCV.NXT）：</p><pre><code class="hljs x86asm">    A              B<span class="hljs-number">1</span>) A<span class="hljs-number">.</span>snd<span class="hljs-number">.</span>una &lt;--- B<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>ack <span class="hljs-number">4</span>)           =|      ^            v      |=<span class="hljs-number">2</span>) A<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>seq ---&gt; B<span class="hljs-number">.</span>rcv<span class="hljs-number">.</span>nxt <span class="hljs-number">3</span>)发送时：<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ = SND<span class="hljs-number">.</span>UNA<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK = RCV<span class="hljs-number">.</span>NXTSND<span class="hljs-number">.</span>NXT += <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>LEN（段长度）接收时：SND<span class="hljs-number">.</span>UNA = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK（如果该<span class="hljs-built_in">SEG</span>中的ACK合法）RCV<span class="hljs-number">.</span>NXT = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ（如果该<span class="hljs-built_in">SEG</span>中的数据合法）</code></pre><h3 id="3-TCP的编号规则"><a href="#3-TCP的编号规则" class="headerlink" title="3 TCP的编号规则"></a>3 TCP的编号规则</h3><p>根据前边的描述，TCP处理的对象是一段由序列号构成的序列，所有序列号构成整个序列空间。TCP将序列分段成TCP段进行传输，因此TCP段占了序列空间的一部分，TCP段长度就是这一部分序列空间的大小，或者说段长度就是这个段传了多少个序列号。</p><p><strong>注意！本文中的段长度并不是指TCP段的头部加data部分的总长度</strong>。TCP段头部加data部分的总长度可以根据IP报文计算得出。</p><pre><code class="hljs brainfuck"><span class="hljs-comment">一段序列A（大小为n）：</span><span class="hljs-comment"></span>               <span class="hljs-comment">S0</span>                            <span class="hljs-comment">Sn</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-comment"></span>               --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">将序列拆分成多个段进行传输：</span><span class="hljs-comment"></span>              --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">|</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">|</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>                   <span class="hljs-comment">/</span>          <span class="hljs-comment">|</span>          <span class="hljs-comment">\</span><span class="hljs-comment"></span>            --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>   --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>   --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>            <span class="hljs-comment">S0</span>       <span class="hljs-comment">Sq</span>  <span class="hljs-comment">Sq</span><span class="hljs-literal">+</span><span class="hljs-comment">1</span>      <span class="hljs-comment">Sp</span>  <span class="hljs-comment">Sp</span><span class="hljs-literal">+</span><span class="hljs-comment">1</span>     <span class="hljs-comment">Sn</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-comment"></span>            <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg0</span>     <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg1</span>      <span class="hljs-comment">TCP</span> <span class="hljs-comment">seg2</span></code></pre><p>如上图所示，TCP将序列A分成三个segment进行传输，其中seg0的段长度为q+1。</p><p>TCP将序列号分配给TCP段的data域中的每个otect，以及SYN、FIN。举例来说，一个不包含data的SYN段其段长度为1（因为data占用了0个序列号，而SYN占用了1个序列号），一个不包含data的FIN段长度也是1。</p><p>一个包含data（data大小为4）的SYN段其段长度为5，此时编号规则如下：</p><pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   |序   号 <span class="hljs-attribute">SYN</span>    D<span class="hljs-number">0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     |数据控制</code></pre><p>一个包含data（data大小为5）的FIN段其长度为6，此时编号规则如下：</p><pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">5</span>   |序   号 <span class="hljs-attribute">D0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     D<span class="hljs-number">4</span>     FIN    |数据控制</code></pre><p>假设一个更具体的例子，如果需要通过TCP将<code>&quot;Hello!&quot;</code>传输给远端，并且传输结束后就关闭连接，那么，我们将发送8个序列号给远端。假设初始发送序列号为x，则序列号及其对应的数据（或控制信息）关系如下：</p><pre><code class="hljs gml">S[<span class="hljs-symbol">x</span>  ] = SYNS[<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;H&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;e&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;l&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;l&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;o&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;!&#x27;</span>S[<span class="hljs-symbol">x</span>+<span class="hljs-number">7</span>] = FIN</code></pre><h3 id="4-传输前的状态"><a href="#4-传输前的状态" class="headerlink" title="4 传输前的状态"></a>4 传输前的状态</h3><p>根据2中的描述，在此仔细考察一下TCP交换信息的过程。两种情况：1)一端先发起SYN，2)两端同时发起SYN。</p><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><pre><code class="hljs clean">B     A       B        B            A           A        B监听-&gt;发送SYN-&gt;收到SYN-&gt;发送SYN,ACK-&gt;收到SYN,ACK-&gt;发送ACK-&gt;收到ACK</code></pre><p>起初，在没有人尝试连接的时候，B一直处于监听状态（B处于LISTEN状态），随后A向B发送一个<code>&lt;SYN&gt;</code>，然后等待B的<code>&lt;ACK&gt;</code>（A处于SYN-SENT状态），B收到A的<code>&lt;SYN&gt;</code>后向A发出<code>&lt;SYN,ACK&gt;</code>然后等待A的<code>&lt;ACK&gt;</code>（B处于SYN-RECEIVED状态）</p><blockquote><p>注：为什么B发SYN却不是SYN-SENT状态？怎么理解状态？</p><p>状态是对<strong>一段过程</strong>中存在<strong>持续部分</strong>的描述，比如说打电话这个过程，有拨号（等待接通），通话（等待信息传递完毕），挂断（过程结束）三个状态。所以状态有两个特点：对于一段过程来说，状态是这段过程的流程、步骤。对于持续部分来说，状态是会持续的，是会等待外部事件引起改变的。所以状态机设计时，一个状态到底是不是状态可以从这两方面进行考虑，它是不是一段过程中的某个步骤，它是不是需要等待外部引起变化。</p><p>从过程的角度想：<code>LISTEN-&gt;SENT-&gt;RECEIVED-&gt;ESTABLISHED</code>比<code>LISTEN-&gt;SENT-&gt;ESTABLISHED</code>更合适。</p></blockquote><pre><code class="hljs django"><span class="xml">    TCP A                                                TCP B</span><span class="xml">1.                                                       LISTEN</span><span class="xml">2.  SYN-SENT    --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN</span>&gt;</span>               --&gt; SYN-RECEIVED</span><span class="xml">3.  ESTABLISHED <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span> <span class="hljs-attr">SYN-RECEIVED</span></span></span><span class="xml">4.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>       --&gt; ESTABLISHED</span><span class="xml">5.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">DATA</span>&gt;</span> --&gt; ESTABLISHED</span></code></pre><p>这个过程中，两端的TCP至少有四种状态：</p><ol><li><p>LISTEN：等待其他TCP的<code>&lt;SYN&gt;</code>。</p></li><li><p>SYN-SENT：发送<code>&lt;SYN&gt;</code>后，等待远端TCP的<code>&lt;SYN,ACK&gt;</code>。</p></li><li><p>SYN-RECEIVED：发送<code>&lt;SYN,ACK&gt;</code>后，等待远端TCP的<code>&lt;ACK&gt;</code>。</p></li><li><p>ESTABLISHED：同步完成。</p></li></ol><p>状态迁移图（横线上方是事件，下方是动作）：</p><pre><code class="hljs gherkin">                             +---------+     ?                                 |<span class="hljs-string">  LISTEN </span>|<span class="hljs-string">&lt;----------    </span><span class="hljs-string">                             +---------+                     </span>|<span class="hljs-string">     ?</span><span class="hljs-string">                  rcv SYN      </span>|<span class="hljs-string">                             </span>|<span class="hljs-string"> ---------</span><span class="hljs-string">                 -----------   </span>|<span class="hljs-string">                             v  snd SYN</span><span class="hljs-string">+---------+      snd SYN,ACK  /                            +---------+</span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;-----------------                              </span>|<span class="hljs-string">         </span>||<span class="hljs-string">   SYN   </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">   SYN   </span>||<span class="hljs-string">   RCVD  </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">   SENT  </span>||<span class="hljs-string">         </span>|<span class="hljs-string">                                                </span>|<span class="hljs-string">         </span>||<span class="hljs-string">         </span>|<span class="hljs-string">------------------           -------------------</span>|<span class="hljs-string">         </span>|+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+              --------------   |<span class="hljs-string">     </span>|<span class="hljs-string">   -----------</span><span class="hljs-string">                     x         </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     snd ACK</span><span class="hljs-string">                               V     V</span><span class="hljs-string">                             +---------+</span><span class="hljs-string">                             </span>|<span class="hljs-string">  ESTAB  </span>|                             +---------+</code></pre><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>【TODO】</p><h3 id="5-传输过程及机制"><a href="#5-传输过程及机制" class="headerlink" title="5 传输过程及机制"></a>5 传输过程及机制</h3><h4 id="有效响应及数据"><a href="#有效响应及数据" class="headerlink" title="有效响应及数据"></a>有效响应及数据</h4><p>当收到一个ACK段时，一个有效响应指该ACK段中的ACK号满足：</p><pre><code class="hljs stylus">SND<span class="hljs-selector-class">.UNA</span> &lt; SEG<span class="hljs-selector-class">.ACK</span> =&lt; SND.NXT。</code></pre><p>当收到一个数据段时，需要根据以下四种情况判别收到的段是否有效。</p><pre><code class="hljs stylus">段长度   接收窗口  判别条件------- --------  -------------------------------------------<span class="hljs-number">0</span>       <span class="hljs-number">0</span>         SEG<span class="hljs-selector-class">.SEQ</span> = RCV.NXT<span class="hljs-number">0</span>       &gt;<span class="hljs-number">0</span>        RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG<span class="hljs-selector-class">.SEQ</span> &lt; RCV.NXT+RCV.WND&gt;<span class="hljs-number">0</span>      <span class="hljs-number">0</span>         not acceptable&gt;<span class="hljs-number">0</span>      &gt;<span class="hljs-number">0</span>        RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG<span class="hljs-selector-class">.SEQ</span> &lt; RCV.NXT+RCV.WND               or RCV<span class="hljs-selector-class">.NXT</span> =&lt; SEG.SEQ+SEG<span class="hljs-selector-class">.LEN-1</span> &lt; RCV.NXT+RCV.WND</code></pre><p>当接收窗口为0时，所有除ACK、RST、URG段外的段都是无效段。因此，对于一个只发送数据的TCP来说，可以用0接收窗口传输数据，并仅接收ACK段。</p><h4 id="数据处理及TCB维护"><a href="#数据处理及TCB维护" class="headerlink" title="数据处理及TCB维护"></a>数据处理及TCB维护</h4><p>用户调用SEND接口时，TCP首先把数据缓存到内部的发送缓冲区（如果缓冲区还有剩余空间的话），然后在合适的时机从发送缓冲区中提取数据并构造TCP段发送给远端。收到数据时，TCP需要验证数据的有效性，然后按序将其推入接收缓冲区，用户调用RECEIVE接口时，便从接收缓冲区中提取数据。发送和接收过程可能都涉及到对TCP段进行拆分的操作。</p><p>在传输数据的过程中对TCB进行维护（基本上只要维护好SND.UNA和RCV.NXT）：</p><pre><code class="hljs x86asm">    A              B<span class="hljs-number">1</span>) A<span class="hljs-number">.</span>snd<span class="hljs-number">.</span>una &lt;--- B<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>ack <span class="hljs-number">4</span>)           =|      ^            v      |=<span class="hljs-number">2</span>) A<span class="hljs-number">.</span><span class="hljs-built_in">seg</span><span class="hljs-number">.</span>seq ---&gt; B<span class="hljs-number">.</span>rcv<span class="hljs-number">.</span>nxt <span class="hljs-number">3</span>)发送时（需要构造<span class="hljs-built_in">SEG</span>，<span class="hljs-built_in">SEG</span>的某些值从TCB中的相关变量中提取）：<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ = SND<span class="hljs-number">.</span>UNA<span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK = RCV<span class="hljs-number">.</span>NXTSND<span class="hljs-number">.</span>NXT += <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>LEN（段长度）接收时（需要更新TCB中的变量，这些变量更新的值从<span class="hljs-built_in">SEG</span>中提取）：SND<span class="hljs-number">.</span>UNA = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>ACK（如果该<span class="hljs-built_in">SEG</span>中的ACK合法）RCV<span class="hljs-number">.</span>NXT = <span class="hljs-built_in">SEG</span><span class="hljs-number">.</span>SEQ（如果该<span class="hljs-built_in">SEG</span>中的数据合法）</code></pre><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>TCP发送一个段后会等待ACK，如果超时没有收到ACK，则进行重传，超时时间是根据网络情况动态计算得到的，该算法在RFC793中有定义，详细见<a href="https://tools.ietf.org/html/rfc793#section-3.7">RFC793 3.7 Data Communication</a></p><h4 id="Urgent机制"><a href="#Urgent机制" class="headerlink" title="Urgent机制"></a>Urgent机制</h4><p>TCP的Urgent机制使得发送数据的用户可以通知接收数据的用户去处理（接收）一些紧急的数据，并允许接收端的TCP在当前紧急数据接收完毕后，告知接收用户数据已全部接收。</p><p>当收到一个URG标志为1的TCP段时，Urgent Pointer字段生效，TCP模块必须提取段中的Sequence Number（SN）和Urgent Pointer（UP），此时的SN+UP可以得到一个序列号，该序列号指向Urgent数据的末尾，即：在SN+UP前的所有序列号（数据）都是紧急数据。</p><pre><code class="hljs angelscript">       SN         SN+UP -<span class="hljs-number">-1</span>---|---<span class="hljs-number">-2</span>-----|--<span class="hljs-number">-3</span>---<span class="hljs-number">1</span>：可能是Urgent数据，也可能不是Urgent数据。<span class="hljs-number">2</span>：Urgent数据。<span class="hljs-number">3</span>：非Urgent数据。</code></pre><p>Urgent数据没有接收完毕之前，接收端的TCP需告知用户当前处于Urgent模式，当接收完Urgent数据后，TCP需告知用户当前处于正常模式。</p><h4 id="Push机制"><a href="#Push机制" class="headerlink" title="Push机制"></a>Push机制</h4><pre><code class="hljs asciidoc">-------------------------用户     data     data----------v---------^----TCP    tx-seq     rx-seq-------------------------</code></pre><p>TCP会缓存外部数据到内部的逻辑意义上的环型缓冲区中，也就是说，用户如果调用了多次TCP.Send，TCP仅仅只是把数据拷贝到缓冲区中，并在其合适的时候将数据发送出去，并非调用一次Send就发送一个TCP段。接收过程类似。</p><p>为了能够让用户立即发送数据，TCP提供了一个PUSH标志。用户发送数据并告知TCP需要PUSH时，TCP会立即将所有未发送的数据发送。接收到带有PUSH标志的TCP段时，TCP会将所有缓存在接收缓冲区中的数据交给用户。</p><h4 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h4><p>TCP在段中设计了一个window字段，用于表明发送该段的TCP能接收多少数据，用于流控。接收窗口取决于TCP所在主机的硬件资源及系统资源。</p><pre><code class="hljs angelscript">L &lt;-- &lt;WND:<span class="hljs-number">500</span>&gt; &lt;-- R 我的（R的）窗口大小是<span class="hljs-number">500</span> L --&gt; &lt;WND:<span class="hljs-number">300</span>&gt; --&gt; R 我的（L的）窗口大小是<span class="hljs-number">300</span></code></pre><p>当TCP知道了另一端的接收窗口大小后，其发送窗口也就被限制到最大不超过另一端的接收窗口下，因为发多了对面也收不完，所以发送窗口取决于对面的接收窗口。</p><pre><code class="hljs lasso">struct &#123; u8 *tx_mem; u32 seq; u32 swnd; <span class="hljs-params">...</span> &#125; <span class="hljs-built_in">local</span>;struct &#123; u8 *rx_mem; u32 ack; u32 rwnd; <span class="hljs-params">...</span> &#125; remote;<span class="hljs-built_in">local</span>                                                                   remote                         <span class="hljs-built_in">data</span>(<span class="hljs-built_in">local</span>.seq, <span class="hljs-built_in">local</span>.swnd)-&gt;                                                        remote.ack=<span class="hljs-built_in">local</span>.seq+x                                                                     (x&lt;=size)                         &lt;<span class="hljs-params">-ack</span>(remote.ack,remote.rwnd)<span class="hljs-built_in">local</span>.seq=remote.ack <span class="hljs-built_in">local</span>.swnd=remote.rwnd                          <span class="hljs-built_in">data</span>(<span class="hljs-built_in">local</span>.seq, <span class="hljs-built_in">local</span>.swnd)-&gt;                                      <span class="hljs-params">...</span></code></pre><p>对于窗口的管理，TCP规范中提到了以下内容。</p><ol><li><p>发送TCP必须准备好接受用户的请求，并发送至少一个字节的新数据，即使发送窗口为零。发送TCP必须定期向接收TCP重传，即使窗口为零。当窗口为0时，建议重传间隔为2分钟。这种重传对于保证当任何一个TCP有一个零窗口时，窗口的重新打开将可靠地报告给另一个是至关重要的。</p><p> 对于这句话的理解，因为远程TCP的接收窗口为零，所以本地TCP的发送窗口为零，尽管本地TCP的发送窗口为零，但本地TCP仍需要能够接收用户的发送请求，并且发送至少一个字节的数据给远程TCP。这样一来，便可以周期性的探测远程TCP接收窗口的情况，如果远程TCP接收窗口重新打开，便可以继续传输数据。见Q7。</p></li><li><p>接收TCP的接收窗口为零，并且收到一个TCP段时，它仍然必须发送一个ACK给对方，表明它的下一个预期序列号和当前窗口(零)。</p><p> 如果接收TCP的接收窗口打开了，便可以通过这个ACK告知对方。</p></li><li><p>In a connection with a one-way data flow, the window information will be carried in acknowledgment segments that all have the same sequence number so there will be no way to reorder them if they arrive out of order.  This is not a serious problem, but it will allow the window information to be on occasion temporarily based on old reports from the data receiver.  A refinement to avoid this problem is to act on the window information from segments that carry the highest acknowledgment number (that is segments with acknowledgment number equal or greater than the highest previously received).</p><p> 【不理解】</p></li></ol><h3 id="6-传输后的处理"><a href="#6-传输后的处理" class="headerlink" title="6 传输后的处理"></a>6 传输后的处理</h3><p>TCP规定，关闭连接的用户可以继续接收数据，直到它被告知另一端已经被关闭。这意味着，一个程序在接连发送数据并关闭连接后，仍旧可以接收数据，直到由于另一端连接关闭而导致接收失败。规范假定TCP组件会通知用户另一端已经关闭。TCP会在连接关闭之前将所有数据发送出去。只发数据的用户必须一直读取他们发送数据后关闭的连接，直到TCP告知他们连接已关闭。</p><p>TCP通过一个FIN标志来标识一个TCP段为FIN段，当用户关闭TCP时，TCP会向另一端发送一个FIN，以告知另一端，本端的连接已经关闭。</p><p>关闭连接的三种情况：</p><ol><li><p>本地用户关闭连接</p><p> 这种情况下，TCP会构造一个FIN段添加到发送队列中，不再接受用户的发送请求，并进入FIN-WAIT-1状态，此时仍旧可以接收数据，如收到另一端对FIN段的ACK后，连接进入TIME-WAIT状态（这里之所以没有立即进入CLOSED的状态是考虑另一端可能发FIN段并等待ACK），超时后连接进入CLOSED状态。只有本地用户主动关闭连接的情况下，TCP才会发送FIN段。这意味着，一个收到FIN段的TCP仅仅会发送ACK，但不会自动发送FIN给另一端。</p></li><li><p>远端用户关闭连接（收到来自远端的FIN段）</p><p> 收到来自另一端的FIN段的TCP要对该FIN段进行ACK，并告知用户连接正在关闭，进入CLOSE-WAIT状态，等待用户关闭连接。用户收到关闭通知后应关闭TCP连接，用户关闭连接后，TCP在发送完用户数据后发送FIN段给另一端，进入LAST-ACK状态等待另一端对FIN段的ACK。如果一直没收到另一端对FIN段的ACK，连接将被中断，并告知用户。</p></li><li><p>两端用户同时关闭连接</p><p> TCP发送FIN段后又收到另一端的FIN段，进入CLOSING状态，再收到另一端的ACK后进入TIME-WAIT状态，超时后进入CLOSED状态。</p></li></ol><p>正常关闭的情况：</p><pre><code class="hljs angelscript">  TCP A                                                TCP B<span class="hljs-number">1.</span>  ESTABLISHED                                          ESTABLISHED<span class="hljs-number">2.</span>  (Close)    FIN-WAIT<span class="hljs-number">-1</span>  --&gt; &lt;SEQ=<span class="hljs-number">100</span>&gt;&lt;ACK=<span class="hljs-number">300</span>&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT<span class="hljs-number">3.</span>  FIN-WAIT<span class="hljs-number">-2</span>  &lt;-- &lt;SEQ=<span class="hljs-number">300</span>&gt;&lt;ACK=<span class="hljs-number">101</span>&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT<span class="hljs-number">4.</span>                                                       (Close)    TIME-WAIT   &lt;-- &lt;SEQ=<span class="hljs-number">300</span>&gt;&lt;ACK=<span class="hljs-number">101</span>&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK<span class="hljs-number">5.</span>  TIME-WAIT   --&gt; &lt;SEQ=<span class="hljs-number">101</span>&gt;&lt;ACK=<span class="hljs-number">301</span>&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED<span class="hljs-number">6.</span>  (<span class="hljs-number">2</span> MSL)    CLOSED</code></pre><p>两端同时关闭的情况：</p><pre><code class="hljs django"><span class="xml">  TCP A                                                TCP B</span><span class="xml">1.  ESTABLISHED                                          ESTABLISHED</span><span class="xml">2.  (Close)                                              (Close)</span><span class="xml">    FIN-WAIT-1  --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  ... FIN-WAIT-1</span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span></span></span><span class="xml">                ... <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=FIN,ACK</span>&gt;</span>  --&gt;</span><span class="xml">3.  CLOSING     --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      ... CLOSING</span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">--</span></span></span><span class="xml">                ... <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>      --&gt;</span><span class="xml">4.  TIME-WAIT                                            TIME-WAIT</span><span class="xml">    (2 MSL)                                              (2 MSL)</span><span class="xml">    CLOSED                                               CLOSED</span></code></pre><p>状态迁移：</p><pre><code class="hljs gherkin">                             +---------+                             |<span class="hljs-string">  ESTAB  </span>|                             +---------+                      CLOSE    |<span class="hljs-string">     </span>|<span class="hljs-string">    rcv FIN</span><span class="hljs-string">                     -------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    -------</span><span class="hljs-string">+---------+          snd FIN  /       \   snd ACK          +---------+</span>|<span class="hljs-string">  FIN    </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">  CLOSE  </span>||<span class="hljs-string"> WAIT-1  </span>|<span class="hljs-string">------------------                              </span>|<span class="hljs-string">   WAIT  </span>|+---------+          rcv FIN  \                            +---------+  |<span class="hljs-string"> rcv ACK of FIN   -------   </span>|<span class="hljs-string">                            CLOSE  </span>|  |<span class="hljs-string"> --------------   snd ACK   </span>|<span class="hljs-string">                           ------- </span>|  V        x                   V                           snd FIN V+---------+                  +---------+                   +---------+|<span class="hljs-string">FINWAIT-2</span>|<span class="hljs-string">                  </span>|<span class="hljs-string"> CLOSING </span>|<span class="hljs-string">                   </span>|<span class="hljs-string"> LAST-ACK</span>|+---------+                  +---------+                   +---------+  |<span class="hljs-string">                rcv ACK of FIN </span>|<span class="hljs-string">                 rcv ACK of FIN </span>|  |<span class="hljs-string">  rcv FIN       -------------- </span>|<span class="hljs-string">    Timeout=2MSL -------------- </span>|  |<span class="hljs-string">  -------              x       V    ------------        x       V</span><span class="hljs-string">   \ snd ACK                 +---------+delete TCB         +---------+</span><span class="hljs-string">    ------------------------&gt;</span>|<span class="hljs-string">TIME WAIT</span>|<span class="hljs-string">------------------&gt;</span>|<span class="hljs-string"> CLOSED  </span>|                             +---------+                   +---------+</code></pre><h3 id="7-异常情况处理"><a href="#7-异常情况处理" class="headerlink" title="7 异常情况处理"></a>7 异常情况处理</h3><h4 id="半开连接"><a href="#半开连接" class="headerlink" title="半开连接"></a>半开连接</h4><p>如果已经建立连接的双方，1)一方在另一方不知情的情况下关闭或中断连接，或者2)同步失效，则此种连接被称为半开连接（Half Open Connectino）。当一方尝试发送数据到另一方时，连接可能会被重置（Reset）。</p><p>针对情况1)，异常的一端可能是因为连接已关闭或系统异常。针对连接关闭的情况，假设有如下连接：</p><pre><code class="hljs haskell"><span class="hljs-type">A</span>      &lt;-<span class="hljs-comment">----&gt;      B</span>         ...<span class="hljs-type">A</span> dead    x         <span class="hljs-type">B</span>         ...       &lt;--<span class="hljs-class"><span class="hljs-keyword">data</span>      <span class="hljs-type">B</span></span><span class="hljs-type">O</span>      <span class="hljs-type">RST</span><span class="hljs-comment">---&gt;      B</span></code></pre><p>起初，A与B之间已经建立连接，一段时间后，A因为某种原因中断或关闭了连接，并且B不知情。当B向A发送数据时，由于A不存在，所以TCP模块或系统内核O代替A向B发送了一个RST段。</p><p>如果系统异常（O也无法发送任何消息），B将无法收到任何回应。【不知道是否如此？】</p><p>针对情况2)，即任意一端处于LISTEN、SYN-SENT、SYN-RECEIVED状态下，如果一方收到的段中包含了<strong>不可接受的ACK</strong>，或者安全等级不匹配，则向对方发送RST段。</p><h4 id="RST段"><a href="#RST段" class="headerlink" title="RST段"></a>RST段</h4><h5 id="RST段生成"><a href="#RST段生成" class="headerlink" title="RST段生成"></a>RST段生成</h5><p>一般来说，如果收到一个明显不属于当前连接的段时，必须发送一个RST段。这种情况分为以下三种：</p><ol><li><p>连接不存在（对面向本地发送TCP段，然而本地并不存在TCP端）。</p><ol><li>如果收到的TCP段SEG中ACK域有效，则RST.SEQ=SEG.ACK，否则RST.SEQ=0并且RST.ACK=SEG.SEQ+SEG.LEN</li></ol></li><li><p>连接处于失步状态（即任意一端处于LISTEN、SYN-SENT、SYN-RECEIVED状态）</p><ol><li><p>此时收到了一个带ACK的段，并且该ACK值超过了当前的窗口（即SEG.ACK &gt; SND.UNA+SND.WND），则发送一个RST段。如果收到的TCP段SEG中ACK域有效，则RST.SEQ=SEG.ACK，否则RST.SEQ=0并且RST.ACK=SEG.SEQ+SEG.LEN</p></li><li><p>和安全相关的部分（本文暂不考虑）</p></li></ol></li><li><p>连接处于同步状态（即两端均处在ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT状态），【感觉原文中没把话说话，不好理解，见<a href="https://tools.ietf.org/html/rfc793#section-3.4">Establishing a Connection</a>中的Reset a Connection部分】</p></li></ol><h5 id="处理收到的RST段"><a href="#处理收到的RST段" class="headerlink" title="处理收到的RST段"></a>处理收到的RST段</h5><ol><li><p>检查RST段是否合法</p><p> 除SYN-SENT状态外，如果RST段的SEQ在接收窗口中，则其为合法的RST段。SYN-SENT状态下，如果RST段的ACK响应了SYN（RST-SEG.ACK=SYN.SEQ+1），则其为合法的RST段。</p></li><li><p>状态变更</p><p> 如果收到一个合法的RST段，并且接收RST段的TCP处于LISTEN状态下，则忽视该RST。如果接收RST段的TCP处于SYN-RECEIVED状态并且之前处于LISTEN状态，则重新回到LISTEN状态。其余情况下，中断连接并进入CLOSED状态。</p></li></ol><h3 id="8-接口"><a href="#8-接口" class="headerlink" title="8 接口"></a>8 接口</h3><p>详细说明见<a href="https://tools.ietf.org/html/rfc793#section-3.8">RFC793 3.8 Interfaces</a>。</p><h4 id="TCP与高层的接口"><a href="#TCP与高层的接口" class="headerlink" title="TCP与高层的接口"></a>TCP与高层的接口</h4><p>open、close、send、receive、status、abort</p><h4 id="TCP与底层的接口"><a href="#TCP与底层的接口" class="headerlink" title="TCP与底层的接口"></a>TCP与底层的接口</h4><p>如果使用IP作为TCP底层，TCP使用了IP定义的以下参数：</p><ul><li><p>Type of Service：（00000000）。</p></li><li><p>Time to Live：1分钟（00111100）。</p></li><li><p>安全选项</p></li><li><p>伪头部校验时用到的<code>source address</code>，<code>dest address</code>以及<code>protocol</code></p></li></ul><h3 id="A-附录"><a href="#A-附录" class="headerlink" title="A 附录"></a>A 附录</h3><h4 id="A-1-TCP段完整格式"><a href="#A-1-TCP段完整格式" class="headerlink" title="A.1 TCP段完整格式"></a>A.1 TCP段完整格式</h4><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|          Source Port          |       Destination Port        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                        Sequence Number                        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Acknowledgment Number                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|           Checksum            |         Urgent Pointer        |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                    Options                    |    Padding    |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                             Data                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             大小       说明<span class="hljs-bullet">----             </span>----      ----Source Port      2B        源端口。Destination Port 2B        目的端口。Sequence Number  4B        TCP段中Data部分第一个字节的序列号。如果SYN被置位，则表示<span class="hljs-code">                           初始序列号（ISN），此时TCP段的第一个字节的序列号为ISN+1。</span>Acknowledgment   4B        下一个期望收到序列号。一旦一个连接建立后，这个字段会一直<span class="hljs-code">                           发送。由ACK标识是否有效，ACK=1时有效。</span>Data Offset      4b        TCP头部长度，单位4B。Reserved         6b        保留。URG              1b        紧急数据指针启用标志。ACK              1b        ACK标志。PSH              1b        PUSH标志。RST              1b        重置连接标志。SYN              1b        同步序列号标志。FIN              1b        发送方无更多数据。Window           2B        接收窗口大小，指示发送该WINDOW的一端接收数据时能够接收的<span class="hljs-code">                           数据量</span>Checksum         2B        校验和Urgent Pointer   2B        禁止数据指针Options          n         TCP选项Padding          m         填充字段Data             x         用户数据</code></pre><h4 id="A-2-TCP状态汇总"><a href="#A-2-TCP状态汇总" class="headerlink" title="A.2 TCP状态汇总"></a>A.2 TCP状态汇总</h4><p>连接终止请求（Connection Termination Request，CTR），可理解为向对端发送FIN段。由用户调用CLOSE接口触发发送FIN段的动作。</p><ul><li><p>LISTEN：表示正在等待远端任意的TCP连接。</p></li><li><p>SYN-SENT：发送SYN，并等待响应。</p></li><li><p>SYN-RECEIVED：收到SYN，并发送SYN,ACK，等待响应。</p></li><li><p>ESTABLISHED：收到对于SYN的ACK，进入数据传输状态。</p></li><li><p>FIN-WAIT-1：本地用户发起CTR（用户调用CLOSE，发送FIN,ACK，并等待ACK）。</p></li><li><p>FIN-WAIT-2：收到对于FIN,ACK的ACK，等待对面发起FIN,ACK。</p></li><li><p>CLOSE-WAIT：等待本地用户发起CTR（等待本地用户调用CLOSE）。</p></li><li><p>CLOSING：等待远程TCP对于CTR的ACK。</p></li><li><p>LAST-ACK：等待之前发送给远程TCP的CTR的ACK。</p></li><li><p>TIME-WAIT：等待足够的时间（在这段时间中看看对面会不会发送什么东西过来，并进行合适的回复），保证远程TCP收到了它发起的CTR的ACK</p></li><li><p>CLOSED（虚构的状态）：表示没有连接存在。</p></li></ul><h5 id="导致状态转移的事件"><a href="#导致状态转移的事件" class="headerlink" title="导致状态转移的事件"></a>导致状态转移的事件</h5><ul><li><p>OPEN、SEND、RECEIVE、CLOSE、ABORT、STATUS。</p></li><li><p>SEGMENT ARRIVES。</p></li><li><p>USER TIMEOUT、RETRANSMISSION TIMEOUT、TIME-WAIT TIMEOUT。</p></li></ul><h5 id="状态迁移图"><a href="#状态迁移图" class="headerlink" title="状态迁移图"></a>状态迁移图</h5><p>此状态图仅表示了状态转移时的事件及处理，完整逻辑见RFC793中<a href="https://tools.ietf.org/html/rfc793#section-3.9">3.9 Event Processing</a>一节。</p><pre><code class="hljs gherkin">                             +---------+ ---------\      active OPEN                             |<span class="hljs-string">  CLOSED </span>|<span class="hljs-string">            \    -----------</span><span class="hljs-string">                             +---------+&lt;---------\   \   create TCB</span><span class="hljs-string">                               </span>|<span class="hljs-string">     ^              \   \  snd SYN</span><span class="hljs-string">                  passive OPEN </span>|<span class="hljs-string">     </span>|<span class="hljs-string">   CLOSE        \   \</span><span class="hljs-string">                  ------------ </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> ----------       \   \</span><span class="hljs-string">                   create TCB  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> delete TCB         \   \</span><span class="hljs-string">                               V     </span>|<span class="hljs-string">                      \   \</span><span class="hljs-string">                             +---------+            CLOSE    </span>|<span class="hljs-string">    \</span><span class="hljs-string">                             </span>|<span class="hljs-string">  LISTEN </span>|<span class="hljs-string">          ---------- </span>|<span class="hljs-string">     </span>|                             +---------+          delete TCB |<span class="hljs-string">     </span>|                  rcv SYN      |<span class="hljs-string">     </span>|<span class="hljs-string">     SEND              </span>|<span class="hljs-string">     </span>|                 -----------   |<span class="hljs-string">     </span>|<span class="hljs-string">    -------            </span>|<span class="hljs-string">     V</span><span class="hljs-string">+---------+      snd SYN,ACK  /       \   snd SYN          +---------+</span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">         </span>||<span class="hljs-string">   SYN   </span>|<span class="hljs-string">                    rcv SYN                     </span>|<span class="hljs-string">   SYN   </span>||<span class="hljs-string">   RCVD  </span>|<span class="hljs-string">&lt;-----------------------------------------------</span>|<span class="hljs-string">   SENT  </span>||<span class="hljs-string">         </span>|<span class="hljs-string">                    snd ACK                     </span>|<span class="hljs-string">         </span>||<span class="hljs-string">         </span>|<span class="hljs-string">------------------           -------------------</span>|<span class="hljs-string">         </span>|+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+  |<span class="hljs-string">           --------------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">   -----------</span><span class="hljs-string">  </span>|<span class="hljs-string">                  x         </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     snd ACK</span><span class="hljs-string">  </span>|<span class="hljs-string">                            V     V</span><span class="hljs-string">  </span>|<span class="hljs-string">  CLOSE                   +---------+</span><span class="hljs-string">  </span>|<span class="hljs-string"> -------                  </span>|<span class="hljs-string">  ESTAB  </span>|  |<span class="hljs-string"> snd FIN                  +---------+</span><span class="hljs-string">  </span>|<span class="hljs-string">                   CLOSE    </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    rcv FIN</span><span class="hljs-string">  V                  -------   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    -------</span><span class="hljs-string">+---------+          snd FIN  /       \   snd ACK          +---------+</span>|<span class="hljs-string">  FIN    </span>|<span class="hljs-string">&lt;-----------------           ------------------&gt;</span>|<span class="hljs-string">  CLOSE  </span>||<span class="hljs-string"> WAIT-1  </span>|<span class="hljs-string">------------------                              </span>|<span class="hljs-string">   WAIT  </span>|+---------+          rcv FIN  \                            +---------+  |<span class="hljs-string"> rcv ACK of FIN   -------   </span>|<span class="hljs-string">                            CLOSE  </span>|  |<span class="hljs-string"> --------------   snd ACK   </span>|<span class="hljs-string">                           ------- </span>|  V        x                   V                           snd FIN V+---------+                  +---------+                   +---------+|<span class="hljs-string">FINWAIT-2</span>|<span class="hljs-string">                  </span>|<span class="hljs-string"> CLOSING </span>|<span class="hljs-string">                   </span>|<span class="hljs-string"> LAST-ACK</span>|+---------+                  +---------+                   +---------+  |<span class="hljs-string">                rcv ACK of FIN </span>|<span class="hljs-string">                 rcv ACK of FIN </span>|  |<span class="hljs-string">  rcv FIN       -------------- </span>|<span class="hljs-string">    Timeout=2MSL -------------- </span>|  |<span class="hljs-string">  -------              x       V    ------------        x       V</span><span class="hljs-string">   \ snd ACK                 +---------+delete TCB         +---------+</span><span class="hljs-string">    ------------------------&gt;</span>|<span class="hljs-string">TIME WAIT</span>|<span class="hljs-string">------------------&gt;</span>|<span class="hljs-string"> CLOSED  </span>|                             +---------+                   +---------+</code></pre><h4 id="A-3-TCP事件处理备注"><a href="#A-3-TCP事件处理备注" class="headerlink" title="A.3 TCP事件处理备注"></a>A.3 TCP事件处理备注</h4><h5 id="CLOSE事件"><a href="#CLOSE事件" class="headerlink" title="CLOSE事件"></a>CLOSE事件</h5><ul><li>CLOSE<ul><li>CLOSE-WAIT STATE<br>  Queue this request until all preceding SENDs have been<br>  segmentized; then send a FIN segment, enter CLOSING state.<br>  【这里是不是应该enter LAST-ACK state？】</li></ul></li></ul><h4 id="A-4-使用TCP"><a href="#A-4-使用TCP" class="headerlink" title="A.4 使用TCP"></a>A.4 使用TCP</h4><ul><li><p>抓包<br>  sudo tcpdump -vvv -s0 host 10.0.0.1 （可以显示TCP checksum是否错误）<br>  sudo tcpdump -x -i eth0（抓网口以太网帧）</p></li><li><p>静态IP配置<br>  sudo ifconfig eth0 donw<br>  sudo ifconfig eth0 10.0.0.1 netmask 255.255.255.0<br>  sudo ifconfig eth0 up</p></li><li><p>端口占用的两种查询方式<br>  netstat -anp | grep 12345<br>  lsof -i:12345</p></li><li><p>其他</p><ul><li><p>在linux下ctrl+c杀死进程模拟close tcp，按理close后应发送fin,ack并进入FIN_WAIT_1，但实际只发了一个ack并进入FIN_WAIT_1</p></li><li><p>send() -&gt; close() -&gt; recv() -&gt; recv失败 = 连接已关闭 = 数据发送到远端。</p></li></ul></li></ul><h4 id="A-5-问题汇总"><a href="#A-5-问题汇总" class="headerlink" title="A.5 问题汇总"></a>A.5 问题汇总</h4><ul><li><p>Q1. 如果三次握手的第三次ACK没被收到会怎么样？</p><p>  将设三次握手过程如下</p>  <pre><code class="hljs django"><span class="xml">    TCP A                                                TCP B</span><span class="xml">1.                                                       LISTEN</span><span class="xml">2.  SYN-SENT    --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=100</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN</span>&gt;</span>               --&gt; SYN-RECEIVED</span><span class="xml">3.  ESTABLISHED <span class="hljs-tag">&lt;<span class="hljs-name">--</span> &lt;<span class="hljs-attr">SEQ</span>=<span class="hljs-string">300</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=SYN,ACK</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">--</span> <span class="hljs-attr">SYN-RECEIVED</span></span></span><span class="xml">4.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span>       x  ESTABLISHED</span><span class="xml">5.  ESTABLISHED --&gt; <span class="hljs-tag">&lt;<span class="hljs-name">SEQ=101</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ACK=301</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">CTL=ACK</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">DATA</span>&gt;</span> --&gt; ESTABLISHED</span></code></pre><p>  如果4的<code>&lt;ACK&gt;</code>没被B收到，可能会有几种情况发生：</p><ol><li><p>发完<code>&lt;ACK&gt;</code>后，A便开始向B传输数据，由于数据中带<code>&lt;ACK&gt;</code>，所以B会根据数据段中的<code>&lt;ACK&gt;</code>值判断连接是否建立。</p></li><li><p>发完<code>&lt;ACK&gt;</code>后，A没有立即发送数据，此时B会重传<code>&lt;SYN,ACK&gt;</code>。</p></li><li><p>异常情况下，B会重置（RST段）A。</p></li></ol></li><li><p>Q2. 如果我发送之后立即关闭，并且不做recv操作，是不是意味着数据可能没有被发送完毕？</p></li><li><p>Q3. 如果我发送之后立即关闭，然后又打开，又发送关闭，会出现什么问题？</p></li><li><p>Q4. 如果重传仍旧收不到ACK呢，比如对端主机已宕机？</p></li><li><p>Q5. 如果已建立连接的两端，一端宕机后，另一端仍旧是ESTABLISHED状态？它如何发现对面已经断开连接？</p><p>  给对面发送数据，如果异常则表明有问题（同Q4）。另一个问题：如果一直不给对面发数据，就会一直保持一个虚假的ESTABLISHED状态吗？能否主动发现对面已经挂了？</p></li><li><p>Q6. 什么时候两端会同时发SYN呢？</p></li><li><p>Q7. 发送窗口是不是仅仅取决于接收窗口，难道它不考虑本地资源？</p></li><li><p>Q8. 段长度（segment length）指什么？</p><p>  通过<strong>RFC793中关于segment length的表述</strong>可知，TCP的段长度指一个段所占用的序列空间的大小（一个段占用了一段序列，这段序列的长度就是段长度）。比如，一个段占用了序列[1,2,3,4,5]，则其段长度为5。序列中的序列号会分配给TCP段中data域中的每个otect，以及SYN、FIN。</p><p>  举例来说，一个不包含data的SYN段其段长度为1（因为data占用了0个序列号，而SYN占用了1个序列号），一个不包含data的FIN段长度也是1。</p><p>  一个包含data（data大小为4）的SYN段其段长度为5，此时编号规则如下：</p>  <pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   |序   号 <span class="hljs-attribute">SYN</span>    D<span class="hljs-number">0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     |数据控制</code></pre><p>  一个包含data（data大小为5）的FIN段其长度为6，此时编号规则如下：</p>  <pre><code class="hljs apache"><span class="hljs-attribute">s0</span>     s<span class="hljs-number">0</span>+<span class="hljs-number">1</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">2</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">3</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">4</span>   s<span class="hljs-number">0</span>+<span class="hljs-number">5</span>   |序   号 <span class="hljs-attribute">D0</span>     D<span class="hljs-number">1</span>     D<span class="hljs-number">2</span>     D<span class="hljs-number">3</span>     D<span class="hljs-number">4</span>     FIN    |数据控制</code></pre><p>  <strong>RFC793中关于segment length的表述</strong></p><blockquote><p>SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN).</p><p>segment length = The amount of sequence number space occupied by a segment, including any controls which occupy sequence space.</p><p>SEG.LEN - segment length</p><p>The segment length (SEG.LEN) includes both data and sequence space occupying controls.</p><p>We have taken advantage of the numbering scheme to protect certain control information as well.  This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  Control information is not physically carried in the segment data space.  Consequently, we must adopt rules for implicitly assigning sequence numbers to control.  The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  The segment length (SEG.LEN) includes both data and sequence space occupying controls.  When a SYN is present then SEG.SEQ is the sequence number of the SYN.</p></blockquote></li></ul><h4 id="A-6-关于协议设计的思考"><a href="#A-6-关于协议设计的思考" class="headerlink" title="A.6 关于协议设计的思考"></a>A.6 关于协议设计的思考</h4><p>协议的功能：用什么方法或机制，实现什么目标。</p><p>协议的组成：传输格式，交互过程，状态机（状态、事件、动作、状态转移），接口（对外依赖，对外提供）。</p><p>协议中有哪些角色：比如TCP中有1)发送数据的用户，2)接收数据的用户，3)发送数据的TCP，4)接收数据的TCP。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://tools.ietf.org/html/rfc793">TRANSMISSION CONTROL PROTOCOL, RFC793</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>协议栈</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有趣的C宏</title>
    <link href="/2021/01/14/%E6%9C%89%E8%B6%A3%E7%9A%84C%E5%AE%8F/"/>
    <url>/2021/01/14/%E6%9C%89%E8%B6%A3%E7%9A%84C%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="有趣的C宏"><a href="#有趣的C宏" class="headerlink" title="有趣的C宏"></a>有趣的C宏</h2><p>不定时更新一些C宏用法</p><h3 id="变量后添加行号"><a href="#变量后添加行号" class="headerlink" title="变量后添加行号"></a>变量后添加行号</h3><p>想法来源：在一些自动生成变量而又不会<strong>直接</strong>使用到该变量的情况。</p><pre><code class="hljs reasonml">#define <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> x##y#define <span class="hljs-constructor">CONCAT(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>#define <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">v</span>)</span> <span class="hljs-constructor">CONCAT(<span class="hljs-params">v</span>,<span class="hljs-params">__LINE__</span>)</span><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span>&#123;    <span class="hljs-built_in">int</span> <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">a</span>)</span>;    return <span class="hljs-number">0</span>;&#125;</code></pre><p>预编译后：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> main()&#123;    <span class="hljs-built_in">int</span> a7;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>用法举例：</p><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;#<span class="hljs-keyword">include</span> &lt;stdint.h&gt;#<span class="hljs-keyword">include</span> &lt;<span class="hljs-built_in">string</span>.h&gt;#define <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> x##y#define <span class="hljs-constructor">CONCAT(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span> <span class="hljs-constructor">CONCAT_(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>#define <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">v</span>)</span> <span class="hljs-constructor">CONCAT(<span class="hljs-params">v</span>,<span class="hljs-params">__LINE__</span>)</span>#define alloc<span class="hljs-constructor">_from_stack(<span class="hljs-params">pp</span>, <span class="hljs-params">size</span>)</span> \    uint8_t <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">stack_memory</span>)</span><span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>; \    *(pp) = <span class="hljs-constructor">VAR_LINE(<span class="hljs-params">stack_memory</span>)</span>;<span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span>&#123;    uint8_t *p;    alloc<span class="hljs-constructor">_from_stack(&amp;<span class="hljs-params">p</span>, 12)</span>;    memcpy(p, <span class="hljs-string">&quot;Hello world\0&quot;</span>, <span class="hljs-number">12</span>);    printf(<span class="hljs-string">&quot;%s\n&quot;</span>, p);    return <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="List-foreach"><a href="#List-foreach" class="headerlink" title="List foreach"></a>List foreach</h3><p>来源：如何在遍历list的同时删除其中的节点，又不暴露list内部的next指针。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">// list.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> *<span class="hljs-title">next</span>;</span>&#125; <span class="hljs-keyword">list_t</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_append(list, node) do \</span>&#123; \    <span class="hljs-keyword">list_t</span> **it = &amp;(((<span class="hljs-keyword">list_t</span> *)(<span class="hljs-built_in">list</span>))-&gt;next); \    ((<span class="hljs-keyword">list_t</span> *)node)-&gt;next = <span class="hljs-literal">NULL</span>; \    <span class="hljs-keyword">while</span> (*it) &#123; \        it = &amp;((*it)-&gt;next); \    &#125; \    (*it) = (<span class="hljs-keyword">list_t</span> *)node; \&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_foreach_remove(node) list_foreach_rm = 1; *node = (*(node))-&gt;next;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_foreach(type, name, list, do_something) \</span>    <span class="hljs-keyword">for</span> (type **name = (type **)&amp;((<span class="hljs-built_in">list</span>)-&gt;next); *name; ) &#123; \        <span class="hljs-keyword">int</span> list_foreach_rm = <span class="hljs-number">0</span>; \        do_something \        <span class="hljs-keyword">if</span> (*name &amp;&amp; !list_foreach_rm) &#123; \            name = &amp;((*name)-&gt;next); \        &#125; \    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_INIT(list) (list)-&gt;next = NULL;</span><span class="hljs-comment">// something.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">int_node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">int_node</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">int</span> val;&#125; <span class="hljs-keyword">int_node_t</span>;<span class="hljs-comment">// main.c</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">list_t</span> <span class="hljs-built_in">list</span>;    <span class="hljs-keyword">int_node_t</span> n[<span class="hljs-number">5</span>];    LIST_INIT(&amp;<span class="hljs-built_in">list</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;        n[i].val = i;        list_append(&amp;<span class="hljs-built_in">list</span>, &amp;n[i]);    &#125;    <span class="hljs-comment">// 输出：0 1 2 3 4</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (*item)-&gt;val);    &#125;);    <span class="hljs-comment">// 删除0，1，4节点</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-keyword">if</span> ((*item)-&gt;val == <span class="hljs-number">0</span> || (*item)-&gt;val == <span class="hljs-number">1</span> || (*item)-&gt;val == <span class="hljs-number">4</span>) &#123;            list_foreach_remove(item);        &#125;    &#125;);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-comment">// 输出：2 3</span>    list_foreach(<span class="hljs-keyword">int_node_t</span>, item, &amp;<span class="hljs-built_in">list</span>, &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (*item)-&gt;val);    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 完整输出：</span><span class="hljs-comment">0 1 2 3 4</span><span class="hljs-comment">2 3</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种灵活的内存块数据结构设计</title>
    <link href="/2021/01/13/%E4%B8%80%E7%A7%8D%E7%81%B5%E6%B4%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/01/13/%E4%B8%80%E7%A7%8D%E7%81%B5%E6%B4%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一种灵活的内存块数据结构设计"><a href="#一种灵活的内存块数据结构设计" class="headerlink" title="一种灵活的内存块数据结构设计"></a>一种灵活的内存块数据结构设计</h2><p>初衷：在dts.net中提供一个数据块结构，用于在网络各层模块中传递数据的同时，尽可能的将动态内存分配推迟到用户层。</p><p>完整代码及其实现见<a href="https://github.com/Doerthous/dts.net">dts.net.dblk</a>。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Node：节点<br>Block：逻辑数据块</p><h3 id="1-UDP到IP时的数据变化"><a href="#1-UDP到IP时的数据变化" class="headerlink" title="1 UDP到IP时的数据变化"></a>1 UDP到IP时的数据变化</h3><p>假设UDP数据为A，到IP层后，IP层需要在上层的数据的头部新增一个IP头部B，其结构形如链表：B-&gt;A。</p><p>故此，我们设计一个如下链表进行处理：</p><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">uint8_t</span> *data; <span class="hljs-comment">// 实际数据</span>    <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>; <span class="hljs-comment">// data大小</span>&#125; <span class="hljs-keyword">dblk_t</span>;<span class="hljs-keyword">dblk_t</span> *udp;<span class="hljs-keyword">dblk_t</span> *ip = ip_pack(udp) &#123; <span class="hljs-comment">// IP模块组包接口</span>    dblk *ip_header;    <span class="hljs-comment">// ...</span>    ip_header-&gt;next = udp;    <span class="hljs-keyword">return</span> ip_header; &#125;</code></pre><h3 id="2-链表数据管理"><a href="#2-链表数据管理" class="headerlink" title="2 链表数据管理"></a>2 链表数据管理</h3><p>按照1中的分析，假设当前有一个三层网络，每层都会添加头部，那么，加上原始载荷，有：</p><p>C-&gt;B-&gt;A-&gt;P。</p><p>其中P表示原始载荷，A表示最高层协议，B表示中间层协议，C表示最底层协议。随着层次逐渐降低，链表中的节点逐渐增加。</p><pre><code class="hljs clean"><span class="hljs-number">0</span>层          PA层          A-&gt;PB层          B-&gt;A-&gt;PC层          C-&gt;B-&gt;A-&gt;P</code></pre><p>如此，可遍历C、B、A、P节点中的数据完成一个完整协议栈数据的发送或解析操作。</p><pre><code class="hljs arduino"><span class="hljs-comment">// 将dblk数据拷贝到指定内存</span><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">dblk_copy_to</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> *dblk, <span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;    <span class="hljs-keyword">size_t</span> do_size;    <span class="hljs-keyword">size_t</span> done_size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (dblk) &#123;        do_size = <span class="hljs-built_in">size</span> &lt; dblk-&gt;<span class="hljs-built_in">size</span> ? <span class="hljs-built_in">size</span> : dblk-&gt;<span class="hljs-built_in">size</span>;        <span class="hljs-built_in">memcpy</span>(mem, dblk-&gt;data, do_size);        done_size += do_size;        mem += do_size;        <span class="hljs-keyword">if</span> (done_size == <span class="hljs-built_in">size</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        dblk = dblk-&gt;next;    &#125;    <span class="hljs-keyword">return</span> done_size;&#125;send(dblk) &#123;    <span class="hljs-keyword">uint8_t</span> buff[SOME_SIZE];    <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span> = dblk_copy_to(dblk, buff, SOME_SIZE);    low_level_send(buff, <span class="hljs-built_in">size</span>);&#125;</code></pre><h3 id="3-2-中存在的问题"><a href="#3-2-中存在的问题" class="headerlink" title="3 [2]中存在的问题"></a>3 [2]中存在的问题</h3><p>考虑到底层可能由于硬件原因，无法及时发送数据，导致多个完整协议栈数据被缓存。为管理这些数据，可添加用于表示后续节点是否属于当前<strong>逻辑数据块</strong>的more标志，区分不同的逻辑数据块，具体解释如下图：</p><pre><code class="hljs apache"><span class="hljs-attribute">C1</span> -&gt; B<span class="hljs-number">1</span> -&gt; A<span class="hljs-number">1</span> -&gt; P<span class="hljs-number">1</span> -&gt; C<span class="hljs-number">2</span> -&gt; B<span class="hljs-number">2</span> -&gt; A<span class="hljs-number">2</span> -&gt; P<span class="hljs-number">2</span> -&gt; ...<span class="hljs-attribute">m</span>:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">0</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">1</span>   m:<span class="hljs-number">0</span>   ...</code></pre><p>上述链表虽有8个节点（C1 ~ P2），但是只有两个逻辑数据块，其中（C1 ~ P1）是一个，（C2 ~ P2）是另一个（m：more）。在处理一个节点的数据时，需要判断more标志，如果more标志为1则表示后续节点仍属于当前逻辑数据块，否者则表示当前节点为当前逻辑数据块的最后一个节点。类似IP报文中的More Fragment标志。</p><p>如此，在处理时可按照逻辑数据块进行区分：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">dblk_copy_to</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> *dblk, <span class="hljs-keyword">void</span> *mem, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span> </span>&#123;    <span class="hljs-keyword">size_t</span> do_size;    <span class="hljs-keyword">size_t</span> done_size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (dblk) &#123;        do_size = <span class="hljs-built_in">size</span> &lt; dblk-&gt;<span class="hljs-built_in">size</span> ? <span class="hljs-built_in">size</span> : dblk-&gt;<span class="hljs-built_in">size</span>;        <span class="hljs-built_in">memcpy</span>(mem, dblk-&gt;data, do_size);        done_size += do_size;        mem += do_size;        <span class="hljs-keyword">if</span> (done_size == <span class="hljs-built_in">size</span> || !dblk-&gt;more) &#123; <span class="hljs-comment">// 按逻辑数据块进行处理</span>            <span class="hljs-keyword">break</span>;        &#125;        dblk = dblk-&gt;next;    &#125;    <span class="hljs-keyword">return</span> done_size;&#125;</code></pre><p>除上述方法外，也可引入另一个指针来连接不同的逻辑数据块。</p><pre><code class="hljs coq">C1 -&gt; B1 -&gt; A1 -&gt; P1 |<span class="hljs-type"></span><span class="hljs-type"> v</span>C2 -&gt; B2 -&gt; A2 -&gt; P2</code></pre><h3 id="4-分片及内存对齐问题"><a href="#4-分片及内存对齐问题" class="headerlink" title="4 分片及内存对齐问题"></a>4 分片及内存对齐问题</h3><p>假设某个双层应用层协议需通过UDP传输，最终形成如下内存：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">U</span>  <span class="hljs-literal">-</span>&gt;  <span class="hljs-comment">L1</span>    <span class="hljs-literal">-</span>&gt;    <span class="hljs-comment">L2</span><span class="hljs-comment">\</span>       <span class="hljs-comment">\</span>           <span class="hljs-comment">\</span><span class="hljs-comment"></span><span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span><span class="hljs-comment">|</span>  <span class="hljs-comment">U</span>  <span class="hljs-comment">|</span>   <span class="hljs-comment">|</span>  <span class="hljs-comment">L1</span>  <span class="hljs-comment">|</span>   <span class="hljs-comment">|</span>  <span class="hljs-comment">L2</span>  <span class="hljs-comment">|</span><span class="hljs-comment"></span><span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span>   <span class="hljs-literal">+</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">+</span></code></pre><p>在逻辑上，我们可以将上述内存想象成一大块连续分配的虚拟内存：</p><pre><code class="hljs asciidoc"><span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span></code></pre><p>到IP层时，由于逻辑数据块长度太大，IP模块需要进行分片，为了最大化节省空间，我们可让IP层节点指向上述虚拟内存。例如，假设经计算上述内存需被分为4个IP分片报文：</p><pre><code class="hljs asciidoc">F1   F2   F3   F4|    |    |    |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>IP1 -&gt; F1IP2 -&gt; F2IP3 -&gt; F3IP4 -&gt; F4</code></pre><p>每个IPx节点的内存中包含了IP Header的数据，而Fx节点包含了传给IP层的上层数据分片。按照上述虚拟的连续内存思路，我们可以实现利用<strong>原数据</strong>而<strong>无需重新拷贝</strong>而得到分片的操作。然而，由于IP层在分片时对载荷有对齐要求（8B对齐），如果U、L1、L2内存本身没有满足8B对齐，那么就会出现上图中类似F2与F3的情况：一个dblk节点的所代表的内存块在实际物理内存上并不连续！</p><p>为此，我们引入一个vsize和类型为dblk_t *的vmem指针，用vsize表示当前节点虚拟内存的大小，当当前节点的data的大小无法满足vsize时，我们继续从vmem中取内存，直到其大小为vsize为止。</p><p>在保持原有链表不动的情况下，假设U、L1、L2的data指针分别为u、l1、l2，大小分别为us、l1s、l2s，如下所示，</p><pre><code class="hljs apache"><span class="hljs-attribute">U</span>  -&gt;  L<span class="hljs-number">1</span>  -&gt;  L<span class="hljs-number">2</span><span class="hljs-attribute">d</span>:u    d:l<span class="hljs-number">1</span>    d:l<span class="hljs-number">2</span><span class="hljs-attribute">s</span>:us   s:l<span class="hljs-number">1</span>s   s:l<span class="hljs-number">2</span>s</code></pre><p>再设分片后，每个分片报文大小为x，则，F1 ~ F4的data指针及其内容如下：</p><pre><code class="hljs sas">F1   -&gt;   F2   -&gt;   F3  -&gt;                 F4d:u       d:u+<span class="hljs-meta">x</span>     d:l1+(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))        d:l2+(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))s:us      s:us-<span class="hljs-meta">x</span>    s:l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))       s:l2s-(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))vs:<span class="hljs-meta">x</span>      vs:<span class="hljs-meta">x</span>      vs:<span class="hljs-meta">x</span>                   vs:l2s-(<span class="hljs-meta">x</span>-(l1s-(<span class="hljs-meta">x</span>-(us-<span class="hljs-meta">x</span>))))vm:<span class="hljs-meta">NULL</span>   vm:L1     vm:L2                  vm:<span class="hljs-meta">NULL</span></code></pre><p>推导：</p><ol><li><p>F1节点，d指向u；s为d的大小us；vs=x；由于us&gt;x，故F1无需再取内存，故vm为NULL。</p></li><li><p>F2节点，由于F1没能占完u，故F2的d指向u加上F1占用u后剩下的内存，F1占了x，所以F2的d指向u+x；s为d的大小(us-x)；vs=x；从图中可看出，仅仅u无法满足F2的vs大小，F2后续还占用了l1，故vm=L1。</p></li><li><p>F3，F4思路类似。</p></li></ol><p>需要注意的是F4作为尾节点，可能没有vmem使用，故其vs可能不一定等于x。此外一个vmem-节点可能占用原来链表的多个节点内存，如下图，Fa占用了三块原节点内存。</p><pre><code class="hljs asciidoc">Fa             Fb|              |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span>|  U  |  L1  |  L2  |<span class="hljs-code">+-----+</span>------<span class="hljs-code">+------+</span></code></pre><p>在此过程中，size字段的含义不变，仍旧表示data的大小。只是当未启用vmem时，节点的内存大小正好等于data的大小。而vmem启用时，节点的内存大小未必等于data的大小。按照上述思路，可以设计一个如下接口，实现将dblk内存分割成按任意字节对齐的片段。需要注意，此处的dblk参数必须是未启用vmem模式的节点。</p><p><code>dblk_t *dblk_fragments(dblk_t *dblk, size_t frag_size);</code></p><p>至此，当上层数据超长需要分片时，仅需调用<code>dblk_fragments</code>进行处理即可。可以引入一个将vmem节点还原回正常节点的操作，如此便可无限制地使用分片接口。</p><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5 接口"></a>5 接口</h3><h4 id="Node结构及接口"><a href="#Node结构及接口" class="headerlink" title="Node结构及接口"></a>Node结构及接口</h4><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">uint8_t</span> *data;    <span class="hljs-keyword">uint16_t</span> <span class="hljs-built_in">size</span>;    <span class="hljs-keyword">uint16_t</span> data_malloc:<span class="hljs-number">1</span>; <span class="hljs-comment">// 指示data字段是否来自malloc</span>    <span class="hljs-keyword">uint16_t</span> node_malloc:<span class="hljs-number">1</span>; <span class="hljs-comment">// 指示此Node是否来自malloc。</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @brief 指示后续Node与当前Node同属一个Block。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *  假设有如下dblk链表:</span><span class="hljs-comment">     *   Nodes:</span><span class="hljs-comment">     *   n1    -&gt;    n2    -&gt;   n3    -&gt;    n4    -&gt;    n5    -&gt;  n6</span><span class="hljs-comment">     *   more:1      more:1     more:0      more:1      more:1    more:0</span><span class="hljs-comment">     *   -----------------------------      ----------------------------</span><span class="hljs-comment">     *   Block1                             Block2</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">uint16_t</span> more:<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @brief vmem模式.</span><span class="hljs-comment">     * </span><span class="hljs-comment">     *  当vsize != 0的Node属于vmem-Node，反之为rmem-Node。vsize表示当前vmem-Node所</span><span class="hljs-comment">     *  带内存大小，而size表示data的大小。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">uint16_t</span> vsize;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dblk</span> *<span class="hljs-title">vmem</span>;</span>&#125; <span class="hljs-keyword">dblk_t</span>;</code></pre><pre><code class="hljs reasonml"><span class="hljs-comment">// 将两个Node按序纳入同一个Block</span>void dblk<span class="hljs-constructor">_node_concat(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk1</span>, <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk2</span>)</span>;<span class="hljs-comment">// 初始化Node参数</span>dblk_t *dblk<span class="hljs-constructor">_node_init(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 分配一个Node并设置其内存</span>dblk_t *dblk<span class="hljs-constructor">_node_new(<span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 从栈上分配一个Node并设置其内存</span>void dblk<span class="hljs-constructor">_node_new_from_stack(<span class="hljs-operator">**</span><span class="hljs-params">ppdblk</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 分配一个Node及其内存</span>dblk_t *dblk<span class="hljs-constructor">_node_new_with_buff(<span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;...</code></pre><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><pre><code class="hljs cpp"><span class="hljs-comment">// 释放所有Node</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dblk_list_delete</span><span class="hljs-params">(<span class="hljs-keyword">dblk_t</span> * dblk)</span></span>;...</code></pre><h4 id="Block接口"><a href="#Block接口" class="headerlink" title="Block接口"></a>Block接口</h4><pre><code class="hljs reasonml"><span class="hljs-comment">// 删除第一个Block，并返回后一个块</span>dblk_t *dblk<span class="hljs-constructor">_delete(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 获取第一个Block大小</span>size_t dblk<span class="hljs-constructor">_size(<span class="hljs-params">const</span> <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 获取下一个Block</span>dblk_t *dblk<span class="hljs-constructor">_next(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">dblk</span>)</span>;<span class="hljs-comment">// 将第一个Block的数据拷贝到指定内存，并返回拷贝数量</span>size_t dblk<span class="hljs-constructor">_copy_to(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">mem</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 将指定内存中的数据拷贝到第一个Block，并返回拷贝数量</span><span class="hljs-comment">// 不支持 vmem Node</span>size_t dblk<span class="hljs-constructor">_copy_from(<span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">mem</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>)</span>;<span class="hljs-comment">// 将第一个逻辑数据块按照给定大小分割，分割后，每个片段独立成Block</span><span class="hljs-comment">// 不支持 vmem Node</span>dblk_t *dblk<span class="hljs-constructor">_fragment(<span class="hljs-params">const</span> <span class="hljs-params">dblk_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dblk</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">fsize</span>)</span>;...</code></pre><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h3><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">dblk_t</span> *b1 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    <span class="hljs-keyword">dblk_t</span> *b2 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    <span class="hljs-keyword">dblk_t</span> *b3 = dblk_node_new_with_buff(<span class="hljs-number">12</span>);    dblk_node_concat(b1, b2);    dblk_node_concat(b2, b3);    <span class="hljs-keyword">dblk_t</span> *it = b1;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; it-&gt;size; ++i) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, it-&gt;data[i]);        &#125;        it = dblk_node_next(it);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    dblk_copy_from(b1, <span class="hljs-string">&quot;123456789098765432101234567890123456&quot;</span>, <span class="hljs-number">36</span>);    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">36</span>];    &#123;        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(b1, buff, <span class="hljs-number">36</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">dblk_t</span> *fragments = dblk_fragment(b1, <span class="hljs-number">7</span>);    it = fragments;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        it = dblk_next(it);    &#125;    <span class="hljs-keyword">if</span> (dblk_list_to_rmem_list(fragments)) &#123;        it = fragments;        <span class="hljs-keyword">while</span> (it) &#123;            <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);            <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);            it = dblk_next(it);        &#125;    &#125;    dblk_list_delete(fragments);    fragments = dblk_fragment(b1, <span class="hljs-number">5</span>);    it = fragments;    <span class="hljs-keyword">while</span> (it) &#123;        <span class="hljs-built_in">memset</span>(buff, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)dblk_copy_to(it, buff, <span class="hljs-number">36</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%sn: &quot;</span>, dblk_node_is_vmem_node(it)?<span class="hljs-string">&quot;v&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; ++i) &#123;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X &quot;</span>, buff[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        it = dblk_next(it);    &#125;    dblk_list_delete(fragments);    dblk_list_delete(b1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;输出：CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span>vn: <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span>vn: <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span>vn: <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span>vn: <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> n: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> n: <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> n: <span class="hljs-number">35</span> <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> n: <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> n: <span class="hljs-number">39</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> n: <span class="hljs-number">36</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">39</span> <span class="hljs-number">38</span> <span class="hljs-number">37</span> <span class="hljs-number">36</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">34</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span> <span class="hljs-number">37</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">30</span>vn: <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span>vn: <span class="hljs-number">36</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>协议栈</tag>
      
      <tag>数据结构</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP协议</title>
    <link href="/2021/01/13/UDP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/13/UDP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP基于IP协议，为上层提供一个协议机制最少的通信协议。</p><h3 id="1-UDP报文格式"><a href="#1-UDP报文格式" class="headerlink" title="1 UDP报文格式"></a>1 UDP报文格式</h3><pre><code class="hljs asciidoc"><span class="hljs-code"> 0      7 8     15 16    23 24    31</span><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|     Source      |   Destination   ||      Port       |      Port       |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|     Length      |    Checksum     |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|               Data                ||                ...                |<span class="hljs-code">+-----------------------------------+</span>字段             大小       说明<span class="hljs-bullet">----             </span>----      ----Source Port      2B        源端口。Destination Port 2B        目标端口。Length           2B        长度（从Source Port到Data结束）。Checksum         2B        校验和（包括伪头部及UDP完整报文）。Data             n         数据。</code></pre><h3 id="2-伪头部"><a href="#2-伪头部" class="headerlink" title="2 伪头部"></a>2 伪头部</h3><p>在网络数据传递中，伪头部并不存在，其仅为了计算校验和而产生。</p><pre><code class="hljs asciidoc"><span class="hljs-code"> 0      7 8     15 16    23 24    31</span><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|              source               |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|            destination            |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+|  zero  |protocol|   UDP length    |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+字段         大小       说明<span class="hljs-bullet">----         </span>----      ----source       4B        IP源地址destination  4B        IP目的地址zero         1B        0。protocol     1B        IP报文头部的protocol字段。UDP length   n         UDP报文长度（从Source Port到Data结束，其值和UDP报文中的<span class="hljs-code">                       length相等）。</span></code></pre><h3 id="3-实现考虑"><a href="#3-实现考虑" class="headerlink" title="3 实现考虑"></a>3 实现考虑</h3><h4 id="检验和计算"><a href="#检验和计算" class="headerlink" title="检验和计算"></a>检验和计算</h4><ul><li>伪头部模块</li></ul><h4 id="提供给高层的接口"><a href="#提供给高层的接口" class="headerlink" title="提供给高层的接口"></a>提供给高层的接口</h4><ul><li><p>创建新的接收端口。</p></li><li><p>接收操作，接收报文后向高层传递UDP Data、Source Port、Source Address（IP）。</p><p>  <code>udp_recv_callback(data, size, src_ip, src_port)</code></p></li><li><p>发送操作，允许高层指定数据、源及目的的端口和IP地址。</p><p>  <code>udp_send(ip_src, src_port, ip_dest, dest_port, data, size)</code></p></li></ul><h4 id="对IP层的依赖"><a href="#对IP层的依赖" class="headerlink" title="对IP层的依赖"></a>对IP层的依赖</h4><ul><li><p>UDP要求IP模块提供至少能够确定IP头部中的source address、destination address以及protocol字段的接口。</p><p>  <code>udp_recv_from_ip(data, size, ip_src, ip_dest, ip_protocol)</code></p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://tools.ietf.org/html/rfc768">User Datagram Protocol</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>协议栈</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ethernet帧及其软件模块实现</title>
    <link href="/2021/01/12/Ethernet%E5%B8%A7%E5%8F%8A%E5%85%B6%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/01/12/Ethernet%E5%B8%A7%E5%8F%8A%E5%85%B6%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Ethernet帧及其软件模块实现"><a href="#Ethernet帧及其软件模块实现" class="headerlink" title="Ethernet帧及其软件模块实现"></a>Ethernet帧及其软件模块实现</h2><h3 id="1-Ethernet帧"><a href="#1-Ethernet帧" class="headerlink" title="1 Ethernet帧"></a>1 Ethernet帧</h3><pre><code class="hljs asciidoc"><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                       target address (6)                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                       source address (6)                      |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                         type/length (2)                       |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                           payload (n)                         | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            crc (4)                            | <span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段             字节数     说明<span class="hljs-bullet">----             </span>----      ----target address   6         目标地址。source address   6         源地址。type/length      2         类型/长度。payload          n         载荷。crc              4         校验。</code></pre><p>一般和IEEE 802.3标准相兼容的帧的长度在64和1518（0x5EE）个字节之间。当type/length的值超过最大长度时，该字段含义为type（例如0x800表示IP协议），反之为length。另外，当有效载荷小于46（46+6+6+2+4）个字节时需对载荷进行填充，使帧达到最小长度。</p><h3 id="2-实现考虑"><a href="#2-实现考虑" class="headerlink" title="2 实现考虑"></a>2 实现考虑</h3><p>Ether模块功能：</p><ul><li><p>提供接口给上下层</p>  <pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |   high level   |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">  |</span><span class="hljs-comment">  v ether_hl_send</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |     ether      |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">  ^ ether_ll_recv</span><span class="hljs-comment">  | </span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment"> |   low level    |</span><span class="hljs-comment"> +----------------+</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 底层调用此函数通知Ether模块接收帧数据</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_ll_recv</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;<span class="hljs-comment">// 高层调用此函数发送帧数据</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_hl_send</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;</code></pre></li><li><p>拆帧组帧</p>  <pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">uint8_t</span> *dest_mac_addr;    <span class="hljs-keyword">uint8_t</span> *src_mac_addr;    <span class="hljs-keyword">dblk_t</span> *payload;    <span class="hljs-keyword">uint16_t</span> type;    <span class="hljs-keyword">uint32_t</span> crc;    <span class="hljs-comment">//</span>    <span class="hljs-keyword">uint8_t</span> *data;    <span class="hljs-keyword">size_t</span> data_size;&#125; <span class="hljs-keyword">ether_frame_t</span>;<span class="hljs-comment">// 拆帧</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_unpack</span><span class="hljs-params">(<span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;<span class="hljs-comment">// 组帧</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_pack</span><span class="hljs-params">(<span class="hljs-keyword">ether_frame_t</span> *frame)</span></span>;</code></pre></li><li><p>硬件抽象</p>  <pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">// 驱动抽象</span>    <span class="hljs-keyword">size_t</span> (*send)(<span class="hljs-keyword">void</span> *interface, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size);    <span class="hljs-keyword">size_t</span> (*recv)(<span class="hljs-keyword">void</span> *interface, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size);    <span class="hljs-keyword">void</span> *interface;    <span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">ether_t</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_hl_send</span><span class="hljs-params">(<span class="hljs-keyword">ether_t</span>* ether, <span class="hljs-keyword">ether_frame_t</span> *frame)</span> </span>&#123;    frame-&gt;src_mac_addr = ether-&gt;mac_address,    ether_pack(frame); <span class="hljs-comment">// 组帧</span>    <span class="hljs-keyword">return</span> ether-&gt;send(ether-&gt;interface, frame-&gt;data, frame-&gt;data_size); <span class="hljs-comment">// 发送</span>&#125;</code></pre></li><li><p>帧分发</p><p>  ether收到数据且拆包正常后，根据type/length字段将载荷分发到高层模块。</p>  <pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ether_ll_recv</span><span class="hljs-params">(<span class="hljs-keyword">ehter_t</span> *e, <span class="hljs-keyword">ether_frame_t</span> *f)</span> </span>&#123;    f-&gt;data_size = e-&gt;recv(e-&gt;interface, f-&gt;data, f-&gt;data_size); <span class="hljs-comment">// 接收</span>    <span class="hljs-keyword">if</span> (f-&gt;data_size &gt; <span class="hljs-number">0</span> &amp;&amp; ether_unpack(f)) &#123; <span class="hljs-comment">// 拆帧</span>        <span class="hljs-keyword">switch</span> (f-&gt;type) &#123;            <span class="hljs-keyword">case</span> HIGH_LEVEL_1_TYPE: &#123;                <span class="hljs-comment">//...</span>                hl1_ll_recv(frame-&gt;payload)            &#125; <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//...</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><p>此代码见<a href="https://github.com/Doerthous/dts.net">dts.net</a>中的<code>ether</code>模块。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://tools.ietf.org/html/rfc894">A Standard for the Transmission of IP Datagrams over Ethernet Networks</a></p></li><li><p><a href="http://decnet.ipv7.net/docs/dundas/aa-k759a-tk.pdf">The Ethernet - A Local Area Network, Version 1.0, Digital Equipment Corporation, Intel Corporation, Xerox Corporation, September 1980</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>协议栈</tag>
      
      <tag>Ethernet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOOTP协议</title>
    <link href="/2021/01/12/BOOTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/12/BOOTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="BOOTP协议"><a href="#BOOTP协议" class="headerlink" title="BOOTP协议"></a>BOOTP协议</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1 目的"></a>1 目的</h3><p>为无盘系统<strong>确定IP地址</strong>及<strong>服务器地址</strong>及<strong>镜像文件位置</strong>，使得系统可以自举。</p><h3 id="2-两个阶段"><a href="#2-两个阶段" class="headerlink" title="2 两个阶段"></a>2 两个阶段</h3><ol><li><p>IP地址确定及镜像文件定位（RFC951主要内容）。</p></li><li><p>文件传输（通常为TFTP协议）。</p></li></ol><h4 id="阶段一交互逻辑"><a href="#阶段一交互逻辑" class="headerlink" title="阶段一交互逻辑"></a>阶段一交互逻辑</h4><p>客户端请求，服务端响应（响应数据可能含<strong>分配给客户端的IP地址</strong>及<strong>BOOT文件位置</strong>）。</p><h3 id="3-包格式"><a href="#3-包格式" class="headerlink" title="3 包格式"></a>3 包格式</h3><pre><code class="hljs txt"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |+---------------+---------------+---------------+---------------+|                            xid (4)                            |+-------------------------------+-------------------------------+|           secs (2)            |           reserved (2)        |+-------------------------------+-------------------------------+|                          ciaddr  (4)                          |+---------------------------------------------------------------+|                          yiaddr  (4)                          |+---------------------------------------------------------------+|                          siaddr  (4)                          |+---------------------------------------------------------------+|                          giaddr  (4)                          |+---------------------------------------------------------------+|                          chaddr  (16)                         |+---------------------------------------------------------------+|                          sname   (64)                         |+---------------------------------------------------------------+|                          file    (128)                        |+---------------------------------------------------------------+|                          vend    (64)                         |+---------------------------------------------------------------+字段      字节数     说明----      ----      ----op        1         包类型标志（1=BOOTREQUEST，2=BOOTREPLY）。htype     1         同ARP协议，见RFC826。hlen      1         同ARP协议。hops      1         网关可选使用该字段（客户端填0）。xid       4         会话ID，随机数，客户端产生，用于匹配REQUEST及REPLY。secs      2         自客户端尝试BOOT起所消耗的时间（秒），由客户端填充。reserved  2         保留。ciaddr    4         客户端IP地址（如果客户端BOOT有IP则填充，否则填0）。yiaddr    4         服务端分配给客户端的IP地址（如ciaddr为0则填充该字段）。siaddr    4         服务端IP地址（REPLY中由服务端填充）。giaddr    4         网关IP地址（其他角色填0）。chaddr    16        客户端硬件地址（客户端填充）。sname     64        服务端主机名，可选，null-结尾字符串。file      128       BOOT文件名（null串，通用名，全路径）。vend      64        可选。</code></pre><h3 id="4-“鸡生蛋，蛋生鸡”问题"><a href="#4-“鸡生蛋，蛋生鸡”问题" class="headerlink" title="4 “鸡生蛋，蛋生鸡”问题"></a>4 “鸡生蛋，蛋生鸡”问题</h3><p>问题：客户端没有IP地址，其请求IP地址时，服务端如何回复到客户端？</p><p>思路：如果客户端知道自己的IP地址（ciaddr不为零），则按该地址回复给客户端。如果客户端不知道自己的IP地址，且服务器可以通过某种方式修改ARP表，则将yiaddr与chaddr写入ARP表，然后正常发送。如果都不行，则采用广播。</p><h3 id="5-实现考虑"><a href="#5-实现考虑" class="headerlink" title="5 实现考虑"></a>5 实现考虑</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>ARP实现（要能够响应ARP请求，告知自己的地址）。</p></li><li><p>时间及定时器（超时重传）。</p></li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li><p>BOOTP数据库</p><ul><li><p>BOOTP表（与ARP表作用相反）</p></li><li><p>BOOT文件路径映射表</p></li></ul></li></ul><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h3><ul><li><p>假定IP层不分片</p></li><li><p>为什么使用两个端口</p><p>  避免<strong>其他BOOTP服务端</strong>被<strong>选定的服务端</strong>广播给客户端的REPLY包唤醒。</p></li><li><p>siaddr的作用</p><p>  告知客户端去哪里取BOOT文件。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://tools.ietf.org/html/rfc951">BOOTSTRAP PROTOCOL (BOOTP), RFC951</a></p></li><li><p><a href="https://tools.ietf.org/html/rfc2131">Dynamic Host Configuration Protocol, RFC2131</a></p></li><li><p><a href="https://tools.ietf.org/html/rfc826">An Ethernet Address Resolution Protocol, RFC826</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>协议栈</tag>
      
      <tag>BOOTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FatFS移植</title>
    <link href="/2021/01/10/FatFS%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/10/FatFS%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="FatFS移植"><a href="#FatFS移植" class="headerlink" title="FatFS移植"></a>FatFS移植</h2><p>此项目代码见<a href="https://github.com/Doerthous/dts.embedded">stm32f10x-mdk-none_fatfs</a>。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F103ZE </li><li>W25Q128</li></ul><p>软件：</p><ul><li>MDK 5.26.2.0</li><li>FatFS R0.14</li><li>STM32F10x StdPeriph Lib 3.5.0</li></ul><p>目录结构：</p><p>以下是移植过程中的项目目录结构。此处的目录结构非必须，可根据个人代码管理喜好进行。</p><pre><code class="hljs 1c">embedded├─bsp├─hal├─fs<span class="hljs-string">|  └─fatfs</span><span class="hljs-string">|     ├─ ...</span><span class="hljs-string">|     └─source</span><span class="hljs-string">|        ...</span>└─project   └─stm32f10x-mdk-none_fatfs      ├─bsp      ├─os      ├─hal      ├─fs      <span class="hljs-string">|  ├─diskio.c</span>      <span class="hljs-string">|  └─ffconf.h</span>      └─mdk</code></pre><h3 id="FatFS源码导入"><a href="#FatFS源码导入" class="headerlink" title="FatFS源码导入"></a>FatFS源码导入</h3><p>需要的文件有：</p><ul><li>ff.c</li><li>ffsystem.c</li><li>diskio.c (待实现的存储驱动)</li></ul><h3 id="实现IO驱动（diskio-c）"><a href="#实现IO驱动（diskio-c）" class="headerlink" title="实现IO驱动（diskio.c）"></a>实现IO驱动（diskio.c）</h3><p>参考FatFS源码中提供的diskio.c实现下述几个接口：</p><pre><code class="hljs C"><span class="hljs-function">DSTATUS <span class="hljs-title">disk_initialize</span> <span class="hljs-params">(BYTE pdrv)</span></span>;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_status</span> <span class="hljs-params">(BYTE pdrv)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_read</span> <span class="hljs-params">(BYTE pdrv, BYTE* buff, LBA_t sector, UINT count)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_write</span> <span class="hljs-params">(BYTE pdrv, <span class="hljs-keyword">const</span> BYTE* buff, LBA_t sector, UINT count)</span></span>;<span class="hljs-function">DRESULT <span class="hljs-title">disk_ioctl</span> <span class="hljs-params">(BYTE pdrv, BYTE cmd, <span class="hljs-keyword">void</span>* buff)</span></span>;</code></pre><p>针对W25Q128芯片，上述接口的简单实现如下：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;w25qxx.h&quot;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">w25qxx_t</span> w25q128;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_status</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-function">DSTATUS <span class="hljs-title">disk_initialize</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (w25qxx_init(&amp;w25q128)) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-function">DRESULT <span class="hljs-title">disk_read</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params">BYTE *buff,<span class="hljs-comment">/* Data buffer to store read data */</span></span></span><span class="hljs-function"><span class="hljs-params">DWORD sector,<span class="hljs-comment">/* Start sector in LBA */</span></span></span><span class="hljs-function"><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to read */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> rc;rc = w25qxx_read(&amp;w25q128, w25q128.sector_size * sector,buff, count * w25q128.sector_size);<span class="hljs-keyword">if</span> (rc) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> FF_FS_READONLY == 0</span><span class="hljs-function">DRESULT <span class="hljs-title">disk_write</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> BYTE *buff,<span class="hljs-comment">/* Data to be written */</span></span></span><span class="hljs-function"><span class="hljs-params">DWORD sector,<span class="hljs-comment">/* Start sector in LBA */</span></span></span><span class="hljs-function"><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to write */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> wc;<span class="hljs-keyword">for</span> (wc = <span class="hljs-number">0</span>; wc &lt; count; ++wc) &#123;w25qxx_erase_sector(&amp;w25q128, w25q128.sector_size * (sector + wc));&#125;wc = w25qxx_write(&amp;w25q128, w25q128.sector_size * sector,(<span class="hljs-keyword">uint8_t</span> *)buff, count * w25q128.sector_size);<span class="hljs-keyword">if</span> (wc) &#123;<span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_ERROR;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function">DRESULT <span class="hljs-title">disk_ioctl</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber (0..) */</span></span></span><span class="hljs-function"><span class="hljs-params">BYTE cmd,<span class="hljs-comment">/* Control code */</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span> *buff<span class="hljs-comment">/* Buffer to send/receive control data */</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">switch</span> (cmd) &#123; <span class="hljs-keyword">case</span> CTRL_SYNC: <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_SECTOR_COUNT: *(DWORD * )buff = w25q128.capacity / w25q128.sector_size; <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_SECTOR_SIZE: *(WORD * )buff = w25q128.sector_size; <span class="hljs-keyword">return</span> RES_OK;  <span class="hljs-keyword">case</span> GET_BLOCK_SIZE:  *(DWORD * )buff = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> RES_OK;&#125;<span class="hljs-keyword">return</span> RES_PARERR;&#125;</code></pre><p>完整文件见<a href="">diskio.c</a></p><h3 id="FatFS配置"><a href="#FatFS配置" class="headerlink" title="FatFS配置"></a>FatFS配置</h3><ul><li>设置扇区大小</li></ul><p>#define FF_MIN_SS        4096<br>#define FF_MAX_SS        4096</p><ul><li>启用MKFS接口</li></ul><p>#define FF_USE_MKFS        1</p><ul><li>不提供RTC</li></ul><p>#define FF_FS_NORTC        1</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fs_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">static</span> FATFS fs; <span class="hljs-comment">/* Filesystem object */</span>    <span class="hljs-keyword">static</span> FIL fil; <span class="hljs-comment">/* File object */</span>    <span class="hljs-keyword">static</span> BYTE work[FF_MAX_SS]; <span class="hljs-comment">/* Work area (larger is better for processing time) */</span>    FRESULT res; <span class="hljs-comment">/* API result code */</span>    UINT cnt;BYTE mm[<span class="hljs-number">50</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_ASSERT(cond, msg) \</span><span class="hljs-keyword">if</span> (!(cond)) &#123; \<span class="hljs-built_in">printf</span>(msg<span class="hljs-string">&quot; error\n&quot;</span>); \<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; \&#125; \<span class="hljs-keyword">else</span> &#123; \<span class="hljs-built_in">printf</span>(msg<span class="hljs-string">&quot; ok\n&quot;</span>); \&#125;    <span class="hljs-comment">// 挂载</span>res = f_mount(&amp;fs, <span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-number">0</span>);MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;mount&quot;</span>);    <span class="hljs-comment">// 新建FatFS</span>res = f_mkfs(<span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-literal">NULL</span>, work, <span class="hljs-keyword">sizeof</span>(work)); <span class="hljs-comment">//</span>MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;mkfs&quot;</span>);    <span class="hljs-comment">// 新建文件</span>res = f_open(&amp;fil, <span class="hljs-string">&quot;0:/a.txt&quot;</span>, FA_CREATE_NEW|FA_WRITE|FA_READ);MSG_ASSERT(res == FR_OK, <span class="hljs-string">&quot;open&quot;</span>);<span class="hljs-comment">// 写文件</span>res = f_write(&amp;fil, <span class="hljs-string">&quot;Hello,World!&quot;</span>, <span class="hljs-number">12</span>, &amp;cnt);MSG_ASSERT(res == FR_OK &amp;&amp; cnt == <span class="hljs-number">12</span>, <span class="hljs-string">&quot;write&quot;</span>);    <span class="hljs-comment">// 获取文件大小</span>cnt = f_size(&amp;fil);MSG_ASSERT(cnt == <span class="hljs-number">12</span>, <span class="hljs-string">&quot;size&quot;</span>);    <span class="hljs-comment">// 读文件</span><span class="hljs-built_in">memset</span>(mm, <span class="hljs-number">0x0</span>, <span class="hljs-number">50</span>);f_lseek(&amp;fil, <span class="hljs-number">0</span>);res = f_read(&amp;fil, mm, <span class="hljs-number">12</span>, &amp;cnt);MSG_ASSERT(res == FR_OK &amp;&amp; cnt == <span class="hljs-number">12</span> &amp;&amp; <span class="hljs-built_in">memcmp</span>(mm, <span class="hljs-string">&quot;Hello,World!&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;read&quot;</span>);f_close(&amp;fil);f_mount(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0:&quot;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS</a></li><li><a href="http://elm-chan.org/fsw/ff/archives.html">FatFS往期版本</a></li><li><a href="https://github.com/abbrev/fatfs.git">FatFS Github Mirror</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>文件系统</tag>
      
      <tag>FatFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F10x+RTThread+MDK移植</title>
    <link href="/2021/01/07/STM32F10x-RTThread-MDK%E7%A7%BB%E6%A4%8D/"/>
    <url>/2021/01/07/STM32F10x-RTThread-MDK%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="STM32F10x-RTThread-MDK移植"><a href="#STM32F10x-RTThread-MDK移植" class="headerlink" title="STM32F10x+RTThread+MDK移植"></a>STM32F10x+RTThread+MDK移植</h2><p>此项目代码见<a href="https://github.com/Doerthous/dts.embedded">stm32f10x-mdk-rtthread_empty</a>。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>硬件：</p><ul><li>STM32F103ZE </li></ul><p>软件：</p><ul><li>MDK 5.26.2.0</li><li>RTThread 4.0.0</li><li>STM32F10x StdPeriph Lib 3.5.0 </li></ul><p>目录结构：</p><p>以下是移植过程中的项目目录结构。此处的目录结构非必须，可根据个人代码管理喜好进行。</p><pre><code class="hljs lua">embedded├─bsp├─<span class="hljs-built_in">os</span>└─project   └─stm32f10x-mdk-rtthread_empty      ├─bsp      ├─<span class="hljs-built_in">os</span>      └─mdk</code></pre><h3 id="1-获取源码"><a href="#1-获取源码" class="headerlink" title="1. 获取源码"></a>1. 获取源码</h3><h4 id="获取BSP源码"><a href="#获取BSP源码" class="headerlink" title="获取BSP源码"></a>获取BSP源码</h4><p>下载STM32F10x对应的<a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">bsp源码</a>，拷贝到<code>embedded/bsp</code>目录中。</p><pre><code class="hljs erlang">embedded├─bsp│  ├─CMSIS│  └─STM32F10x_StdPeriph_Driver├─os|  ...└─project   ...</code></pre><h4 id="获取OS源码"><a href="#获取OS源码" class="headerlink" title="获取OS源码"></a>获取OS源码</h4><p>获取RTThread源码可通过下面两种方式进行，本教程使用第二种方式。</p><ul><li><p>直接下载某个版本的源码</p></li><li><p>使用<code>git submodule</code>将源码仓库拉到本地，并切换到指定版本</p></li></ul><p>进入<code>embedded/os</code>目录，执行<code>git submodule add https://github.com/RT-Thread/rt-thread.git</code>，待拉取结束后，<code>embedded/os</code>目录下将新增<code>rt-thread</code>目录，即为RTThread源码。</p><pre><code class="hljs 1c">embedded├─bsp<span class="hljs-string">|  ...</span>├─os<span class="hljs-string">|  └─rt-thread</span>└─project   ...</code></pre><p>进入<code>rt-thread</code>目录，执行<code>git checkout v4.0.0</code>切换到4.0.0版本的RTThread。</p><h3 id="2-拷贝项目相关源码"><a href="#2-拷贝项目相关源码" class="headerlink" title="2. 拷贝项目相关源码"></a>2. 拷贝项目相关源码</h3><ul><li>将和本项目直接相关的源码拷贝到<code>embedded/project/stm32f10x-mdk-rtthread_empty</code>（本节及其小节内简记为<code>stm32f10x-mdk-rtthread_empty</code>）及其子目录下。</li></ul><h4 id="拷贝BSP相关源码"><a href="#拷贝BSP相关源码" class="headerlink" title="拷贝BSP相关源码"></a>拷贝BSP相关源码</h4><ul><li>将<code>stm32f10x_conf.h</code>（可在STM32F10x StdPeriph Lib 3.5.0中找到）拷贝到<code>stm32f10x-mdk-rtthread_empty/bsp</code>目录下。</li></ul><h4 id="移植或从OS源码中拷贝相关源码"><a href="#移植或从OS源码中拷贝相关源码" class="headerlink" title="移植或从OS源码中拷贝相关源码"></a>移植或从OS源码中拷贝相关源码</h4><p>由于RTThread已经有了STM32F10X芯片的例程，所以本教程直接拷贝其源码。</p><ul><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/drivers</code>下的<code>board.c</code>及<code>board.h</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/bsp</code>目录下。</p></li><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/rtconfig.h</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/os</code>目录下。</p></li><li><p>将<code>embedded/os/rt-thread/bsp/stm32f10x/applications/startup.c</code>拷贝到<code>stm32f10x-mdk-rtthread_empty/app</code>目录下。</p></li></ul><h3 id="3-新建项目"><a href="#3-新建项目" class="headerlink" title="3. 新建项目"></a>3. 新建项目</h3><p>新建keil项目，并将项目文件(.uvprojx等文件)保存到<code>embedded/project/stm32f10x-mdk-rtthread_empty/mdk</code>中。</p><h3 id="4-将源码导入项目"><a href="#4-将源码导入项目" class="headerlink" title="4. 将源码导入项目"></a>4. 将源码导入项目</h3><h4 id="导入BSP源码"><a href="#导入BSP源码" class="headerlink" title="导入BSP源码"></a>导入BSP源码</h4><p>将下述文件导入到项目的bsp目录中</p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp/board.c</code></p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport/core_cm3.c</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/startup_stm32f10x_hd.s</code></p><p><code>embedded/bsp/STM32F10x_StdPeriph_Driver/src/misc.c</code></p><h4 id="导入OS源码"><a href="#导入OS源码" class="headerlink" title="导入OS源码"></a>导入OS源码</h4><p>将下述文件导入到项目的os目录中，</p><p><code>embedded/os/rt-thread/libcpu/arm/cortex-m3/cpuport.c</code><br><code>embedded/os/rt-thread/libcpu/arm/cortex-m3/context_rvds.S</code><br><code>embedded/os/rt-thread/src</code>下所有.c文件</p><h4 id="导入启动代码"><a href="#导入启动代码" class="headerlink" title="导入启动代码"></a>导入启动代码</h4><p>将下述文件导入到项目的app目录中，</p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp/startup.c</code></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>最终结果如下图，</p><p><img src="https://ftp.bmp.ovh/imgs/2021/01/93e69f86f18025a3.png" alt="p1"></p><h3 id="5-配置"><a href="#5-配置" class="headerlink" title="5. 配置"></a>5. 配置</h3><h4 id="配置项目include路径"><a href="#配置项目include路径" class="headerlink" title="配置项目include路径"></a>配置项目include路径</h4><p>将以下目录设置为include目录，</p><p><code>embedded/bsp/CMSIS/CM3/CoreSupport</code><br><code>embedded/bsp/CMSIS/CM3/DeviceSupport/ST/STM32F10x</code></p><p><code>embedded/bsp/STM32F10x_StdPeriph_Driver/inc</code></p><p><code>embedded/os/rt-thread/include</code></p><p><code>embedded/project/stm32f10x-mdk-rtthread_empty/bsp</code><br><code>embedded/project/stm32f10x-mdk-rtthread_empty/os</code></p><h4 id="配置BSP"><a href="#配置BSP" class="headerlink" title="配置BSP"></a>配置BSP</h4><h5 id="配置ST外设库"><a href="#配置ST外设库" class="headerlink" title="配置ST外设库"></a>配置ST外设库</h5><p>在keil中添加宏定义<code>USE_STDPERIPH_DRIVER</code>和<code>STM32F10X_HD</code>，修改<code>stm32f10x-mdk-rtthread_empty/bsp/stm32f10x_conf.h</code>配置，注释掉暂不使用的功能（非<code>misc.h</code>的头文件）。</p><pre><code class="hljs C"><span class="hljs-comment">//#include &quot;stm32f10x_adc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_bkp.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_can.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_cec.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_crc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dac.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dbgmcu.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_dma.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_exti.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_flash.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_fsmc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_gpio.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_i2c.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_iwdg.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_pwr.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_rcc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_rtc.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_sdio.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_spi.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_tim.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_usart.h&quot;</span><span class="hljs-comment">//#include &quot;stm32f10x_wwdg.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;misc.h&quot;</span> <span class="hljs-comment">/* High level functions for NVIC and SysTick (add-on to CMSIS functions) */</span></span></code></pre><h4 id="配置OS"><a href="#配置OS" class="headerlink" title="配置OS"></a>配置OS</h4><p>修改<code>stm32f10x-mdk-rtthread_empty/os/rtconfig.h</code>配置。</p><pre><code class="hljs C">...<span class="hljs-comment">// 注释掉暂不使用的功能</span><span class="hljs-comment">//#define RT_USING_POSIX</span><span class="hljs-comment">//#define RT_USING_DEVICE</span><span class="hljs-comment">//#define RT_USING_FINSH</span><span class="hljs-comment">//#define RT_USING_DFS</span><span class="hljs-comment">// 每秒1000次tick</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RT_TICK_PER_SECOND 1000</span>...</code></pre><p><code>startup.c</code>:</p><pre><code class="hljs C">...<span class="hljs-comment">// 添加测试程序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rt_init_thread_entry</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* parameter)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;rt_thread_delay(<span class="hljs-number">1000</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rt_application_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">rt_thread_t</span> init_thread;    init_thread = rt_thread_create(<span class="hljs-string">&quot;init&quot;</span>,                                   rt_init_thread_entry, RT_NULL,                                   <span class="hljs-number">2048</span>, <span class="hljs-number">8</span>, <span class="hljs-number">20</span>);    <span class="hljs-keyword">if</span> (init_thread != RT_NULL)        rt_thread_startup(init_thread);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;...</code></pre><p><code>board.c</code>:</p><pre><code class="hljs C">...<span class="hljs-comment">// 注释掉无效内容</span><span class="hljs-comment">//#include &quot;stm32f10x_fsmc.h&quot;</span><span class="hljs-comment">//#include &quot;usart.h&quot;</span><span class="hljs-comment">//rt_hw_usart_init();</span><span class="hljs-comment">//rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span>...</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32054.html">STM32F10x StdPeriph Lib 3.5.0</a></p></li><li><p><a href="https://www.rt-thread.org/">RTThread</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>RTOS移植</tag>
      
      <tag>MDK</tag>
      
      <tag>RTThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARP协议</title>
    <link href="/2020/11/07/ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/07/ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1 目的"></a>1 目的</h3><p>解决已知目标网络地址但未知其硬件地址时，如何获取目标硬件地址的问题。</p><h3 id="2-交互过程"><a href="#2-交互过程" class="headerlink" title="2 交互过程"></a>2 交互过程</h3><p>一子网中有A（192.168.1.101）、B（192.168.1.1）、X（X知道B的MAC地址）。A要发送数据给B，但不知道B的MAC地址：</p><p>A广播：谁有192.168.1.1的MAC地址，请告诉我（192.168.1.101）</p><p>X单播到A：192.168.1.1的MAC地址是AA:BB:CC:DD:EE:FF。</p><h3 id="3-ARP包格式"><a href="#3-ARP包格式" class="headerlink" title="3 ARP包格式"></a>3 ARP包格式</h3><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1                   2                   3</span><span class="hljs-code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|            hrd (2)            |             pro (2)           |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|     hln (1)   |     pln (1)   |             op (2)            |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            sha (n)                            ||                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            spa (m)                            ||                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            tha (n)                            | |                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+|                            tpa (m)                            | |                              ...                              |<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-<span class="hljs-code">+-+</span>-+字段      字节数     说明<span class="hljs-bullet">----      </span>----      ----hrd       2         硬件地址类型（1=Ethernet（以太网））。pro       2         网络地址类型（0x0800=IP）。hln       1         硬件地址长度（以太网地址长度6字节）。pln       1         网络地址长度（IP地址长度4字节）。op        2         操作码（1=REEQUEST，2=REPLY）。sha       n         源硬件地址，长度由hln指定。spa       m         源网络地址，长度由pln指定。tha       n         目标硬件地址，长度由hln指定。tpa       m         目标网络地址，长度由pln指定。</code></pre><h3 id="4-实现考虑"><a href="#4-实现考虑" class="headerlink" title="4 实现考虑"></a>4 实现考虑</h3><ul><li><p>ARP表</p><p>  以网络地址为key，硬件地址为value的数据库</p></li><li><p>ARP模块</p><p>  ARP协议本身并未假定某个硬件（Ethernet）或网络（IP），针对任意的<strong>硬件-网络</strong>协议对，都可以使用ARP协议解决获取硬件地址的问题。故可将ARP实现为<strong>ARP协议拆包组包模块</strong>及<strong>Ethernet-IP ARP模块</strong>。前者只负责ARP包的拆组，后者负责处理ARP交互逻辑。</p></li></ul><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h3><ul><li><p>Linux下抓包</p><p>  sudo tcpdump -i eth0 -x</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://tools.ietf.org/html/rfc826">An Ethernet Address Resolution Protocol</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>协议栈</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ENC28J60笔记</title>
    <link href="/2020/11/06/ENC28J60%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/06/ENC28J60%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ENC28J60笔记"><a href="#ENC28J60笔记" class="headerlink" title="ENC28J60笔记"></a>ENC28J60笔记</h1><p>本文记录了开发驱动过程中的大致实施思路以及踩过的一些坑，方便后续回顾。本文尚未完善，但已有基本思路，如后续有需要再进行细化。具体的细节还需参考芯片的数据手册。实现见<a href="https://github.com/Doerthous/dts_driver">dts_driver</a>中enc28j60*。</p><h2 id="供给协议栈的接口"><a href="#供给协议栈的接口" class="headerlink" title="供给协议栈的接口"></a>供给协议栈的接口</h2><p>和其他通讯硬件类似，ENC28J60提供给上层软件的接口基本上包括初始化接口和收发接口，其可能的形式如下（如无特殊说明，下文中提到的<strong>基本接口</strong>均指此处提到的软件接口）。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">enc28j60_init</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60)</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_send</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">enc28j60_recv</span><span class="hljs-params">(<span class="hljs-keyword">enc28j60_t</span> *enc28j60, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> size)</span></span>;</code></pre><p>此外，出于其他需要，可能还需实现一些管理、配置用的接口，不过我们暂时不关注这些。有了上述这些基本接口后，上层软件就可以将封装成以太网数据帧的数据发送到线缆上。关于以太网数据帧的说明在本文后续有简单地涉及，现在我们先把它当成黑盒子，划清驱动的范围，重点考虑如何实现这些接口。</p><h2 id="解剖ENC28J60"><a href="#解剖ENC28J60" class="headerlink" title="解剖ENC28J60"></a>解剖ENC28J60</h2><p>在考虑实现基本接口前，我们需要先熟悉一下ENC28J60。</p><p>通过查阅其手册可知，ENC28J60身提供了一个SPI接口和一个中断信号INT（其他暂不考虑）作为和外部设备通信的接口，其内部包含有用于各类特殊用途的<strong>寄存器</strong>和用于存放数据帧的硬件缓冲区（<strong>以太网缓冲</strong>），通过SPI接口，我们可以直接或间接地访问这些内存。</p><pre><code class="hljs gherkin">                                 ENC28J60                          +-----------------------------+                      |<span class="hljs-string">  +-------+  +------------+  </span>|                      |<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                      |<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   +--+--+  ETH  |<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Ethernet  </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  </span>|<span class="hljs-string">   Buffer   </span>|<span class="hljs-string">  </span>|                   +--+-------------+            |<span class="hljs-string">  </span>|+------------+     |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>||<span class="hljs-string"> Host       </span>|<span class="hljs-string"> SPI </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>||<span class="hljs-string"> Controller +-----+--+--+  MAC  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|+------------+     |<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  +------------+  </span>|                   |<span class="hljs-string">  </span>|<span class="hljs-string">  +-------+  +------------+  </span>|                   +--+--+  MII  +--+    PHY     |<span class="hljs-string">  </span>|                      |<span class="hljs-string">  +-------+  +------------+  </span>|                      +-----------------------------+</code></pre><h3 id="SPI接口"><a href="#SPI接口" class="headerlink" title="SPI接口"></a>SPI接口</h3><p>ENC28J60的SPI接口仅支持mode(0,0)模式，即<strong>空闲时时钟处于低电平</strong>，<strong>在第一个边沿采样</strong>。</p><p>ENC28J60的指令集包括：</p><ol><li>读控制寄存器指令（Read Control Register Command, RCR）</li><li>写控制寄存器指令（Write Control Register Command, WCR）</li><li>读以太网缓冲指令（Read Buffer Memory Command, RBM）</li><li>写以太网缓冲指令（Write Buffer Memory Command, WBM）</li><li>置位指令（Bit Field Set Command, BFS）</li><li>清零指令（Bit Field Clear Command, BFC）</li><li>系统复位指令（System Reset Command, SRC）</li></ol><p>其通信格式为：指令码(3 bits)+寄存器地址或固定值(5 bits)+数据(N bytes)。</p><table><thead><tr><th>指令</th><th>指令码</th><th>十六进制</th><th>地址/参数</th></tr></thead><tbody><tr><td>RCR</td><td>000b</td><td>00h</td><td>address</td></tr><tr><td>WCR</td><td>010b</td><td>02h</td><td>address</td></tr><tr><td>RBM</td><td>001b</td><td>01h</td><td>11010b</td></tr><tr><td>WBM</td><td>011b</td><td>03h</td><td>11010b</td></tr><tr><td>BFS</td><td>100b</td><td>04h</td><td>address</td></tr><tr><td>BFC</td><td>101b</td><td>05h</td><td>address</td></tr><tr><td>SRC</td><td>111b</td><td>07h</td><td>11111b</td></tr></tbody></table><p>具体时序见ENC28J60的数据手册。需要注意的是BFS和BFC指令只能用于ETH寄存器。另外，除了RBM和WBM指令，其他指令貌似均不能连续操作寄存器。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_RCR(addr)   (0x1F &amp; (addr))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_RBM         ((0x01 &lt;&lt; 5)|(0x1A))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_WCR(addr)   ((0x02 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_WBM         ((0x03 &lt;&lt; 5)|(0x1A))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_BFS(addr)   ((0x04 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_BFC(addr)   ((0x05 &lt;&lt; 5)|(0x1F &amp; (addr)))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMD_SRC         (0xFF)</span></code></pre><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>ENC28J60的寄存器大致可分为四类，包括ETH寄存器、MAC寄存器、MII寄存器以及PHY寄存器，其中除了PHY寄存器需要通过MII寄存器进行间接访问外，其余的寄存器均可以通过SPI接口进行访问。</p><p>ENC28J60的寄存器集合又被分到了四个区域（Bank），每个Bank有32个寄存器，所以每个Bank中的寄存器都可以通过一个5bit长的地址进行寻址，结合前边的SPI命令可知，每个SPI都可以寻址到任意一个Bank中的所有寄存器。</p><p>另外，每个Bank最后的5个寄存器（<code>EIE</code>、<code>EIR</code>、<code>ESTAT</code>、<code>ECON2</code>、<code>ECON1</code>）都相同，即无论在哪个Bank中，<code>EIE</code>（或其他四个）都是同一个，这样一来，访问这些寄存器就无需频繁地切换Bank。</p><p>Bank由<code>ECON1</code>中的两个比特<code>ECON1.BSEL</code>指定。所以，要想访问寄存器，一般要先选择Bank，在选择Bank中的寄存器。</p><pre><code class="hljs gherkin">      Bank0        Bank1        Bank2        Bank3     +----------+ +----------+ +----------+ +----------+0x00 |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     +----------+ +----------+ +----------+ +----------+     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ...      </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     |<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|     +----------+ +----------+ +----------+ +----------+0x1B |<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIE      </span>|     +----------+ +----------+ +----------+ +----------+0x1C |<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> EIR      </span>|     +----------+ +----------+ +----------+ +----------+0x1D |<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ESTAT    </span>|     +----------+ +----------+ +----------+ +----------+0x1E |<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON2    </span>|     +----------+ +----------+ +----------+ +----------+0x1F |<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> ECON1    </span>|     +----------+ +----------+ +----------+ +----------+</code></pre><h3 id="以太网缓冲区"><a href="#以太网缓冲区" class="headerlink" title="以太网缓冲区"></a>以太网缓冲区</h3><p>ENC28J60有一个8K的以太网缓冲，主要用来存储以太网数据帧数据。</p><p>该缓冲可通过两个寄存器<code>ERDPT</code>与<code>EWRPT</code>进行访问。<code>EWRPT</code>指向的位置是将要写入的位置，<code>ERDPT</code>则是将要读取的位置，结合这两个寄存器，主控可以通过<code>Read Buffer Memory</code>和<code>Read Buffer Memory</code>SPI指令来读写整个缓冲区。</p><p>通过将<code>ECON2</code>寄存器的<code>AUTOINC</code>位设置为1（<code>ECON2.AUTOINC</code>的复位值为1），还可以使这两个指针自动递增。</p><pre><code class="hljs c">            +-----------+            |           |  <span class="hljs-number">0x0000</span>            +-----------+ERDPT +---&gt; |           |  <span class="hljs-number">0x0001</span>            +-----------+            |           |            |    ...    |            |           |            +-----------+EWRPT +---&gt; |           |  <span class="hljs-number">0x1FFE</span>            +-----------+            |           |  <span class="hljs-number">0x1FFF</span>            +-----------+</code></pre><p>整个8K缓冲又被分为RX与TX两部分，通过设置寄存器<code>ERXSTPT</code>与<code>ERXNDPT</code>来划分RX缓冲，其余皆为TX缓冲。根据[1]中的Issue#5的描述，<code>ERXSTPT</code>必须设置为0x0000，所以整个缓冲的结构和下图类似。</p><p>在ENC28J60内部存在一个主控无法访问的指向RX区域的寄存器<code>ERXWRPT</code>。该寄存器的作用和<code>EWRPT</code>类似，作为ENC28J60接收数据时的写指针，即当收到以太网数据时，ENC28J60会将数据拷贝到<code>ERXWRPT</code>指向的以太网缓冲内存，并自动移动该指针。另外，还有个<code>ERXRDPT</code>寄存器，该寄存器用来作为RX队列的哨兵节点，标识RX队列的头部。</p><pre><code class="hljs c">              +-----------+  --+-----ERXSTPT +---&gt; |           |    ^              +-----------+    |              |           |    |              |    ...    |    |RX区域              |           |    |              +-----------+    |ERXNDPT +---&gt; |           |    v              +-----------+  --------              |           |    ^              |    ...    |    |              |           |    |TX区域              +-----------+    |              |           |    v              +-----------+  --+-----</code></pre><blockquote><p>注：ST（Start），ND（End）</p></blockquote><h4 id="TX缓冲指针"><a href="#TX缓冲指针" class="headerlink" title="TX缓冲指针"></a>TX缓冲指针</h4><p>前边说过<code>ERXSTPT</code>和<code>ERXNDPT</code>确定了RX缓冲的范围，而在ENC28J60提供的寄存器中，还存在<code>ETXSTPT</code>和<code>ETXNDPT</code>两个寄存器。但是这两个寄存器的作用并非用于确定TX缓冲的范围（RX缓冲范围确定后，剩余的都是TX缓冲），而是用来确定当前要发送的数据的范围。当把<code>ECON1.TXRTS</code>置1以启动发送后，ENC28J60会把从<code>ETXSTPT</code>到<code>ETXNDPT</code>的地方判定为当前需要发送的数据，接着把数据发送到线缆上。</p><pre><code class="hljs gherkin">    TX FIFO+--------------+|<span class="hljs-string"> +----------+ &lt;---ETXSTPT</span>|<span class="hljs-string"> </span>|<span class="hljs-string">ctrl byte </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> packet1  </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ &lt;---ETSNDPT</span>|<span class="hljs-string">      ...     </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">ctrl byte </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> packet2  </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> +----------+ </span>||<span class="hljs-string">      ...     </span>|+--------------+</code></pre><h4 id="RX队列"><a href="#RX队列" class="headerlink" title="RX队列"></a>RX队列</h4><p>ENC28J60的数据接收采用队列的形式，它在接收到的数据包前边添加了下一个数据包的指针（Next Packet Pointer），在RX缓冲中，其呈现了下述的形式。</p><p>我们通过<code>Read Buffer Memory</code>命令读取RX缓冲中的数据时，需要先设置<code>ERXRDPT</code>来确定读取的起始位置。在读取RX数据后，需要把Next Packet Pointer保存下来，以便读取下一个数据包时用于设置<code>ERXRDPT</code>。需要注意，<code>ERXRDPT</code>必须设置成奇数地址，而Next Packet Pointer总是偶数地址。</p><pre><code class="hljs gherkin">    RX FIFO+--------------+|<span class="hljs-string"> +----------+ </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">              </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------&lt;-+---+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">              </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------&lt;-+---+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> next ptr </span>|<span class="hljs-string">-+---+</span>|<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">  packet  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>||<span class="hljs-string"> +----------+ </span>|<span class="hljs-string">   </span>||<span class="hljs-string">      ...   &lt;-+---+</span><span class="hljs-string">+--------------+</span></code></pre><h4 id="RX缓冲写入细节"><a href="#RX缓冲写入细节" class="headerlink" title="RX缓冲写入细节"></a>RX缓冲写入细节</h4><p>ENC28J60接收线缆上的数据的伪代码大致如下，需要注意的是<code>erxwrpt == erxrdpt</code>的情况，该情况下，ENC28J60将判定缓冲区无多余空间存储新数据，之后将不再接收新数据，直到有空余的空间出现。</p><pre><code class="hljs properties"><span class="hljs-attr">struct</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxstpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxndpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxrdpt;</span>    <span class="hljs-attr">u8</span> <span class="hljs-string">*erxwrpt;</span><span class="hljs-meta">&#125;</span> <span class="hljs-string">rx_fifo;</span><span class="hljs-meta">enc28j60_write_data_to_rx_fifo(data,</span> <span class="hljs-string">size)</span>    <span class="hljs-attr">for</span> <span class="hljs-string">i=0~(size-1)</span>        <span class="hljs-attr">if</span> <span class="hljs-string">erxwrpt == erxrdpt:</span>            <span class="hljs-attr">rx</span> <span class="hljs-string">abort</span>        <span class="hljs-meta">*erxwrpt</span> = <span class="hljs-string">data[i]</span>        <span class="hljs-attr">increase</span> <span class="hljs-string">erxwrpt (make sure erxwrpt between erxstpt and erxndpt)</span></code></pre><p>ENC28J60把帧数据写到缓冲后会将<code>PKTCNT</code>加一，主控可通过查询<code>PKTCNT</code>判断当前缓冲中是否有数据帧，当主控从缓冲中读取一帧数据后，还需通过将<code>ECON2.PKTDEC</code>置1来递减<code>PKTCNT</code>，否则，一旦<code>PKTCNT</code>递增到255后，ENC28J60将不再接收线缆上的新数据帧。</p><h4 id="通过以太网缓冲与ENC28J60交互"><a href="#通过以太网缓冲与ENC28J60交互" class="headerlink" title="通过以太网缓冲与ENC28J60交互"></a>通过以太网缓冲与ENC28J60交互</h4><p>以太网缓冲区除了用来存放以太网数据帧外，还会放一些状态和控制数据。包括接收状态向量、发送状态向量以及发送控制字节。</p><p>主控在发送数据前，要先往发送缓冲区中写入一个控制字节，然后才将以太网帧数据写入到发送缓冲区。发送完一包数据后，ENC28J60会在包的尾部写入七个字节的发送状态向量，用于指示该包的发送状态。同样，收数据时，ENC28J60在往接收缓冲区中写入以太网帧数据前会先写入六个字节的接收状态向量。</p><h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>发送数据的过程如下所示，首先1)主控向缓冲区写入一个<strong>控制字节</strong>，然后2)写入以太网数据帧，启动发送并且发送完毕后，ENC28J60会3)在包尾部添加七个字节的<strong>发送状态向量</strong>，用于指示发送的状态及结果。</p><pre><code class="hljs gherkin">HostController      TX Buffer        ENC28J60            +---------------+            |<span class="hljs-string">      ...      </span>|            |<span class="hljs-string"> +-----------+ </span>|    1)--------+ ctrl byte |<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|    2)--------+  packet   |<span class="hljs-string"> </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|<span class="hljs-string">    </span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> transmit  +------3)</span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   status  </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string">      ...      </span>|            +---------------+</code></pre><h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>接收数据的过程如下所示，当有数据收到后，ENC28J60会1)先往缓冲区中写入一个<strong>接收状态向量</strong>，2)然后才写入真正的以太网数据帧。在收到信号或查询到有数据时，主控依次3)、4)读取<strong>接收状态向量</strong>和以太网数据帧。</p><pre><code class="hljs gherkin">HostController      RX Buffer        ENC28J60            +---------------+            |<span class="hljs-string">      ...      </span>|            |<span class="hljs-string"> +-----------+ </span>|<span class="hljs-string">    </span><span class="hljs-string">    3)--------+ receive   +------1)</span><span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string">   status  </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|    4)--------+  packet   +------2)            |<span class="hljs-string"> </span>|<span class="hljs-string">           </span>|<span class="hljs-string"> </span>|            |<span class="hljs-string"> +-----------+ </span>|            |<span class="hljs-string">      ...      </span>|            +---------------+</code></pre><h2 id="基本接口实现思路"><a href="#基本接口实现思路" class="headerlink" title="基本接口实现思路"></a>基本接口实现思路</h2><p>在参考了ENC20J68数据手册，并对ENC20J68的行为进行大致分析后，三个接口的实现思路如下。</p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><ol><li>初始化以太网缓冲（RX初始化ST、ND、RDPT）</li><li>设置接收过滤器（RX filter）</li><li>等待晶振稳定（修改MAC和PHY寄存器需等待时钟稳定）</li><li>MAC初始化</li><li>PHY初始化</li></ol><blockquote><p>Reset后初始化，一般初始化后，后续无需再初始化。</p></blockquote><h3 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h3><ol><li>设置EWRPT指针</li><li>将以太网数据帧拷贝到以太网缓冲中</li><li>设置ETXSTPT和ETXNDPT指针</li><li>启动传输</li><li>等待传输完毕</li><li>读取传输状态向量，判断传输状态</li></ol><h3 id="接收流程"><a href="#接收流程" class="headerlink" title="接收流程"></a>接收流程</h3><ol><li>检查PKTCNT寄存器，判断是否有收到数据包</li><li>设置Next Packet Pointer</li><li>读取接收状态向量</li><li>读取以太网数据帧</li><li>保存Next Packet Pointer</li><li>递减PKTCNT寄存器</li></ol><h2 id="ENC28J60的功能点"><a href="#ENC28J60的功能点" class="headerlink" title="ENC28J60的功能点"></a>ENC28J60的功能点</h2><h3 id="以太网数据帧"><a href="#以太网数据帧" class="headerlink" title="以太网数据帧"></a>以太网数据帧</h3><ul><li>发送时可通过控制<code>MACON3.PADCFG</code>使其自动添加CRC以及Padding。</li><li>接收时通过设置<code>ERXFCON.CRCEN</code>对收到的帧进行CRC校验。</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>ENC28J60有多个中断源和一个总中断开关，中断配置主要涉及了<code>EIE</code>，<code>EIR</code>以及<code>ESTAT</code>寄存器。本文只关注TXIE、PKTIE、TXERIE、RXERIE这四个中断，以及INTE总中断开关。</p><p>ENC28J60数据手册中有一张清晰表示了其中断逻辑的逻辑门图，此处简要用代码表述了其原理，更多信息请参考ENC28J60的数据手册。</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (TXIE and TXIF) <span class="hljs-comment">// 发送结束中断开关 及 发送结束中断标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (PKTIE and PKTIF) <span class="hljs-comment">// 收到PKT中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (TXERTIE and TXERIF) <span class="hljs-comment">// 发送异常中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span><span class="hljs-keyword">if</span> (RXERTIE and RXERIF) <span class="hljs-comment">// 接收异常中断开关 及 其标志</span>    <span class="hljs-keyword">INT</span> = <span class="hljs-keyword">true</span>... <span class="hljs-comment">// 其他中断信号</span><span class="hljs-keyword">if</span> (INTIE &amp;&amp; <span class="hljs-keyword">INT</span>) <span class="hljs-comment">// 总中断开关 及 其标志</span>    拉低<span class="hljs-keyword">INT</span>信号线</code></pre><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><ul><li>半双工模式下，可以通过控制<code>EFLOCON.FCEN0</code>来一直发送前导码，以占用信道，类似在说，我在用。设置<code>ECON1.TXRTS</code>后（启动发送），有一个间隔，间隔结束后开始发送packet。</li></ul><h2 id="容易掉坑的地方"><a href="#容易掉坑的地方" class="headerlink" title="容易掉坑的地方"></a>容易掉坑的地方</h2><ul><li><p>RX缓冲必须从0x0000地址起始，即<code>ERXSTPT</code>必须设置为0x0000。</p></li><li><p><code>ERXRDPT</code>必须设置成奇数地址。</p></li><li><p>SPI时序不匹配或时钟频率过低、dummy byte没有处理、bank不正确、晶振不稳定可能导致寄存器读写不正常。</p></li><li><p>复位后要等待晶振稳定（通过<code>ESTAT.CLKRDY</code>判断）才能收发数据或访问MAC、MII、PHY寄存器。</p></li><li><p><code>Bit Field Set</code>、<code>Bit Field Clear</code>指令中，别多传Data，有些Data会跑到下一个地址，导致程序逻辑错误。比如，往<code>ECON2.PKTDEC</code>写1时，多写一次会写到下一个地址相同位的地方，即ECON1.RXRST，导致接收异常。</p></li><li><p><code>Bit Field Set</code>、<code>Bit Field Clear</code>指令只能用于ETH寄存器。</p></li><li><p>当<code>MACON3.FULDPX</code>和<code>PHCON1.PDPXMD</code>所指示的全/半双工状态不相同时，芯片处于未定义状态。</p></li><li><p>接收逻辑使能（<code>ECON1.RXEN</code>为1）时，不可以改变<code>ERXST</code>和<code>ERXND</code>指针。</p></li><li><p>更改<code>ERXRDPT</code>时，必须先写<code>ERXRDPTL</code>，后写<code>ERXRDPTH</code>。</p></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h3><p>以太网帧结构按序包括下述字段：</p><p>目标MAC地址、源MAC地址、类型/长度、有些载荷、填充数据、CRC校验。</p><p>CRC校验的内容包括目标MAC地址、源MAC地址、类型/长度、有些载荷、填充数据。一般和IEEE 802.3标准相兼容的帧的长度在64和1518个字节之间，所以当有效载荷小于46（46+6+6+2+4）个字节时需要填充数据。</p><p>另外，除了在发送以太网帧之前，PHY还会发送前导码和帧分隔。</p><h3 id="Linux下收发以太网帧"><a href="#Linux下收发以太网帧" class="headerlink" title="Linux下收发以太网帧"></a>Linux下收发以太网帧</h3><p><a href="https://stackoverflow.com/questions/24355597/linux-when-sending-ethernet-frames-the-ethertype-is-being-re-written">源码见本问题回答</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>全双工模式中的暂停控制帧（IEEE 802.3）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>[1] <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/80349c.pdf">ENC28J60 Silicon Errata and Data Sheet Clarification</a></p></li><li><p>[2] <a href="https://pdf1.alldatasheet.com/datasheet-pdf/view/515823/MICROCHIP/ENC28J60.html">ENC28J60 Data Sheet</a></p></li><li><p>[3] <a href="https://stackoverflow.com/questions/24355597/linux-when-sending-ethernet-frames-the-ethertype-is-being-re-written">Linux: When sending Ethernet frames the ethertype is being re-written</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>驱动</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python ArgParse笔记</title>
    <link href="/2020/11/02/Python-ArgParse%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/02/Python-ArgParse%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="可选参数和位置参数"><a href="#可选参数和位置参数" class="headerlink" title="可选参数和位置参数"></a>可选参数和位置参数</h2><p>可选参数由类似<code>add_argument(&#39;-f&#39;,&#39;--foo&#39;)</code>的语句创建，<code>add_argument(&#39;foo&#39;)</code>创建位置参数。当调用<code>parse_args()</code>时，带<code>-</code>前缀的将被识别为可选参数，剩余的被识别为位置参数。</p><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>通过调用<a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method">add_argument</a>可设置参数的一些属性，如默认值、参数类型等。</p><h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>子命令通过<a href="https://docs.python.org/3/library/argparse.html#sub-commands">add_subparsers</a>创建，</p><pre><code class="hljs python">parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_a = subparsers.add_parser(<span class="hljs-string">&#x27;cmd1&#x27;</span>)<span class="hljs-comment"># parser_a.add_argument ...</span>parser_b = subparsers.add_parser(<span class="hljs-string">&#x27;cmd2&#x27;</span>)<span class="hljs-comment"># parser_b.add_argument ...</span></code></pre><p>用法上，除了在调用时需指定子命令外（如<code>python p.py cmd1 ...</code>），其余基本相同。</p><h2 id="一些需求"><a href="#一些需求" class="headerlink" title="一些需求"></a>一些需求</h2><h3 id="两种执行模式"><a href="#两种执行模式" class="headerlink" title="两种执行模式"></a>两种执行模式</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py -s</code>执行另一种操作</li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&#x27;-s&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>)args = parser.parse_args()<span class="hljs-keyword">if</span> args.s:    print(<span class="hljs-string">&#x27;python p.py -s&#x27;</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)</code></pre><h3 id="互斥的多模式"><a href="#互斥的多模式" class="headerlink" title="互斥的多模式"></a>互斥的多模式</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py s</code>执行另一种操作</li><li><code>python p.py r</code>执行另一种操作</li><li>1,2,3互斥</li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_r</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py r&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_s</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py s&#x27;</span>)parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_s = subparsers.add_parser(<span class="hljs-string">&#x27;s&#x27;</span>)parser_s.set_defaults(func=func_s)parser_r = subparsers.add_parser(<span class="hljs-string">&#x27;r&#x27;</span>)parser_r.set_defaults(func=func_r)args = parser.parse_args()<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(args, <span class="hljs-string">&#x27;func&#x27;</span>):    args.func = funcargs.func(args)</code></pre><h3 id="带参命令"><a href="#带参命令" class="headerlink" title="带参命令"></a>带参命令</h3><ol><li><code>python p.py</code>执行一种操作</li><li><code>python p.py s</code>执行另一种操作</li><li><code>python p.py r</code>执行另一种操作</li><li>1,2,3互斥</li><li><code>python p.py r [-t title]</code>提供可选参数<code>title</code>, 默认为<code>&#39;&#39;</code></li></ol><p>实现</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_r</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py r title:%s&#x27;</span> % args.title)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_s</span>(<span class="hljs-params">args</span>):</span>    print(<span class="hljs-string">&#x27;python p.py s&#x27;</span>)parser = argparse.ArgumentParser()subparsers = parser.add_subparsers()parser_s = subparsers.add_parser(<span class="hljs-string">&#x27;s&#x27;</span>)parser_s.set_defaults(func=func_s)parser_r = subparsers.add_parser(<span class="hljs-string">&#x27;r&#x27;</span>)parser_r.set_defaults(func=func_r)parser_r.add_argument(<span class="hljs-string">&#x27;-t&#x27;</span>, <span class="hljs-string">&#x27;--title&#x27;</span>, type=str, default=<span class="hljs-string">&#x27;&#x27;</span>, required=<span class="hljs-literal">False</span>)args = parser.parse_args()<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(args, <span class="hljs-string">&#x27;func&#x27;</span>):    args.func = funcargs.func(args)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>使用记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>已知前（后）序及中序遍历，求后（前）序</title>
    <link href="/2020/10/14/%E5%B7%B2%E7%9F%A5%E5%89%8D%EF%BC%88%E5%90%8E%EF%BC%89%E5%BA%8F%E5%8F%8A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E5%90%8E%EF%BC%88%E5%89%8D%EF%BC%89%E5%BA%8F/"/>
    <url>/2020/10/14/%E5%B7%B2%E7%9F%A5%E5%89%8D%EF%BC%88%E5%90%8E%EF%BC%89%E5%BA%8F%E5%8F%8A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E5%90%8E%EF%BC%88%E5%89%8D%EF%BC%89%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>已知二叉树的前/后序及中序遍历，求后/前序遍历。</p><p>典型题目：已知二叉树中序遍历为ADEFGHMZ，后序遍历为AEFDHZMG，求前序遍历。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前中后序列遍历的基本概念 =&gt; 前中后序遍历的规律 =&gt; 算法思路</p><h3 id="前中后序遍历的基本概念"><a href="#前中后序遍历的基本概念" class="headerlink" title="前中后序遍历的基本概念"></a>前中后序遍历的基本概念</h3><pre><code class="hljs C">  P / \L   R</code></pre><p>前序（pre-order）: PLR<br>中序（in-order）: LPR<br>后序（post-order）: LRP</p><p>序指的是根节点在左右子树中的位置：根左右、左根右、左右根。</p><h3 id="前中后序列遍历的规律"><a href="#前中后序列遍历的规律" class="headerlink" title="前中后序列遍历的规律"></a>前中后序列遍历的规律</h3><ul><li>前序遍历：如果在同一颗树内，最前边的节点是根节点。</li><li>中序遍历：如果在同一颗树内，根左边的是左子树，根右边的是右子树。</li><li>后序遍历：如果在同一颗树内，最后边的节点是根节点。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>通过前序（后序）遍历，找到树的根节点。</li><li>通过根节点及中序遍历，划分左右子树。</li><li>对左右子树递归进行步骤1、2，直到子树划分完毕。</li></ol><p>总结：找根节点、划分左右子树。</p><h4 id="人型电脑实验"><a href="#人型电脑实验" class="headerlink" title="人型电脑实验"></a>人型电脑实验</h4><p>已知二叉树中序遍历为ADEFGHMZ，后序遍历为AEFDHZMG，求前序遍历。</p><h5 id="解"><a href="#解" class="headerlink" title="解"></a>解</h5><p>1th，看后序得知根节点为G，看中序划分左子树ADEF和右子树HMZ</p><pre><code class="hljs latex">    G  /   <span class="hljs-tag">\</span>ADEF  HMZ</code></pre><p>2th</p><pre><code class="hljs dns">  D / \<span class="hljs-keyword">A</span>  EF</code></pre><p>3th</p><pre><code class="hljs mathematica">  F /<span class="hljs-keyword">E</span></code></pre><p>4th</p><pre><code class="hljs latex">  M / <span class="hljs-tag">\</span>H   Z</code></pre><p>tree</p><pre><code class="hljs latex">     G   /   <span class="hljs-tag">\</span>  D     M / <span class="hljs-tag">\<span class="hljs-name"> </span></span>  / <span class="hljs-tag">\</span>A   F H   Z   /  E</code></pre><p>故前序遍历为：GDAFEMHZ</p><h2 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs matlab">v bt_preorder(t, op)v bt_inorder(t, op)v bt_postorder(t, op)t bt_solve_from_inpostorder(in, in_len post, post_len)&#123;    r = post[post_len<span class="hljs-number">-1</span>]    <span class="hljs-built_in">find</span> in[<span class="hljs-built_in">i</span>] == r    r-&gt;left = bt_solve_from_inpostorder(in, <span class="hljs-built_in">i</span>, post, <span class="hljs-built_in">i</span>)    r-&gt;right = bt_solve_from_inpostorder(in+<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>, in_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,         post+<span class="hljs-built_in">i</span>, post_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> r;&#125;t bt_solve_from_inpreorder(in, in_len pre, pre_len)&#123;    r = pre[<span class="hljs-number">0</span>]    <span class="hljs-built_in">find</span> in[<span class="hljs-built_in">i</span>] == r    r-&gt;left = bt_solve_from_inpreorder(in, <span class="hljs-built_in">i</span>, pre+<span class="hljs-number">1</span>, <span class="hljs-built_in">i</span>)    r-&gt;right = bt_solve_from_inpreorder(in+<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>, in_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,         pre+<span class="hljs-number">1</span>+<span class="hljs-built_in">i</span>, pre_len-<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> r;&#125;</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> key;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span> *<span class="hljs-title">left</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bt</span> *<span class="hljs-title">right</span>;</span>&#125; <span class="hljs-keyword">bt_t</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_preorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        op(bt);        bt_preorder(bt-&gt;left, op);        bt_preorder(bt-&gt;right, op);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_inorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        bt_inorder(bt-&gt;left, op);        op(bt);        bt_inorder(bt-&gt;right, op);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_postorder</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt, <span class="hljs-keyword">void</span> (*op)(<span class="hljs-keyword">bt_t</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt) &#123;        bt_postorder(bt-&gt;left, op);        bt_postorder(bt-&gt;right, op);        op(bt);    &#125;&#125;<span class="hljs-keyword">bt_t</span> *bt_solve_from_inpostorder(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int</span> in_len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *post, <span class="hljs-keyword">int</span> post_len)&#123;    <span class="hljs-keyword">if</span> (post_len &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">bt_t</span> *r = (<span class="hljs-keyword">bt_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(bt));        assert(r);        r-&gt;key = post[post_len<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; in_len &amp;&amp; in[i] != r-&gt;key; ++i);        r-&gt;left = bt_solve_from_inpostorder(in, i, post, i);        r-&gt;right = bt_solve_from_inpostorder(in+i+<span class="hljs-number">1</span>, in_len-i<span class="hljs-number">-1</span>,             post+i, post_len-i<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">bt_t</span> *bt_solve_from_inpreorder(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int</span> in_len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pre, <span class="hljs-keyword">int</span> pre_len)&#123;    <span class="hljs-keyword">if</span> (pre_len &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">bt_t</span> *r = (<span class="hljs-keyword">bt_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(bt));        assert(r);        r-&gt;key = pre[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; in_len &amp;&amp; in[i] != r-&gt;key; ++i);        r-&gt;left = bt_solve_from_inpreorder(in, i, pre+<span class="hljs-number">1</span>, i);        r-&gt;right = bt_solve_from_inpreorder(in+i+<span class="hljs-number">1</span>, in_len-i<span class="hljs-number">-1</span>,             pre+<span class="hljs-number">1</span>+i, pre_len-i<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bt_node_print</span><span class="hljs-params">(<span class="hljs-keyword">bt_t</span> *bt)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, bt-&gt;key);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in = <span class="hljs-string">&quot;ADEFGHMZ&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *post = <span class="hljs-string">&quot;AEFDHZMG&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pre = <span class="hljs-string">&quot;GDAFEMHZ&quot;</span>;    <span class="hljs-keyword">bt_t</span> *bt = bt_solve_from_inpostorder(in, <span class="hljs-number">8</span>, post, <span class="hljs-number">8</span>);    bt_preorder(bt, bt_node_print);    bt_postorder(bt, (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">bt_t</span> *))<span class="hljs-built_in">free</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        bt = bt_solve_from_inpreorder(in, <span class="hljs-number">8</span>, pre, <span class="hljs-number">8</span>);    bt_postorder(bt, bt_node_print);    bt_postorder(bt, (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">bt_t</span> *))<span class="hljs-built_in">free</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake笔记</title>
    <link href="/2020/10/12/CMake%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/12/CMake%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake笔记"><a href="#CMake笔记" class="headerlink" title="CMake笔记"></a>CMake笔记</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量设置与打印"><a href="#变量设置与打印" class="headerlink" title="变量设置与打印"></a>变量设置与打印</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/set.html">set</a>命令设置变量名及其对应值，通过<code>$&#123;变量名&#125;</code>的方式引用变量。<a href="https://cmake.org/cmake/help/v3.18/command/message.html">message</a>可打印信息。</p><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(VAR_A <span class="hljs-number">100</span>)<span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;VAR_A&#125;</span>)</code></pre><p>输出：</p><pre><code class="hljs Bash">...-- 100...</code></pre><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>同大多数编程语言一样，<a href="https://cmake.org/cmake/help/v3.18/command/if.html">if</a>用于条件控制。需要注意的是，cmake中<code>&lt;condition&gt;</code>的写法会使用<code>EQUAL</code>, <code>LESS</code>, <code>LESS_EQUAL</code>等关键字，判定为TRUE的条件可能有所复杂。</p><pre><code class="hljs CMake"><span class="hljs-keyword">if</span>(&lt;condition&gt;)    &lt;commands&gt;<span class="hljs-keyword">elseif</span>(&lt;condition&gt;)    &lt;commands&gt;<span class="hljs-keyword">else</span>()    &lt;commands&gt;<span class="hljs-keyword">endif</span>()</code></pre><h3 id="foreach与list"><a href="#foreach与list" class="headerlink" title="foreach与list"></a>foreach与list</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/list.html">list</a>是cmake中一种类似数组的结构（元素可以不同），<a href="https://cmake.org/cmake/help/v3.18/command/foreach.html">foreach</a>命令则用于遍历操作。</p><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">1</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">2</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">3</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">4</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">5</span>)<span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;LIST_A&#125;</span>)<span class="hljs-keyword">foreach</span>(X IN LISTS LIST_A)    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;X=$&#123;X&#125;&quot;</span>)<span class="hljs-keyword">endforeach</span>()</code></pre><p>输出：</p><pre><code class="hljs Bash">...-- 12345-- X=1-- X=2-- X=3-- X=4-- X=5...</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><a href="https://cmake.org/cmake/help/v3.18/command/function.html">function</a>指令可定义函数。</p><pre><code class="hljs CMake"><span class="hljs-keyword">function</span>(F1 <span class="hljs-keyword">list</span>)    <span class="hljs-keyword">foreach</span>(X IN LISTS <span class="hljs-variable">$&#123;list&#125;</span>)        <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;X=$&#123;X&#125;&quot;</span>)    <span class="hljs-keyword">endforeach</span>()<span class="hljs-keyword">endfunction</span>()<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">1</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">2</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">3</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">4</span>)<span class="hljs-keyword">list</span>(APPEND LIST_A <span class="hljs-number">5</span>)F1(LIST_A)</code></pre><p>输出：</p><pre><code class="hljs Bash">-- X=1-- X=2-- X=3-- X=4-- X=5</code></pre><h2 id="E1-1-Hello-World"><a href="#E1-1-Hello-World" class="headerlink" title="E1.1 Hello World"></a>E1.1 Hello World</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>通过CMake编译、构建一个Hello World程序</li></ul><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>最简单的CMake工程目录如下所示</p><pre><code class="hljs shell">.├─ CMakeLists.txt└─ main.cpp</code></pre><p>CMakeLists.txt内容如下</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">add_executable</span>(main main.cpp)</code></pre><p>main.cpp内容如下</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在工程目录中新建build目录，然后进入build目录下执行<code>cmake ..</code>，再执行<code>cmake --build .</code></p><blockquote><p>Linux下用<code>cmake ..</code>和<code>make</code>指令进行构建</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>project(CMake_Note)</code>指定项目名称，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/project.html">project</a></p></li><li><p><code>add_executable(main main.cpp)</code>添加一个可执行程序Target，将main.cpp编译为可执行程序，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/add_executable.html">add_executable</a></p></li></ul><h2 id="E1-2-生成动态库与静态库"><a href="#E1-2-生成动态库与静态库" class="headerlink" title="E1.2 生成动态库与静态库"></a>E1.2 生成动态库与静态库</h2><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><ul><li>通过CMake生成构建静态库与动态库</li></ul><h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><p>在E1.1基础上新增hello.h及hello.cpp文件，其内容分别如下</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HELLO_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_H_</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// HELLO_H_</span></span></code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello %s!\n&quot;</span>, what);&#125;</code></pre><p>将CMakeLists.txt与main.cpp分别修改为以下内容</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    hello(<span class="hljs-string">&quot;Function&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>add_library(hello hello.cpp)</code>添加一个库文件Target，将hello.cpp编译为库文件，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/add_library.html">add_executable</a></p></li><li><p>使用<code>add_library(hello STATIC hello.cpp)</code>可以强制生成静态库，<code>add_library(hello SHARED hello.cpp)</code>同理。具体见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html#binary-library-types">Binary Library Types</a></p></li><li><p><code>target_link_libraries(main hello)</code>表示将hello链接到main中，具体语法见<a href="https://cmake.org/cmake/help/v3.18/command/target_link_libraries.html">target_link_libraries</a>。需要注意的是，<code>target_link_libraries</code>在添加Target之后，在本例子中的体现是该语句在<code>add_executable(main main.cpp)</code>之后。</p></li></ul><h2 id="E1-3-改变输出文件路径"><a href="#E1-3-改变输出文件路径" class="headerlink" title="E1.3 改变输出文件路径"></a>E1.3 改变输出文件路径</h2><h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><ul><li>将可执行程序与库文件分别输出到bin与lib文件夹</li></ul><h3 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h3><p>在E1.2基础上将CMakeLists.txt修改为以下内容</p><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ul><li><p>基本上，<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>指定可执行文件的输出路径，<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>指定库文件的输出路径。</p></li><li><p><code>CMAKE_BINARY_DIR</code>表示执行<code>cmake</code>命令时所在的路径，在本例子中为<code>build</code>目录。还有一个<code>CMAKE_SOURCE_DIR</code>表示工程源码路径，在本例子中为<code>CMakeLists.txt</code>所在路径。另外还有两个类似的目录，<code>CMAKE_CURRENT_BINARY_DIR</code>与<code>CMAKE_CURRENT_SOURCE_DIR</code>，当cmake工程发生嵌套时，不带CURRENT的变量指顶层CMake工程，带CURRENT的则指当前CMake工程。具体定义见<a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_SOURCE_DIR.html#variable:CMAKE_SOURCE_DIR">CMAKE_SOURCE_DIR</a>。</p></li><li><p>不同平台下，输出文件的路径由不同的变量控制可能不同。例如window下与linux下的动态库文件，在window下，动态库输出路径由<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>指定，linux下则由<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>指定，具体解释见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html#output-artifacts">Output Artifacts</a></p></li><li><p>window平台下，cmake可能会根据不同的构建类型（Debug或Release）将输出文件归类到对应类型的文件夹下，为避免该情况，可将上述CMakeLists.txt新增的内容改为</p>  <pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)</code></pre><p>  参考<a href="https://stackoverflow.com/questions/543203/cmake-runtime-output-directory-on-windows">CMake Runtime Output Directory On Windows</a></p></li></ul><h2 id="E1-4-分离可执行程序与库文件"><a href="#E1-4-分离可执行程序与库文件" class="headerlink" title="E1.4 分离可执行程序与库文件"></a>E1.4 分离可执行程序与库文件</h2><h3 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h3><ul><li>了解如何使用add_subdirectory直接将库的源码工程导入到应用（APP）工程，了解CMake的Target概念</li></ul><h3 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h3><p>在E1.3基础上分离可执行程序工程与库工程，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello│   ├─ CMakeLists.txt│   ├─ hello.h│   └─ hello.cpp└─ main.cpp</code></pre><p>CMakeLists.txt内容为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(MAIN)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">add_subdirectory</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><p>hello/CMakeLists.txt内容为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;)</code></pre><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><ul><li><p>hello文件夹中本身是一个独立的CMake工程（HELLO工程）</p></li><li><p><code>add_subdirectory(lib)</code>将hello库的CMake源码工程直接导入到当前工程（MAIN工程）中，所以当前工程可以直接引用到<code>hello</code>Target，<code>add_executable</code>，<code>add_library</code>都能产生Target，如HELLO工程中产生了<code>hello</code>Target，MAIN工程中产生了<code>main</code>Target，且<code>main</code>依赖<code>hello</code>。<a href="https://cmake.org/cmake/help/v3.18/command/add_subdirectory.html">add_subdirectory</a>是引用外部库的方式之一（通过直接引入库源码的方式）。</p></li><li><p><code>target_include_directories(hello $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)</code>将指定目录绑定到指定Target中。在HELLO工程中，<code>target_include_directories</code>将hello库的源码目录（即<code>CMAKE_CURRENT_SOURCE_DIR</code>-&gt;hello）绑定到<code>hello</code>Target上，所以当链接<code>hello</code>Target时，<code>main</code>Target也以该目录作为include目录，所以main.cpp中能直接<code>#include &quot;hello.h&quot;</code>。具体见<a href="https://cmake.org/cmake/help/v3.18/command/target_include_directories.html">target_include_directories</a>。在HELLO工程中，<code>target_include_directories</code>使用了PUBLIC进行修饰，PUBLIC后的目录可以对外传递。当指定为PRIVATE时，目录不会对外传递，所以这种情况下，main.cpp中的<code>#include &quot;hello.h&quot;</code>将报出找不到头文件的错误。除了PUBLIC外，例子中还用了<code>$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;</code>进行修饰，表示只有在构建（Build）时才会传递指定的目录。所以，当MAIN工程不是直接包含HELLO工程源码来引用<code>hello</code>Target时（如hello库已经以二进制的形式安装在本地环境中，此时需要使用<code>$&lt;INSTALL_INTERFACE:...&gt;</code>），该指定目录不会被传递给<code>main</code>Target。具体见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-generator-expressions.7.html#output-related-expressions">Output-Related Expressions</a></p><blockquote><p><strong>Target自身带有某些属性，如该Target包含了哪些include目录，链接了哪些Target。某些Target属性会传递到引用该Target的Target上</strong>。</p></blockquote></li></ul><h2 id="E1-5-configure-file用法"><a href="#E1-5-configure-file用法" class="headerlink" title="E1.5 configure_file用法"></a>E1.5 configure_file用法</h2><h3 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h3><ul><li>熟悉模板配置，实现通过CMake变量控制生成不同的源文件</li></ul><h3 id="例程-4"><a href="#例程-4" class="headerlink" title="例程"></a>例程</h3><p>在E1.4中的hello目录下添加config.h.in文件，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello│   ├─ CMakeLists.txt│   ├─ config.h.in│   ├─ hello.h│   └─ hello.cpp└─ main.cpp</code></pre><p>hello/config.h.in</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _HELLO_CONFIG_H_</span><span class="hljs-meta">#cmakedefine HELLO_VERSION <span class="hljs-meta-string">&quot;@HELLO_VERSION@&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _HELLO_CONFIG_H_</span></span></code></pre><p>修改hello/CMakeLists.txt文件为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">set</span>(HELLO_VERSION_MAJOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_MINOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_PATCH <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION_MAJOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_MINOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_PATCH&#125;</span>)<span class="hljs-keyword">configure_file</span>(config.h.in <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h&quot;</span> @ONLY)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;    PRIVATE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>&gt;)</code></pre><p>修改hello/hello.cpp文件为</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;hello.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;config.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *what)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello %s!, version: %s\n&quot;</span>, what, HELLO_VERSION);&#125;</code></pre><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><ul><li><p><a href="https://cmake.org/cmake/help/v3.18/command/configure_file.html">configure_file</a>将config.h.in模板文件生成为config.h文件，其内容最终如下所示</p>  <pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _HELLO_CONFIG_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_VERSION <span class="hljs-meta-string">&quot;1.1.1&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _HELLO_CONFIG_H_</span></span></code></pre></li><li><p>由于config.h生成在<code>CMAKE_CURRENT_BINARY_DIR</code>目录中，故<code>target_include_directories</code>中需新增了一个include目录，并且设置为PRIVATE，防止该include目录传递到其他Target上。</p></li></ul><h2 id="E1-6-直接引用二进制库"><a href="#E1-6-直接引用二进制库" class="headerlink" title="E1.6 直接引用二进制库"></a>E1.6 直接引用二进制库</h2><h3 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h3><ul><li>了解CMake直接引用二进制库的方法</li></ul><h3 id="例程-5"><a href="#例程-5" class="headerlink" title="例程"></a>例程</h3><p>在E1.5的基础上，新建cmake文件，并将之前生成的二进制库和hello.h拷贝到其中。工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello # 此目录在本工程中无作用├─ cmake│   ├─ hello.h│   └─ hello.lib # linux下可能会其他类型的文件，如*.so└─ main.cpp</code></pre><p>修改CMakeLists.txt为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(MAIN)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">include_directories</span>(cmake)<span class="hljs-keyword">link_directories</span>(cmake)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main hello)</code></pre><h3 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>include_directories(cmake)</code>指定了MAIN工程的include文件夹，使得CMake在构建、编译时，去这些目录下查找相应的头文件。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/include_directories.html">include_directories</a></p></li><li><p><code>link_directories(cmake)</code>指定MAIN工程所依赖的库的路径，使得CMake在构建、编译时，去这些目录下查找需要的库。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/include_directories.html">link_directories</a></p></li></ul><h2 id="E1-7-通过Module模式的find-package引用二进制库"><a href="#E1-7-通过Module模式的find-package引用二进制库" class="headerlink" title="E1.7 通过Module模式的find_package引用二进制库"></a>E1.7 通过Module模式的find_package引用二进制库</h2><h3 id="目的-6"><a href="#目的-6" class="headerlink" title="目的"></a>目的</h3><ul><li><p>了解通过Module模式的find_package引用二进制库</p></li><li><p>了解find_package的用法</p></li><li><p>了解find_package的module模式</p></li></ul><h3 id="例程-6"><a href="#例程-6" class="headerlink" title="例程"></a>例程</h3><p>在E1.6的基础上，在cmake文件夹中新增Findhello.cmake文件，工程目录如下</p><pre><code class="hljs shell">.├─ CMakeLists.txt├─ hello # 此目录在本工程中无作用├─ cmake│   ├─ Findhello.cmake│   ├─ hello.h│   └─ hello.lib # linux下可能会其他类型的文件，如*.so└─ main.cpp</code></pre><p>cmake/Findhello.cmake</p><pre><code class="hljs CMake"><span class="hljs-keyword">find_path</span>(HELLO_INCLUDES hello.h <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">find_library</span>(HELLO_LIBRARIES hello.lib <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">if</span>(HELLO_INCLUDES)    <span class="hljs-keyword">set</span>(hello_FOUND <span class="hljs-number">1</span>)<span class="hljs-keyword">endif</span>()</code></pre><p>修改CMakeLists.txt为</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(main)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)<span class="hljs-keyword">find_package</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;HELLO_LIBRARIES&#125;</span>)<span class="hljs-keyword">target_include_directories</span>(main PRIVATE <span class="hljs-variable">$&#123;HELLO_INCLUDES&#125;</span>)</code></pre><h3 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h3><ul><li><p><code>find_package(hello)</code>根据<a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_MODULE_PATH.html">CMAKE_MODULE_PATH</a>中指定的路径找到<code>Findhello.cmake</code>文件，并从该文件中获取hello库相关的构建信息。具体用法见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#find-module-packages">find-module-packages</a>。</p></li><li><p><a href="https://cmake.org/cmake/help/v3.18/variable/CMAKE_CURRENT_LIST_DIR.html">CMAKE_CURRENT_LIST_DIR</a>指当前被处理的cmake文件所在目录。</p></li><li><p><code>find_path(HELLO_INCLUDES hello.h $&#123;CMAKE_CURRENT_LIST_DIR&#125;)</code>在给定目录下查找某个文件，如果找到便将该目录赋值给指定变量，在本例子中指在<code>$&#123;CMAKE_CURRENT_LIST_DIR&#125;</code>指定的目录下查找<code>hello.h</code>文件，如果找到则赋值给<code>HELLO_INCLUDES</code>变量。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/find_path.html">find_path</a></p></li><li><p><code>find_library(HELLO_LIBRARIES hello.lib $&#123;CMAKE_CURRENT_LIST_DIR&#125;)</code>的用法和<code>find_path</code>的类似，只是被赋值的变量中包含的是库文件本身，而非库文件所在的目录。具体用法见<a href="https://cmake.org/cmake/help/v3.18/command/find_library.html">find_library</a></p></li><li><p>CMake Module本身是一系列FindXXX.cmake文件，这些文件包含了库的信息（如include目录，library所在目录等），通过这些FindXXX.cmake文件和find_package命令，可以解耦引用了库的cmake工程（即应用工程中不显式存在库的目录信息）。当库稳定后，库的维护者甚至可以向cmake添加自己制作的库的FindXXX.cmake文件，如此随cmake部署时自动部署。一些随cmake安装时附带的见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-modules.7.html">Moudles</a>。</p></li></ul><h2 id="E1-8-创建Config-file-Package"><a href="#E1-8-创建Config-file-Package" class="headerlink" title="E1.8 创建Config-file Package"></a>E1.8 创建Config-file Package</h2><h3 id="目的-7"><a href="#目的-7" class="headerlink" title="目的"></a>目的</h3><ul><li><p>了解CMake的<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#config-file-packages">Config-file Package</a></p></li><li><p>了解通过Config模式的find_package引用二进制库</p></li></ul><h3 id="例程-7"><a href="#例程-7" class="headerlink" title="例程"></a>例程</h3><p>工程目录</p><pre><code class="hljs shell">. # main 工程├─ CMakeLists.txt├─ hello # hello 工程│   ├─ CMakeLists.txt│   ├─ cmake│   │   ├─ config.h.in│   │   ├─ hello-config-version.cmake.in│   │   └─ hello-config.cmake.in│   ├─ hello.h│   └─ hello.cpp├─ install└─ main.cpp</code></pre><p>hello/CMakeLists.txt</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(HELLO)<span class="hljs-keyword">set</span>(HELLO_VERSION_MAJOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_MINOR <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION_PATCH <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION_MAJOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_MINOR&#125;</span>.<span class="hljs-variable">$&#123;HELLO_VERSION_PATCH&#125;</span>)<span class="hljs-keyword">configure_file</span>(cmake/config.h.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span> @ONLY)<span class="hljs-keyword">configure_file</span>(cmake/hello-config-version.cmake.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config-version.cmake&quot;</span> @ONLY)<span class="hljs-keyword">configure_file</span>(cmake/hello-config.cmake.in <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config.cmake&quot;</span> @ONLY)<span class="hljs-keyword">add_library</span>(hello hello.cpp)<span class="hljs-keyword">target_include_directories</span>(hello     PUBLIC         $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;        $&lt;INSTALL_INTERFACE:<span class="hljs-keyword">include</span>/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>&gt;    PRIVATE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>&gt;)<span class="hljs-keyword">install</span>(TARGETS hello     <span class="hljs-keyword">EXPORT</span> hello    DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(FILES hello.h DESTINATION <span class="hljs-keyword">include</span>/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>/<span class="hljs-variable">$&#123;HELLO_INCLUDE_PREFIX&#125;</span>)<span class="hljs-keyword">install</span>(FILES <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config.cmake&quot;</span> DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(FILES <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/hello-config-version.cmake&quot;</span> DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">install</span>(<span class="hljs-keyword">EXPORT</span> hello DESTINATION lib/hello-<span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-comment"># 需要安装NSIS</span><span class="hljs-comment"># cpack -C Debug</span><span class="hljs-keyword">set</span>(CPACK_GENERATOR NSIS)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_NAME <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="hljs-string">&quot;No vendor&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_DESCRIPTION_SUMMARY <span class="hljs-string">&quot;No description&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_INSTALL_DIRECTORY <span class="hljs-string">&quot;/usr/local&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_NSIS_MODIFY_PATH <span class="hljs-keyword">ON</span>)<span class="hljs-keyword">include</span>(CPack)</code></pre><p>hello/cmake/hello-config.cmake.in</p><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<span class="hljs-keyword">include</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/hello.cmake)<span class="hljs-keyword">set</span>(hello_FOUND <span class="hljs-number">1</span>)<span class="hljs-keyword">set</span>(HELLO_LIBRARIES hello)</code></pre><p>hello/cmake/hello-config-version.cmake.in，其中被@@包围的部分为模板变量，最后会被configure_file替换为实际值。</p><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(PACKAGE_VERSION @HELLO_VERSION@)<span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MAJOR&#125;&quot;</span> <span class="hljs-keyword">EQUAL</span> <span class="hljs-string">&quot;@HELLO_VERSION_MAJOR@&quot;</span>)    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MINOR&#125;&quot;</span> <span class="hljs-keyword">EQUAL</span> <span class="hljs-string">&quot;@HELLO_VERSION_MINOR@&quot;</span>)        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_EXACT <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">elseif</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION_MINOR&#125;&quot;</span> <span class="hljs-keyword">LESS</span> <span class="hljs-string">&quot;@HELLO_VERSION_MINOR@&quot;</span>)        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_COMPATIBLE <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">else</span>()        <span class="hljs-keyword">set</span>(PACKAGE_VERSION_UNSUITABLE <span class="hljs-keyword">TRUE</span>)    <span class="hljs-keyword">endif</span>()<span class="hljs-keyword">elseif</span>(<span class="hljs-string">&quot;$&#123;PACKAGE_FIND_VERSION&#125;&quot;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Using hello @HELLO_VERSION@&quot;</span>)    <span class="hljs-keyword">set</span>(PACKAGE_VERSION_COMPATIBLE <span class="hljs-keyword">TRUE</span>)<span class="hljs-keyword">else</span>()    <span class="hljs-keyword">set</span>(PACKAGE_VERSION_UNSUITABLE <span class="hljs-keyword">TRUE</span>)<span class="hljs-keyword">endif</span>()</code></pre><p>进入hello目录下，新建build目录并进入，依次执行<code>cmake ..</code>，<code>cmake --build .</code>,<code>cpack -C Debug</code>，双击生成的<code>hello-1.1.1-win32.exe</code>安装包，将其安装到install目录下。安装完毕后会有如下目录</p><pre><code class="hljs shell">....  ├─ install│   ├─ include│   │   └─ hello-1.1.1│   │       └─ hello.h│   └─ lib│       └─ hello-1.1.1│           ├─ hello.lib│           ├─ hello.cmake # 自动生成的Target导出数据│           ├─ hello-config.cmake│           └─ hello-config-version.cmake...</code></pre><p>CMakeLists.txt</p><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<span class="hljs-keyword">project</span>(CMake_Note)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<span class="hljs-keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">install</span>)<span class="hljs-keyword">find_package</span>(hello)<span class="hljs-keyword">add_executable</span>(main main.cpp)<span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;HELLO_LIBRARIES&#125;</span>)</code></pre><p>返回main工程，用CMake构建</p><h3 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h3><ul><li><p><a href="https://cmake.org/cmake/help/v3.18/command/install.html">install</a>用于安装、导出cmake Target。<code>install(TARGETS hello EXPORT hello DESTINATION lib/hello-$&#123;HELLO_VERSION&#125;)</code>创建了hello工程中需要导出的cmake Target，这些Target记录在自动生成的hello.cmake文件中（hello.cmake的hello来源于EXPORT后头的hello，TARGETS后的hello指向的是add_library时产生的hello）。<code>install(EXPORT hello DESTINATION lib/hello-$&#123;HELLO_VERSION&#125;)</code>则实际和<code>install(FILES ...)</code>一样，将指定的文件拷贝到对应的目录中。</p></li><li><p>cpack为cmake提供的跨平台打包工具，其间接调用各个平台下的工具对软件库进行打包（如本例子中使用window下的NSIS）。具体用法见<a href="https://cmake.org/cmake/help/v3.18/manual/cpack.1.html">cpack</a>。</p><blockquote><p>可使用下面的片段生成deb包</p>  <pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CPACK_GENERATOR <span class="hljs-string">&quot;DEB&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_NAME <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="hljs-string">&quot;No vendor&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_DESCRIPTION_SUMMARY <span class="hljs-string">&quot;No description&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_VERSION <span class="hljs-variable">$&#123;HELLO_VERSION&#125;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_INSTALL_DIRECTORY <span class="hljs-string">&quot;/usr/local&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_RPM_PACKAGE_GROUP <span class="hljs-string">&quot;group name&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_RPM_PACKAGE_LICENSE <span class="hljs-string">&quot;license&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_PACKAGE_CONTACT <span class="hljs-string">&quot;email or phone number&quot;</span>)<span class="hljs-keyword">set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class="hljs-string">&quot;maintainer name&quot;</span>)<span class="hljs-keyword">include</span>(CPack)</code></pre></blockquote></li><li><p>build interface 与 install interface。Target的两种接口，Target具有某些属性，如include目录。在本例程中main Target依赖于hello Target。hello Target的公开的include属性中分别指定了build时的include目录和install后的include目录，两个include目录是不同的。当main工程通过<strong>直接包含hello工程源码来引用hello Target</strong>时，hello Target的include属性中具有<code>$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;</code>指定的include目录。当main工程通过<strong>find_package的方式引用已经安装好的hello Target</strong>时，hello Target的include属性中具有<code>$&lt;INSTALL_INTERFACE:include/hello-$&#123;HELLO_VERSION&#125;&gt;</code>指定的include目录。</p><blockquote><p>重点区别这两种interface，体会不同interface的作用</p></blockquote></li><li><p>Target的通过install命令导出，将cmake编译过程记录在某个文件中，跟随库一起发布。其他某个A工程使用find_package引用该库时，库的编译过程数据将作为输入，传递到A工程的构建过程。</p></li><li><p>hello-config-version.cmake.in文件是cmake的包版本文件（<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#package-version-file">Package Version File</a>），其命名形式一般为foo-config-version.cmake或FooConfigVersion.cmake（其中Foo为包名）。该文件一般随着包一起部署（安装），在该文件中可以通过<code>PACKAGE_FIND_VERSION</code>、<code>PACKAGE_FIND_VERSION_MAJOR</code>、<code>PACKAGE_FIND_VERSION_MINOR</code>、<code>PACKAGE_VERSION_COMPATIBLE</code>等变量来对包进行版本管理。一般在某个工程中find_package(Foo 1.1.1)后，<code>PACKAGE_FIND_VERSION</code>、<code>PACKAGE_FIND_VERSION_MAJOR</code>、<code>PACKAGE_FIND_VERSION_MINOR</code>等变量会被赋值为对应值，在判定兼容性后，设置<code>PACKAGE_VERSION_COMPATIBLE</code>为TRUE或FALSE来控制包是否可用。</p></li><li><p>hello-config.cmake.in文件是cmake的包配置文件，一般通过<code>install(EXPORT)</code>命令导出Target后会自动生成一个包配置文件，然后用hello-config.cmake.in直接包含该文件即可。本例中自动生成的文件为hello.cmake。更具体的描述见<a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html#creating-a-package-configuration-file">Creating a Package Configuration File</a></p></li></ul><h2 id="一些需求"><a href="#一些需求" class="headerlink" title="一些需求"></a>一些需求</h2><h3 id="仅头文件库"><a href="#仅头文件库" class="headerlink" title="仅头文件库"></a>仅头文件库</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>创建一个仅包含头文件的库</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(library_a INTERFACE)<span class="hljs-keyword">target_include_directories</span>(library_a     INTERFACE        $&lt;BUILD_INTERFACE:<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;        $&lt;INSTALL_INTERFACE:<span class="hljs-keyword">include</span>/library_a-<span class="hljs-variable">$&#123;LIBRARY_A_VERSION&#125;</span>&gt;)</code></pre><h3 id="拷贝库的DLL到可执行目标目录"><a href="#拷贝库的DLL到可执行目标目录" class="headerlink" title="拷贝库的DLL到可执行目标目录"></a>拷贝库的DLL到可执行目标目录</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>window平台下，应用工程引用某个动态库后，希望能够通过某种方式自动将DLL拷贝到可执行文件所在的目录下</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>在库的xxx-config.cmake.in中定义以下函数，供外部工程调用</p><pre><code class="hljs CMake"><span class="hljs-keyword">function</span>(XXX_COPY_DLL <span class="hljs-keyword">target</span>)    <span class="hljs-keyword">set</span>(XXX_DLL_FILE  <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/xxx.dll CACHE INTERNAL <span class="hljs-string">&quot;XXX_DLL_FILE&quot;</span>)    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;target&#125;</span> POST_BUILD        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo copy <span class="hljs-variable">$&#123;XXX_DLL_FILE&#125;</span> to $&lt;TARGET_FILE_DIR:<span class="hljs-variable">$&#123;target&#125;</span>&gt;        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="hljs-variable">$&#123;XXX_DLL_FILE&#125;</span> $&lt;TARGET_FILE_DIR:<span class="hljs-variable">$&#123;target&#125;</span>&gt;    )<span class="hljs-keyword">endfunction</span>()</code></pre><p>在应用工程CMakeLists.txt调用XXX_COPY_DLL</p><pre><code class="hljs CMake"><span class="hljs-keyword">add_executable</span>(app ...)<span class="hljs-keyword">target_link_libraries</span>(app xxx)XXX_COPY_DLL(app)</code></pre><h3 id="为已发布的库文件创建Target"><a href="#为已发布的库文件创建Target" class="headerlink" title="为已发布的库文件创建Target"></a>为已发布的库文件创建Target</h3><h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><p>在没有库源码的情况下针对库创建一个cmake Target</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建一个fake.cpp文件，实现空接口。构建完成之后用实际的库文件替换生成的库文件。</p><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(real SHARED fake.cpp)<span class="hljs-keyword">if</span>(UNIX)    <span class="hljs-keyword">add_custom_target</span>(cheat ALL        <span class="hljs-keyword">COMMAND</span> cp <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/real.so        <span class="hljs-comment">#</span>        <span class="hljs-comment"># 这里不能简单的用c. copy之后, ldd查看测试程序的依赖时显示real路径有问题</span>        <span class="hljs-comment"># 不知道为什么copy之后, rpath就变了</span>        <span class="hljs-comment">#</span>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-keyword">install</span> <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        <span class="hljs-keyword">COMMAND</span> rm <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        <span class="hljs-keyword">COMMAND</span> ln <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.so <span class="hljs-variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>/real.so        DEPENDS real <span class="hljs-comment"># POST BUILD作用</span>    )         <span class="hljs-keyword">elseif</span>(WIN32)    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> controlcan POST_BUILD        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E             copy_if_different <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.dll <span class="hljs-variable">$&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY&#125;</span>/real.dll        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E             copy_if_different <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ARCH&#125;</span>/real.lib <span class="hljs-variable">$&#123;CMAKE_ARCHIVE_OUTPUT_DIRECTORY&#125;</span>/real.lib    )<span class="hljs-keyword">endif</span>()</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cmake.org/cmake/help/v3.18/index.html#reference-manuals">CMake Reference Manual</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-packages.7.html">CMake Package</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-variables.7.html">CMake Variables</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-buildsystem.7.html">CMake Build System</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-modules.7.html">CMake Modules</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cmake-commands.7.html">CMake Command</a><br><a href="https://cmake.org/cmake/help/v3.18/manual/cpack.1.html">CPack</a><br><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">It’s Time To Do CMake Right</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>编译构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO入门</title>
    <link href="/2020/10/11/HEXO%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/11/HEXO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO笔记"><a href="#HEXO笔记" class="headerlink" title="HEXO笔记"></a>HEXO笔记</h1><p><a href="https://hexo.io/zh-cn/">HEXO</a><br><a href="https://hexo.io/zh-cn/docs/">HEXO docs</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署文件会生成到public目录下，注释掉.gitignore中public/，使其一同被push到仓库中。</p><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>创建文章时，文章最上方最上方以<code>---</code>分隔的区域被称为Front-matter，Front-matter用来指定个别文件的变量。举例来说：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><span class="hljs-meta">---</span></code></pre><h2 id="为文章添加标签"><a href="#为文章添加标签" class="headerlink" title="为文章添加标签"></a>为文章添加标签</h2><p>在Front-matter的tags下添加，样例：</p><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>- PS3- Games</code></pre><h2 id="主题：hexo-theme-fluid"><a href="#主题：hexo-theme-fluid" class="headerlink" title="主题：hexo-theme-fluid"></a>主题：hexo-theme-fluid</h2><p><a href="https://hexo.fluid-dev.com/">HEXO Theme Fluid</a><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">HEXO Theme Fluid Github</a></p><h3 id="创建简历页"><a href="#创建简历页" class="headerlink" title="创建简历页"></a>创建简历页</h3><ol><li><p>在<code>themes/hexo-theme-fluid/_config.yml</code>中</p><ol><li><p>搜索<code>nav</code>，在about上头添加一行</p> <pre><code class="hljs yaml"><span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;resume&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/resume/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span> &#125;</code></pre></li><li><p>添加如下内容</p><pre><code class="hljs yaml"><span class="hljs-comment">#---------------------------</span><span class="hljs-comment"># 简历页</span><span class="hljs-comment"># Resume Page</span><span class="hljs-comment">#---------------------------</span><span class="hljs-attr">resume:</span>    <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span>    <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># available: 0 - 100</span>    <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span>  <span class="hljs-comment"># available: 0 - 1.0</span>    <span class="hljs-attr">subtitle:</span>  <span class="hljs-comment"># 打字机内容</span></code></pre></li></ol></li><li><p>在<code>themes/hexo-theme-fluid/languages/zh-CN.yml</code>中搜索添加</p> <pre><code class="hljs yaml"><span class="hljs-attr">resume:</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">简历</span>  <span class="hljs-attr">subtitle:</span> <span class="hljs-string">简历</span></code></pre></li><li><p>在<a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">内置社交图标</a>中<br> 查找合适的图标，此处选<code>icon-addrcard</code></p></li><li><p>添加resume页</p><ol><li><p>执行<code>hexo new page resume</code>创建页</p></li><li><p>复制<code>themes/hexo-theme-fluid/layout/about.ejs</code>并改名为<code>resume.ejs</code>创建resume页的layout</p></li><li><p>修改<code>resume.ejs</code>为以下内容</p> <pre><code class="hljs ejs">&lt;%page.layout &#x3D; &quot;resume&quot;page.title &#x3D; theme.resume.title || __(&#39;resume.title&#39;)page.subtitle &#x3D; theme.resume.subtitle || __(&#39;resume.subtitle&#39;)page.banner_img &#x3D; theme.resume.banner_imgpage.banner_img_height &#x3D; theme.resume.banner_img_heightpage.banner_mask_alpha &#x3D; theme.resume.banner_mask_alpha%&gt;&lt;div class&#x3D;&quot;mt-5 markdown-body&quot;&gt;    &lt;%- page.content %&gt;&lt;&#x2F;div&gt;</code></pre></li><li><p>在<code>source/resume/index.md</code>中引用新添加的 <strong>resume</strong> layout</p> <pre><code class="hljs html">---title: resumedate: 2020-10-12 10:06:24layout: resume---</code></pre></li><li><p>在<code>source/resume/index.md</code>编辑简历，实验如下</p> <pre><code class="hljs vala"><span class="hljs-meta"># 简历</span></code></pre></li></ol></li></ol><h3 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h3><p>以站长身份注册一个<a href="https://tongji.baidu.com/">百度统计</a>账户，登陆后进入管理页面，新增站点。新增完毕后，在百度生成的安装代码中找到对应的key（hs?之后的字符串），将该key放到主题_config.yml中的<a href="https://hexo.fluid-dev.com/docs/guide/#%E7%BD%91%E9%A1%B5%E7%BB%9F%E8%AE%A1">web_analytics</a>部分，在<a href="https://hexo.fluid-dev.com/docs/guide/#%E5%B1%95%E7%A4%BA-pv-%E4%B8%8E-uv-%E7%BB%9F%E8%AE%A1">footer</a>中启用显示访问量的工具，在<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%97%A5%E6%9C%9F-%E5%AD%97%E6%95%B0-%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF-%E9%98%85%E8%AF%BB%E6%95%B0">post</a>启用每篇文章的阅读量显示。</p><h3 id="添加Valine评论"><a href="#添加Valine评论" class="headerlink" title="添加Valine评论"></a>添加Valine评论</h3><ol><li><p><a href="https://valine.js.org/quickstart.html">注册LeanCloud</a>。</p><blockquote><p>需实名认证</p></blockquote></li><li><p>创建应用并获取<code>App ID</code>和<code>App Key</code></p></li><li><p>在主题_config.yml的<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">post comment</a>中启用评论，并设置<code>type</code>为<code>valine</code>，在<code>valine</code>项目中配置步骤3中获取的<code>App ID</code>和<code>App Key</code>。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南</a></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/example/">操作示例</a></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/icon/">图标用法</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
